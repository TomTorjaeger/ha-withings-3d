(function(){"use strict";try{if(typeof document<"u"){var t=document.createElement("style");t.appendChild(document.createTextNode(`*,:before,:after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}:before,:after{--tw-content: ""}html,:host{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{opacity:1;color:#9ca3af}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.\\!container{width:100%!important}.container{width:100%}@media (min-width: 640px){.\\!container{max-width:640px!important}.container{max-width:640px}}@media (min-width: 768px){.\\!container{max-width:768px!important}.container{max-width:768px}}@media (min-width: 1024px){.\\!container{max-width:1024px!important}.container{max-width:1024px}}@media (min-width: 1280px){.\\!container{max-width:1280px!important}.container{max-width:1280px}}@media (min-width: 1536px){.\\!container{max-width:1536px!important}.container{max-width:1536px}}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.not-sr-only{position:static;width:auto;height:auto;padding:0;margin:0;overflow:visible;clip:auto;white-space:normal}.pointer-events-none{pointer-events:none}.pointer-events-auto{pointer-events:auto}.\\!visible{visibility:visible!important}.visible{visibility:visible}.invisible{visibility:hidden}.collapse{visibility:collapse}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.\\!relative{position:relative!important}.relative{position:relative}.sticky{position:sticky}.-inset-1{top:-.25rem;right:-.25rem;bottom:-.25rem;left:-.25rem}.-bottom-4{bottom:-1rem}.end-1{inset-inline-end:.25rem}.left-1\\/2{left:50%}.left-4{left:1rem}.start-1{inset-inline-start:.25rem}.top-4{top:1rem}.isolate{isolation:isolate}.isolation-auto{isolation:auto}.z-10{z-index:10}.float-start{float:inline-start}.float-end{float:inline-end}.float-right{float:right}.float-left{float:left}.float-none{float:none}.clear-start{clear:inline-start}.clear-end{clear:inline-end}.clear-left{clear:left}.clear-right{clear:right}.clear-both{clear:both}.clear-none{clear:none}.mb-1{margin-bottom:.25rem}.mb-2{margin-bottom:.5rem}.mb-6{margin-bottom:1.5rem}.mt-1{margin-top:.25rem}.mt-2{margin-top:.5rem}.box-border{box-sizing:border-box}.box-content{box-sizing:content-box}.line-clamp-none{overflow:visible;display:block;-webkit-box-orient:horizontal;-webkit-line-clamp:none}.\\!block{display:block!important}.block{display:block}.inline-block{display:inline-block}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.\\!table{display:table!important}.table{display:table}.inline-table{display:inline-table}.table-caption{display:table-caption}.table-cell{display:table-cell}.table-column{display:table-column}.table-column-group{display:table-column-group}.table-footer-group{display:table-footer-group}.table-header-group{display:table-header-group}.table-row-group{display:table-row-group}.table-row{display:table-row}.flow-root{display:flow-root}.\\!grid{display:grid!important}.grid{display:grid}.inline-grid{display:inline-grid}.contents{display:contents}.list-item{display:list-item}.hidden{display:none}.size-6{width:1.5rem;height:1.5rem}.h-1{height:.25rem}.h-2{height:.5rem}.h-4{height:1rem}.h-\\[500px\\]{height:500px}.h-full{height:100%}.min-h-\\[500px\\]{min-height:500px}.w-1{width:.25rem}.w-\\[this-is\\\\\\\\\\]{width:this-is\\\\}.w-\\[this-is\\]{width:this-is}.w-\\[weird-and-invalid\\]{width:weird-and-invalid}.w-full{width:100%}.min-w-\\[100px\\]{min-width:100px}.flex-shrink,.shrink{flex-shrink:1}.flex-grow,.grow{flex-grow:1}.table-auto{table-layout:auto}.table-fixed{table-layout:fixed}.caption-top{caption-side:top}.caption-bottom{caption-side:bottom}.border-collapse{border-collapse:collapse}.border-separate{border-collapse:separate}.-translate-x-1\\/2{--tw-translate-x: -50%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.\\!transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))!important}.transform,.transform-cpu{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.transform-gpu{transform:translate3d(var(--tw-translate-x),var(--tw-translate-y),0) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.transform-none{transform:none}.cursor-default{cursor:default}.touch-auto{touch-action:auto}.touch-none{touch-action:none}.touch-pan-x{--tw-pan-x: pan-x;touch-action:var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)}.touch-pan-left{--tw-pan-x: pan-left;touch-action:var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)}.touch-pan-right{--tw-pan-x: pan-right;touch-action:var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)}.touch-pan-y{--tw-pan-y: pan-y;touch-action:var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)}.touch-pan-up{--tw-pan-y: pan-up;touch-action:var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)}.touch-pan-down{--tw-pan-y: pan-down;touch-action:var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)}.touch-pinch-zoom{--tw-pinch-zoom: pinch-zoom;touch-action:var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)}.touch-manipulation{touch-action:manipulation}.select-none{-webkit-user-select:none;-moz-user-select:none;user-select:none}.select-text{-webkit-user-select:text;-moz-user-select:text;user-select:text}.select-all{-webkit-user-select:all;-moz-user-select:all;user-select:all}.select-auto{-webkit-user-select:auto;-moz-user-select:auto;user-select:auto}.resize-none{resize:none}.resize-y{resize:vertical}.resize-x{resize:horizontal}.resize{resize:both}.snap-none{scroll-snap-type:none}.snap-x{scroll-snap-type:x var(--tw-scroll-snap-strictness)}.snap-y{scroll-snap-type:y var(--tw-scroll-snap-strictness)}.snap-both{scroll-snap-type:both var(--tw-scroll-snap-strictness)}.snap-mandatory{--tw-scroll-snap-strictness: mandatory}.snap-proximity{--tw-scroll-snap-strictness: proximity}.snap-start{scroll-snap-align:start}.snap-end{scroll-snap-align:end}.snap-center{scroll-snap-align:center}.snap-align-none{scroll-snap-align:none}.snap-normal{scroll-snap-stop:normal}.snap-always{scroll-snap-stop:always}.list-inside{list-style-position:inside}.list-outside{list-style-position:outside}.appearance-none{-webkit-appearance:none;-moz-appearance:none;appearance:none}.appearance-auto{-webkit-appearance:auto;-moz-appearance:auto;appearance:auto}.break-before-auto{-moz-column-break-before:auto;break-before:auto}.break-before-avoid{-moz-column-break-before:avoid;break-before:avoid}.break-before-all{-moz-column-break-before:all;break-before:all}.break-before-avoid-page{-moz-column-break-before:avoid;break-before:avoid-page}.break-before-page{-moz-column-break-before:page;break-before:page}.break-before-left{-moz-column-break-before:left;break-before:left}.break-before-right{-moz-column-break-before:right;break-before:right}.break-before-column{-moz-column-break-before:column;break-before:column}.break-inside-auto{-moz-column-break-inside:auto;break-inside:auto}.break-inside-avoid{-moz-column-break-inside:avoid;break-inside:avoid}.break-inside-avoid-page{break-inside:avoid-page}.break-inside-avoid-column{-moz-column-break-inside:avoid;break-inside:avoid-column}.break-after-auto{-moz-column-break-after:auto;break-after:auto}.break-after-avoid{-moz-column-break-after:avoid;break-after:avoid}.break-after-all{-moz-column-break-after:all;break-after:all}.break-after-avoid-page{-moz-column-break-after:avoid;break-after:avoid-page}.break-after-page{-moz-column-break-after:page;break-after:page}.break-after-left{-moz-column-break-after:left;break-after:left}.break-after-right{-moz-column-break-after:right;break-after:right}.break-after-column{-moz-column-break-after:column;break-after:column}.grid-flow-row{grid-auto-flow:row}.grid-flow-col{grid-auto-flow:column}.grid-flow-dense{grid-auto-flow:dense}.grid-flow-row-dense{grid-auto-flow:row dense}.grid-flow-col-dense{grid-auto-flow:column dense}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.flex-row{flex-direction:row}.flex-row-reverse{flex-direction:row-reverse}.flex-col{flex-direction:column}.flex-col-reverse{flex-direction:column-reverse}.flex-wrap{flex-wrap:wrap}.flex-wrap-reverse{flex-wrap:wrap-reverse}.flex-nowrap{flex-wrap:nowrap}.place-content-center{place-content:center}.place-content-start{place-content:start}.place-content-end{place-content:end}.place-content-between{place-content:space-between}.place-content-around{place-content:space-around}.place-content-evenly{place-content:space-evenly}.place-content-baseline{place-content:baseline}.place-content-stretch{place-content:stretch}.place-items-start{place-items:start}.place-items-end{place-items:end}.place-items-center{place-items:center}.place-items-baseline{place-items:baseline}.place-items-stretch{place-items:stretch}.content-normal{align-content:normal}.content-center{align-content:center}.content-start{align-content:flex-start}.content-end{align-content:flex-end}.content-between{align-content:space-between}.content-around{align-content:space-around}.content-evenly{align-content:space-evenly}.content-baseline{align-content:baseline}.content-stretch{align-content:stretch}.items-start{align-items:flex-start}.items-end{align-items:flex-end}.items-center{align-items:center}.items-baseline{align-items:baseline}.items-stretch{align-items:stretch}.justify-normal{justify-content:normal}.justify-start{justify-content:flex-start}.justify-end{justify-content:flex-end}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.justify-around{justify-content:space-around}.justify-evenly{justify-content:space-evenly}.justify-stretch{justify-content:stretch}.justify-items-start{justify-items:start}.justify-items-end{justify-items:end}.justify-items-center{justify-items:center}.justify-items-stretch{justify-items:stretch}.gap-1{gap:.25rem}.gap-2{gap:.5rem}.gap-3{gap:.75rem}.gap-4{gap:1rem}.gap-6{gap:1.5rem}.space-x-2>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 0;margin-right:calc(.5rem * var(--tw-space-x-reverse));margin-left:calc(.5rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-reverse>:not([hidden])~:not([hidden]){--tw-space-y-reverse: 1}.space-x-reverse>:not([hidden])~:not([hidden]){--tw-space-x-reverse: 1}.divide-x>:not([hidden])~:not([hidden]){--tw-divide-x-reverse: 0;border-right-width:calc(1px * var(--tw-divide-x-reverse));border-left-width:calc(1px * calc(1 - var(--tw-divide-x-reverse)))}.divide-y>:not([hidden])~:not([hidden]){--tw-divide-y-reverse: 0;border-top-width:calc(1px * calc(1 - var(--tw-divide-y-reverse)));border-bottom-width:calc(1px * var(--tw-divide-y-reverse))}.divide-y-reverse>:not([hidden])~:not([hidden]){--tw-divide-y-reverse: 1}.divide-x-reverse>:not([hidden])~:not([hidden]){--tw-divide-x-reverse: 1}.divide-solid>:not([hidden])~:not([hidden]){border-style:solid}.divide-dashed>:not([hidden])~:not([hidden]){border-style:dashed}.divide-dotted>:not([hidden])~:not([hidden]){border-style:dotted}.divide-double>:not([hidden])~:not([hidden]){border-style:double}.divide-none>:not([hidden])~:not([hidden]){border-style:none}.place-self-auto{place-self:auto}.place-self-start{place-self:start}.place-self-end{place-self:end}.place-self-center{place-self:center}.place-self-stretch{place-self:stretch}.self-auto{align-self:auto}.self-start{align-self:flex-start}.self-end{align-self:flex-end}.self-center{align-self:center}.self-stretch{align-self:stretch}.self-baseline{align-self:baseline}.justify-self-auto{justify-self:auto}.justify-self-start{justify-self:start}.justify-self-end{justify-self:end}.justify-self-center{justify-self:center}.justify-self-stretch{justify-self:stretch}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.overflow-clip{overflow:clip}.overflow-visible{overflow:visible}.overflow-scroll{overflow:scroll}.overflow-x-auto{overflow-x:auto}.overflow-y-auto{overflow-y:auto}.overflow-x-hidden{overflow-x:hidden}.overflow-y-hidden{overflow-y:hidden}.overflow-x-clip{overflow-x:clip}.overflow-y-clip{overflow-y:clip}.overflow-x-visible{overflow-x:visible}.overflow-y-visible{overflow-y:visible}.overflow-x-scroll{overflow-x:scroll}.overflow-y-scroll{overflow-y:scroll}.overscroll-auto{overscroll-behavior:auto}.overscroll-contain{overscroll-behavior:contain}.overscroll-none{overscroll-behavior:none}.overscroll-y-auto{overscroll-behavior-y:auto}.overscroll-y-contain{overscroll-behavior-y:contain}.overscroll-y-none{overscroll-behavior-y:none}.overscroll-x-auto{overscroll-behavior-x:auto}.overscroll-x-contain{overscroll-behavior-x:contain}.overscroll-x-none{overscroll-behavior-x:none}.scroll-auto{scroll-behavior:auto}.scroll-smooth{scroll-behavior:smooth}.truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.overflow-ellipsis,.text-ellipsis{text-overflow:ellipsis}.text-clip{text-overflow:clip}.hyphens-none{-webkit-hyphens:none;hyphens:none}.hyphens-manual{-webkit-hyphens:manual;hyphens:manual}.hyphens-auto{-webkit-hyphens:auto;hyphens:auto}.whitespace-normal{white-space:normal}.whitespace-nowrap{white-space:nowrap}.whitespace-pre{white-space:pre}.whitespace-pre-line{white-space:pre-line}.whitespace-pre-wrap{white-space:pre-wrap}.whitespace-break-spaces{white-space:break-spaces}.text-wrap{text-wrap:wrap}.text-nowrap{text-wrap:nowrap}.text-balance{text-wrap:balance}.text-pretty{text-wrap:pretty}.break-normal{overflow-wrap:normal;word-break:normal}.break-words{overflow-wrap:break-word}.break-all{word-break:break-all}.break-keep{word-break:keep-all}.rounded{border-radius:.25rem}.rounded-2xl{border-radius:1rem}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:.5rem}.rounded-xl{border-radius:.75rem}.rounded-b{border-bottom-right-radius:.25rem;border-bottom-left-radius:.25rem}.rounded-e{border-start-end-radius:.25rem;border-end-end-radius:.25rem}.rounded-l{border-top-left-radius:.25rem;border-bottom-left-radius:.25rem}.rounded-r{border-top-right-radius:.25rem;border-bottom-right-radius:.25rem}.rounded-s{border-start-start-radius:.25rem;border-end-start-radius:.25rem}.rounded-t{border-top-left-radius:.25rem;border-top-right-radius:.25rem}.rounded-bl{border-bottom-left-radius:.25rem}.rounded-br{border-bottom-right-radius:.25rem}.rounded-ee{border-end-end-radius:.25rem}.rounded-es{border-end-start-radius:.25rem}.rounded-se{border-start-end-radius:.25rem}.rounded-ss{border-start-start-radius:.25rem}.rounded-tl{border-top-left-radius:.25rem}.rounded-tr{border-top-right-radius:.25rem}.border{border-width:1px}.border-x{border-left-width:1px;border-right-width:1px}.border-y{border-top-width:1px;border-bottom-width:1px}.border-b{border-bottom-width:1px}.border-e{border-inline-end-width:1px}.border-l{border-left-width:1px}.border-r{border-right-width:1px}.border-s{border-inline-start-width:1px}.border-t{border-top-width:1px}.border-solid{border-style:solid}.border-dashed{border-style:dashed}.border-dotted{border-style:dotted}.border-double{border-style:double}.border-hidden{border-style:hidden}.border-none{border-style:none}.border-white\\/10{border-color:#ffffff1a}.border-white\\/5{border-color:#ffffff0d}.bg-\\[\\#0b0f19\\]{--tw-bg-opacity: 1;background-color:rgb(11 15 25 / var(--tw-bg-opacity, 1))}.bg-\\[rgb\\(255\\,0\\,0\\)\\]{--tw-bg-opacity: 1;background-color:rgb(255 0 0 / var(--tw-bg-opacity, 1))}.bg-black\\/60{background-color:#0009}.bg-gray-700{--tw-bg-opacity: 1;background-color:rgb(55 65 81 / var(--tw-bg-opacity, 1))}.bg-gray-800\\/40{background-color:#1f293766}.bg-gray-800\\/50{background-color:#1f293780}.bg-gray-900\\/50{background-color:#11182780}.bg-green-500\\/20{background-color:#22c55e33}.bg-red-500\\/20{background-color:#ef444433}.bg-white\\/20{background-color:#fff3}.bg-yellow-500\\/20{background-color:#eab30833}.bg-gradient-to-b{background-image:linear-gradient(to bottom,var(--tw-gradient-stops))}.bg-gradient-to-r{background-image:linear-gradient(to right,var(--tw-gradient-stops))}.from-blue-400{--tw-gradient-from: #60a5fa var(--tw-gradient-from-position);--tw-gradient-to: rgb(96 165 250 / 0) var(--tw-gradient-to-position);--tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)}.from-blue-500{--tw-gradient-from: #3b82f6 var(--tw-gradient-from-position);--tw-gradient-to: rgb(59 130 246 / 0) var(--tw-gradient-to-position);--tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)}.from-gray-900{--tw-gradient-from: #111827 var(--tw-gradient-from-position);--tw-gradient-to: rgb(17 24 39 / 0) var(--tw-gradient-to-position);--tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)}.via-gray-800{--tw-gradient-to: rgb(31 41 55 / 0) var(--tw-gradient-to-position);--tw-gradient-stops: var(--tw-gradient-from), #1f2937 var(--tw-gradient-via-position), var(--tw-gradient-to)}.to-emerald-400{--tw-gradient-to: #34d399 var(--tw-gradient-to-position)}.to-gray-900{--tw-gradient-to: #111827 var(--tw-gradient-to-position)}.to-green-400{--tw-gradient-to: #4ade80 var(--tw-gradient-to-position)}.decoration-slice{-webkit-box-decoration-break:slice;box-decoration-break:slice}.decoration-clone{-webkit-box-decoration-break:clone;box-decoration-break:clone}.box-decoration-slice{-webkit-box-decoration-break:slice;box-decoration-break:slice}.box-decoration-clone{-webkit-box-decoration-break:clone;box-decoration-break:clone}.bg-fixed{background-attachment:fixed}.bg-local{background-attachment:local}.bg-scroll{background-attachment:scroll}.bg-clip-border{background-clip:border-box}.bg-clip-padding{background-clip:padding-box}.bg-clip-content{background-clip:content-box}.bg-clip-text{-webkit-background-clip:text;background-clip:text}.bg-repeat{background-repeat:repeat}.bg-no-repeat{background-repeat:no-repeat}.bg-repeat-x{background-repeat:repeat-x}.bg-repeat-y{background-repeat:repeat-y}.bg-repeat-round{background-repeat:round}.bg-repeat-space{background-repeat:space}.bg-origin-border{background-origin:border-box}.bg-origin-padding{background-origin:padding-box}.bg-origin-content{background-origin:content-box}.object-contain{-o-object-fit:contain;object-fit:contain}.object-cover{-o-object-fit:cover;object-fit:cover}.object-fill{-o-object-fit:fill;object-fit:fill}.object-none{-o-object-fit:none;object-fit:none}.object-scale-down{-o-object-fit:scale-down;object-fit:scale-down}.p-1{padding:.25rem}.p-2{padding:.5rem}.p-4{padding:1rem}.px-1{padding-left:.25rem;padding-right:.25rem}.px-1\\.5{padding-left:.375rem;padding-right:.375rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-5{padding-left:1.25rem;padding-right:1.25rem}.py-0\\.5{padding-top:.125rem;padding-bottom:.125rem}.py-1{padding-top:.25rem;padding-bottom:.25rem}.pe-1{padding-inline-end:.25rem}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}.text-justify{text-align:justify}.text-start{text-align:start}.text-end{text-align:end}.align-baseline{vertical-align:baseline}.align-top{vertical-align:top}.align-middle{vertical-align:middle}.align-bottom{vertical-align:bottom}.align-text-top{vertical-align:text-top}.align-text-bottom{vertical-align:text-bottom}.align-sub{vertical-align:sub}.align-super{vertical-align:super}.font-sans{font-family:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji"}.text-2xl{font-size:1.5rem;line-height:2rem}.text-\\[10px\\]{font-size:10px}.text-base{font-size:1rem;line-height:1.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-xs{font-size:.75rem;line-height:1rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.font-semibold{font-weight:600}.uppercase{text-transform:uppercase}.lowercase{text-transform:lowercase}.capitalize{text-transform:capitalize}.normal-case{text-transform:none}.italic{font-style:italic}.not-italic{font-style:normal}.normal-nums{font-variant-numeric:normal}.ordinal{--tw-ordinal: ordinal;font-variant-numeric:var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)}.slashed-zero{--tw-slashed-zero: slashed-zero;font-variant-numeric:var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)}.lining-nums{--tw-numeric-figure: lining-nums;font-variant-numeric:var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)}.oldstyle-nums{--tw-numeric-figure: oldstyle-nums;font-variant-numeric:var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)}.proportional-nums{--tw-numeric-spacing: proportional-nums;font-variant-numeric:var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)}.tabular-nums{--tw-numeric-spacing: tabular-nums;font-variant-numeric:var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)}.diagonal-fractions{--tw-numeric-fraction: diagonal-fractions;font-variant-numeric:var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)}.stacked-fractions{--tw-numeric-fraction: stacked-fractions;font-variant-numeric:var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)}.tracking-wider{letter-spacing:.05em}.tracking-widest{letter-spacing:.1em}.text-\\[\\#336699\\]\\/\\[\\.35\\]{color:#33669959}.text-blue-400{--tw-text-opacity: 1;color:rgb(96 165 250 / var(--tw-text-opacity, 1))}.text-blue-500{--tw-text-opacity: 1;color:rgb(59 130 246 / var(--tw-text-opacity, 1))}.text-cyan-400{--tw-text-opacity: 1;color:rgb(34 211 238 / var(--tw-text-opacity, 1))}.text-gray-200{--tw-text-opacity: 1;color:rgb(229 231 235 / var(--tw-text-opacity, 1))}.text-gray-300{--tw-text-opacity: 1;color:rgb(209 213 219 / var(--tw-text-opacity, 1))}.text-gray-400{--tw-text-opacity: 1;color:rgb(156 163 175 / var(--tw-text-opacity, 1))}.text-gray-500{--tw-text-opacity: 1;color:rgb(107 114 128 / var(--tw-text-opacity, 1))}.text-green-400{--tw-text-opacity: 1;color:rgb(74 222 128 / var(--tw-text-opacity, 1))}.text-orange-300{--tw-text-opacity: 1;color:rgb(253 186 116 / var(--tw-text-opacity, 1))}.text-orange-400{--tw-text-opacity: 1;color:rgb(251 146 60 / var(--tw-text-opacity, 1))}.text-orange-500{--tw-text-opacity: 1;color:rgb(249 115 22 / var(--tw-text-opacity, 1))}.text-purple-400{--tw-text-opacity: 1;color:rgb(192 132 252 / var(--tw-text-opacity, 1))}.text-red-400{--tw-text-opacity: 1;color:rgb(248 113 113 / var(--tw-text-opacity, 1))}.text-red-500{--tw-text-opacity: 1;color:rgb(239 68 68 / var(--tw-text-opacity, 1))}.text-transparent{color:transparent}.text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.text-white\\/40{color:#fff6}.text-white\\/80{color:#fffc}.text-yellow-200{--tw-text-opacity: 1;color:rgb(254 240 138 / var(--tw-text-opacity, 1))}.text-yellow-400{--tw-text-opacity: 1;color:rgb(250 204 21 / var(--tw-text-opacity, 1))}.text-yellow-500{--tw-text-opacity: 1;color:rgb(234 179 8 / var(--tw-text-opacity, 1))}.text-yellow-600{--tw-text-opacity: 1;color:rgb(202 138 4 / var(--tw-text-opacity, 1))}.underline{text-decoration-line:underline}.overline{text-decoration-line:overline}.line-through{text-decoration-line:line-through}.no-underline{text-decoration-line:none}.decoration-solid{text-decoration-style:solid}.decoration-double{text-decoration-style:double}.decoration-dotted{text-decoration-style:dotted}.decoration-dashed{text-decoration-style:dashed}.decoration-wavy{text-decoration-style:wavy}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.subpixel-antialiased{-webkit-font-smoothing:auto;-moz-osx-font-smoothing:auto}.opacity-70{opacity:.7}.bg-blend-normal{background-blend-mode:normal}.bg-blend-multiply{background-blend-mode:multiply}.bg-blend-screen{background-blend-mode:screen}.bg-blend-overlay{background-blend-mode:overlay}.bg-blend-darken{background-blend-mode:darken}.bg-blend-lighten{background-blend-mode:lighten}.bg-blend-color-dodge{background-blend-mode:color-dodge}.bg-blend-color-burn{background-blend-mode:color-burn}.bg-blend-hard-light{background-blend-mode:hard-light}.bg-blend-soft-light{background-blend-mode:soft-light}.bg-blend-difference{background-blend-mode:difference}.bg-blend-exclusion{background-blend-mode:exclusion}.bg-blend-hue{background-blend-mode:hue}.bg-blend-saturation{background-blend-mode:saturation}.bg-blend-color{background-blend-mode:color}.bg-blend-luminosity{background-blend-mode:luminosity}.mix-blend-normal{mix-blend-mode:normal}.mix-blend-multiply{mix-blend-mode:multiply}.mix-blend-screen{mix-blend-mode:screen}.mix-blend-overlay{mix-blend-mode:overlay}.mix-blend-darken{mix-blend-mode:darken}.mix-blend-lighten{mix-blend-mode:lighten}.mix-blend-color-dodge{mix-blend-mode:color-dodge}.mix-blend-color-burn{mix-blend-mode:color-burn}.mix-blend-hard-light{mix-blend-mode:hard-light}.mix-blend-soft-light{mix-blend-mode:soft-light}.mix-blend-difference{mix-blend-mode:difference}.mix-blend-exclusion{mix-blend-mode:exclusion}.mix-blend-hue{mix-blend-mode:hue}.mix-blend-saturation{mix-blend-mode:saturation}.mix-blend-color{mix-blend-mode:color}.mix-blend-luminosity{mix-blend-mode:luminosity}.mix-blend-plus-darker{mix-blend-mode:plus-darker}.mix-blend-plus-lighter{mix-blend-mode:plus-lighter}.\\!shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1) !important;--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color) !important;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)!important}.shadow{--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-2xl{--tw-shadow: 0 25px 50px -12px rgb(0 0 0 / .25);--tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-lg{--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);--tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline-none{outline:2px solid transparent;outline-offset:2px}.outline{outline-style:solid}.outline-dashed{outline-style:dashed}.outline-dotted{outline-style:dotted}.outline-double{outline-style:double}.ring{--tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow, 0 0 #0000)}.ring-inset{--tw-ring-inset: inset}.blur{--tw-blur: blur(8px);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.drop-shadow{--tw-drop-shadow: drop-shadow(0 1px 2px rgb(0 0 0 / .1)) drop-shadow(0 1px 1px rgb(0 0 0 / .06));filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.grayscale{--tw-grayscale: grayscale(100%);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.invert{--tw-invert: invert(100%);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.sepia{--tw-sepia: sepia(100%);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.\\!filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)!important}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.filter-none{filter:none}.backdrop-blur{--tw-backdrop-blur: blur(8px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.backdrop-blur-md{--tw-backdrop-blur: blur(12px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.backdrop-blur-sm{--tw-backdrop-blur: blur(4px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.backdrop-grayscale{--tw-backdrop-grayscale: grayscale(100%);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.backdrop-invert{--tw-backdrop-invert: invert(100%);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.backdrop-sepia{--tw-backdrop-sepia: sepia(100%);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.backdrop-filter{-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.backdrop-filter-none{-webkit-backdrop-filter:none;backdrop-filter:none}.\\!transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter!important;transition-timing-function:cubic-bezier(.4,0,.2,1)!important;transition-duration:.15s!important}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-opacity{transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.duration-1000{transition-duration:1s}.duration-300{transition-duration:.3s}.ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}.contain-none{contain:none}.contain-content{contain:content}.contain-strict{contain:strict}.contain-size{--tw-contain-size: size;contain:var(--tw-contain-size) var(--tw-contain-layout) var(--tw-contain-paint) var(--tw-contain-style)}.contain-inline-size{--tw-contain-size: inline-size;contain:var(--tw-contain-size) var(--tw-contain-layout) var(--tw-contain-paint) var(--tw-contain-style)}.contain-layout{--tw-contain-layout: layout;contain:var(--tw-contain-size) var(--tw-contain-layout) var(--tw-contain-paint) var(--tw-contain-style)}.contain-paint{--tw-contain-paint: paint;contain:var(--tw-contain-size) var(--tw-contain-layout) var(--tw-contain-paint) var(--tw-contain-style)}.contain-style{--tw-contain-style: style;contain:var(--tw-contain-size) var(--tw-contain-layout) var(--tw-contain-paint) var(--tw-contain-style)}.content-\\[\\'this-is-also-valid\\]-weirdly-enough\\'\\]{--tw-content: "this-is-also-valid]-weirdly-enough";content:var(--tw-content)}.forced-color-adjust-auto{forced-color-adjust:auto}.forced-color-adjust-none{forced-color-adjust:none}.\\[a-zA-Z0-9\\:\\\\\\\\-\\\\\\\\\\._\\$\\]{a-z-a--z0-9:\\\\-\\\\. $}.\\[vite\\:css\\]{vite:css}.\\[vite\\:html\\]{vite:html}.\\[vite\\:react-babel\\]{vite:react-babel}.withings-card-wrapper{container-type:inline-size}@media (min-width: 640px){.sm\\:container{width:100%}@media (min-width: 640px){.sm\\:container{max-width:640px}}@media (min-width: 768px){.sm\\:container{max-width:768px}}@media (min-width: 1024px){.sm\\:container{max-width:1024px}}@media (min-width: 1280px){.sm\\:container{max-width:1280px}}@media (min-width: 1536px){.sm\\:container{max-width:1536px}}}.selection\\:bg-blue-500\\/30 *::-moz-selection{background-color:#3b82f64d}.selection\\:bg-blue-500\\/30 *::selection{background-color:#3b82f64d}.selection\\:bg-blue-500\\/30::-moz-selection{background-color:#3b82f64d}.selection\\:bg-blue-500\\/30::selection{background-color:#3b82f64d}.hover\\:scale-110:hover{--tw-scale-x: 1.1;--tw-scale-y: 1.1;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.hover\\:bg-gray-800\\/80:hover{background-color:#1f2937cc}.hover\\:font-bold:hover{font-weight:700}.before\\:hover\\:text-center:hover:before{content:var(--tw-content);text-align:center}.hover\\:before\\:text-center:hover:before{content:var(--tw-content);text-align:center}.focus\\:hover\\:text-center:hover:focus{text-align:center}.hover\\:focus\\:text-center:focus:hover{text-align:center}.group:hover .group-hover\\:opacity-100{opacity:1}@media (min-width: 640px){.sm\\:grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.sm\\:underline{text-decoration-line:underline}}@media (min-width: 768px){.md\\:grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}.md\\:grid-cols-5{grid-template-columns:repeat(5,minmax(0,1fr))}}@media (min-width: 1280px){.xl\\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}}@media (prefers-color-scheme: dark){@media (min-width: 1024px){.dark\\:lg\\:hover\\:\\[paint-order\\:markers\\]:hover{paint-order:markers}}}`)),document.head.appendChild(t)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
function Tw(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var Aw = { exports: {} }, sp = {}, Cw = { exports: {} }, Tt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Bc = Symbol.for("react.element"), rR = Symbol.for("react.portal"), sR = Symbol.for("react.fragment"), oR = Symbol.for("react.strict_mode"), aR = Symbol.for("react.profiler"), lR = Symbol.for("react.provider"), uR = Symbol.for("react.context"), cR = Symbol.for("react.forward_ref"), fR = Symbol.for("react.suspense"), hR = Symbol.for("react.memo"), dR = Symbol.for("react.lazy"), w1 = Symbol.iterator;
function pR(n) {
  return n === null || typeof n != "object" ? null : (n = w1 && n[w1] || n["@@iterator"], typeof n == "function" ? n : null);
}
var Rw = { isMounted: function() {
  return !1;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, Pw = Object.assign, bw = {};
function Xl(n, e, t) {
  this.props = n, this.context = e, this.refs = bw, this.updater = t || Rw;
}
Xl.prototype.isReactComponent = {};
Xl.prototype.setState = function(n, e) {
  if (typeof n != "object" && typeof n != "function" && n != null)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, n, e, "setState");
};
Xl.prototype.forceUpdate = function(n) {
  this.updater.enqueueForceUpdate(this, n, "forceUpdate");
};
function Lw() {
}
Lw.prototype = Xl.prototype;
function ry(n, e, t) {
  this.props = n, this.context = e, this.refs = bw, this.updater = t || Rw;
}
var sy = ry.prototype = new Lw();
sy.constructor = ry;
Pw(sy, Xl.prototype);
sy.isPureReactComponent = !0;
var E1 = Array.isArray, Iw = Object.prototype.hasOwnProperty, oy = { current: null }, Nw = { key: !0, ref: !0, __self: !0, __source: !0 };
function Dw(n, e, t) {
  var i, r = {}, s = null, o = null;
  if (e != null)
    for (i in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e)
      Iw.call(e, i) && !Nw.hasOwnProperty(i) && (r[i] = e[i]);
  var l = arguments.length - 2;
  if (l === 1)
    r.children = t;
  else if (1 < l) {
    for (var c = Array(l), f = 0; f < l; f++)
      c[f] = arguments[f + 2];
    r.children = c;
  }
  if (n && n.defaultProps)
    for (i in l = n.defaultProps, l)
      r[i] === void 0 && (r[i] = l[i]);
  return { $$typeof: Bc, type: n, key: s, ref: o, props: r, _owner: oy.current };
}
function mR(n, e) {
  return { $$typeof: Bc, type: n.type, key: e, ref: n.ref, props: n.props, _owner: n._owner };
}
function ay(n) {
  return typeof n == "object" && n !== null && n.$$typeof === Bc;
}
function gR(n) {
  var e = { "=": "=0", ":": "=2" };
  return "$" + n.replace(/[=:]/g, function(t) {
    return e[t];
  });
}
var T1 = /\/+/g;
function rg(n, e) {
  return typeof n == "object" && n !== null && n.key != null ? gR("" + n.key) : e.toString(36);
}
function ld(n, e, t, i, r) {
  var s = typeof n;
  (s === "undefined" || s === "boolean") && (n = null);
  var o = !1;
  if (n === null)
    o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (n.$$typeof) {
          case Bc:
          case rR:
            o = !0;
        }
    }
  if (o)
    return o = n, r = r(o), n = i === "" ? "." + rg(o, 0) : i, E1(r) ? (t = "", n != null && (t = n.replace(T1, "$&/") + "/"), ld(r, e, t, "", function(f) {
      return f;
    })) : r != null && (ay(r) && (r = mR(r, t + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(T1, "$&/") + "/") + n)), e.push(r)), 1;
  if (o = 0, i = i === "" ? "." : i + ":", E1(n))
    for (var l = 0; l < n.length; l++) {
      s = n[l];
      var c = i + rg(s, l);
      o += ld(s, e, t, c, r);
    }
  else if (c = pR(n), typeof c == "function")
    for (n = c.call(n), l = 0; !(s = n.next()).done; )
      s = s.value, c = i + rg(s, l++), o += ld(s, e, t, c, r);
  else if (s === "object")
    throw e = String(n), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
  return o;
}
function eh(n, e, t) {
  if (n == null)
    return n;
  var i = [], r = 0;
  return ld(n, i, "", "", function(s) {
    return e.call(t, s, r++);
  }), i;
}
function vR(n) {
  if (n._status === -1) {
    var e = n._result;
    e = e(), e.then(function(t) {
      (n._status === 0 || n._status === -1) && (n._status = 1, n._result = t);
    }, function(t) {
      (n._status === 0 || n._status === -1) && (n._status = 2, n._result = t);
    }), n._status === -1 && (n._status = 0, n._result = e);
  }
  if (n._status === 1)
    return n._result.default;
  throw n._result;
}
var li = { current: null }, ud = { transition: null }, yR = { ReactCurrentDispatcher: li, ReactCurrentBatchConfig: ud, ReactCurrentOwner: oy };
function Uw() {
  throw Error("act(...) is not supported in production builds of React.");
}
Tt.Children = { map: eh, forEach: function(n, e, t) {
  eh(n, function() {
    e.apply(this, arguments);
  }, t);
}, count: function(n) {
  var e = 0;
  return eh(n, function() {
    e++;
  }), e;
}, toArray: function(n) {
  return eh(n, function(e) {
    return e;
  }) || [];
}, only: function(n) {
  if (!ay(n))
    throw Error("React.Children.only expected to receive a single React element child.");
  return n;
} };
Tt.Component = Xl;
Tt.Fragment = sR;
Tt.Profiler = aR;
Tt.PureComponent = ry;
Tt.StrictMode = oR;
Tt.Suspense = fR;
Tt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = yR;
Tt.act = Uw;
Tt.cloneElement = function(n, e, t) {
  if (n == null)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n + ".");
  var i = Pw({}, n.props), r = n.key, s = n.ref, o = n._owner;
  if (e != null) {
    if (e.ref !== void 0 && (s = e.ref, o = oy.current), e.key !== void 0 && (r = "" + e.key), n.type && n.type.defaultProps)
      var l = n.type.defaultProps;
    for (c in e)
      Iw.call(e, c) && !Nw.hasOwnProperty(c) && (i[c] = e[c] === void 0 && l !== void 0 ? l[c] : e[c]);
  }
  var c = arguments.length - 2;
  if (c === 1)
    i.children = t;
  else if (1 < c) {
    l = Array(c);
    for (var f = 0; f < c; f++)
      l[f] = arguments[f + 2];
    i.children = l;
  }
  return { $$typeof: Bc, type: n.type, key: r, ref: s, props: i, _owner: o };
};
Tt.createContext = function(n) {
  return n = { $$typeof: uR, _currentValue: n, _currentValue2: n, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, n.Provider = { $$typeof: lR, _context: n }, n.Consumer = n;
};
Tt.createElement = Dw;
Tt.createFactory = function(n) {
  var e = Dw.bind(null, n);
  return e.type = n, e;
};
Tt.createRef = function() {
  return { current: null };
};
Tt.forwardRef = function(n) {
  return { $$typeof: cR, render: n };
};
Tt.isValidElement = ay;
Tt.lazy = function(n) {
  return { $$typeof: dR, _payload: { _status: -1, _result: n }, _init: vR };
};
Tt.memo = function(n, e) {
  return { $$typeof: hR, type: n, compare: e === void 0 ? null : e };
};
Tt.startTransition = function(n) {
  var e = ud.transition;
  ud.transition = {};
  try {
    n();
  } finally {
    ud.transition = e;
  }
};
Tt.unstable_act = Uw;
Tt.useCallback = function(n, e) {
  return li.current.useCallback(n, e);
};
Tt.useContext = function(n) {
  return li.current.useContext(n);
};
Tt.useDebugValue = function() {
};
Tt.useDeferredValue = function(n) {
  return li.current.useDeferredValue(n);
};
Tt.useEffect = function(n, e) {
  return li.current.useEffect(n, e);
};
Tt.useId = function() {
  return li.current.useId();
};
Tt.useImperativeHandle = function(n, e, t) {
  return li.current.useImperativeHandle(n, e, t);
};
Tt.useInsertionEffect = function(n, e) {
  return li.current.useInsertionEffect(n, e);
};
Tt.useLayoutEffect = function(n, e) {
  return li.current.useLayoutEffect(n, e);
};
Tt.useMemo = function(n, e) {
  return li.current.useMemo(n, e);
};
Tt.useReducer = function(n, e, t) {
  return li.current.useReducer(n, e, t);
};
Tt.useRef = function(n) {
  return li.current.useRef(n);
};
Tt.useState = function(n) {
  return li.current.useState(n);
};
Tt.useSyncExternalStore = function(n, e, t) {
  return li.current.useSyncExternalStore(n, e, t);
};
Tt.useTransition = function() {
  return li.current.useTransition();
};
Tt.version = "18.3.1";
Cw.exports = Tt;
var xe = Cw.exports;
const _R = /* @__PURE__ */ Tw(xe);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xR = xe, SR = Symbol.for("react.element"), MR = Symbol.for("react.fragment"), wR = Object.prototype.hasOwnProperty, ER = xR.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, TR = { key: !0, ref: !0, __self: !0, __source: !0 };
function Ow(n, e, t) {
  var i, r = {}, s = null, o = null;
  t !== void 0 && (s = "" + t), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref);
  for (i in e)
    wR.call(e, i) && !TR.hasOwnProperty(i) && (r[i] = e[i]);
  if (n && n.defaultProps)
    for (i in e = n.defaultProps, e)
      r[i] === void 0 && (r[i] = e[i]);
  return { $$typeof: SR, type: n, key: s, ref: o, props: r, _owner: ER.current };
}
sp.Fragment = MR;
sp.jsx = Ow;
sp.jsxs = Ow;
Aw.exports = sp;
var se = Aw.exports, v0 = {}, kw = { exports: {} }, Fi = {}, Fw = { exports: {} }, zw = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
  function e(O, X) {
    var W = O.length;
    O.push(X);
    e:
      for (; 0 < W; ) {
        var V = W - 1 >>> 1, j = O[V];
        if (0 < r(j, X))
          O[V] = X, O[W] = j, W = V;
        else
          break e;
      }
  }
  function t(O) {
    return O.length === 0 ? null : O[0];
  }
  function i(O) {
    if (O.length === 0)
      return null;
    var X = O[0], W = O.pop();
    if (W !== X) {
      O[0] = W;
      e:
        for (var V = 0, j = O.length, de = j >>> 1; V < de; ) {
          var ye = 2 * (V + 1) - 1, Te = O[ye], Ie = ye + 1, Be = O[Ie];
          if (0 > r(Te, W))
            Ie < j && 0 > r(Be, Te) ? (O[V] = Be, O[Ie] = W, V = Ie) : (O[V] = Te, O[ye] = W, V = ye);
          else if (Ie < j && 0 > r(Be, W))
            O[V] = Be, O[Ie] = W, V = Ie;
          else
            break e;
        }
    }
    return X;
  }
  function r(O, X) {
    var W = O.sortIndex - X.sortIndex;
    return W !== 0 ? W : O.id - X.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function() {
      return s.now();
    };
  } else {
    var o = Date, l = o.now();
    n.unstable_now = function() {
      return o.now() - l;
    };
  }
  var c = [], f = [], h = 1, d = null, m = 3, v = !1, _ = !1, w = !1, M = typeof setTimeout == "function" ? setTimeout : null, g = typeof clearTimeout == "function" ? clearTimeout : null, x = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(O) {
    for (var X = t(f); X !== null; ) {
      if (X.callback === null)
        i(f);
      else if (X.startTime <= O)
        i(f), X.sortIndex = X.expirationTime, e(c, X);
      else
        break;
      X = t(f);
    }
  }
  function T(O) {
    if (w = !1, S(O), !_)
      if (t(c) !== null)
        _ = !0, oe(C);
      else {
        var X = t(f);
        X !== null && ne(T, X.startTime - O);
      }
  }
  function C(O, X) {
    _ = !1, w && (w = !1, g(N), N = -1), v = !0;
    var W = m;
    try {
      for (S(X), d = t(c); d !== null && (!(d.expirationTime > X) || O && !G()); ) {
        var V = d.callback;
        if (typeof V == "function") {
          d.callback = null, m = d.priorityLevel;
          var j = V(d.expirationTime <= X);
          X = n.unstable_now(), typeof j == "function" ? d.callback = j : d === t(c) && i(c), S(X);
        } else
          i(c);
        d = t(c);
      }
      if (d !== null)
        var de = !0;
      else {
        var ye = t(f);
        ye !== null && ne(T, ye.startTime - X), de = !1;
      }
      return de;
    } finally {
      d = null, m = W, v = !1;
    }
  }
  var P = !1, L = null, N = -1, R = 5, b = -1;
  function G() {
    return !(n.unstable_now() - b < R);
  }
  function $() {
    if (L !== null) {
      var O = n.unstable_now();
      b = O;
      var X = !0;
      try {
        X = L(!0, O);
      } finally {
        X ? Y() : (P = !1, L = null);
      }
    } else
      P = !1;
  }
  var Y;
  if (typeof x == "function")
    Y = function() {
      x($);
    };
  else if (typeof MessageChannel < "u") {
    var K = new MessageChannel(), J = K.port2;
    K.port1.onmessage = $, Y = function() {
      J.postMessage(null);
    };
  } else
    Y = function() {
      M($, 0);
    };
  function oe(O) {
    L = O, P || (P = !0, Y());
  }
  function ne(O, X) {
    N = M(function() {
      O(n.unstable_now());
    }, X);
  }
  n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(O) {
    O.callback = null;
  }, n.unstable_continueExecution = function() {
    _ || v || (_ = !0, oe(C));
  }, n.unstable_forceFrameRate = function(O) {
    0 > O || 125 < O ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : R = 0 < O ? Math.floor(1e3 / O) : 5;
  }, n.unstable_getCurrentPriorityLevel = function() {
    return m;
  }, n.unstable_getFirstCallbackNode = function() {
    return t(c);
  }, n.unstable_next = function(O) {
    switch (m) {
      case 1:
      case 2:
      case 3:
        var X = 3;
        break;
      default:
        X = m;
    }
    var W = m;
    m = X;
    try {
      return O();
    } finally {
      m = W;
    }
  }, n.unstable_pauseExecution = function() {
  }, n.unstable_requestPaint = function() {
  }, n.unstable_runWithPriority = function(O, X) {
    switch (O) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        O = 3;
    }
    var W = m;
    m = O;
    try {
      return X();
    } finally {
      m = W;
    }
  }, n.unstable_scheduleCallback = function(O, X, W) {
    var V = n.unstable_now();
    switch (typeof W == "object" && W !== null ? (W = W.delay, W = typeof W == "number" && 0 < W ? V + W : V) : W = V, O) {
      case 1:
        var j = -1;
        break;
      case 2:
        j = 250;
        break;
      case 5:
        j = 1073741823;
        break;
      case 4:
        j = 1e4;
        break;
      default:
        j = 5e3;
    }
    return j = W + j, O = { id: h++, callback: X, priorityLevel: O, startTime: W, expirationTime: j, sortIndex: -1 }, W > V ? (O.sortIndex = W, e(f, O), t(c) === null && O === t(f) && (w ? (g(N), N = -1) : w = !0, ne(T, W - V))) : (O.sortIndex = j, e(c, O), _ || v || (_ = !0, oe(C))), O;
  }, n.unstable_shouldYield = G, n.unstable_wrapCallback = function(O) {
    var X = m;
    return function() {
      var W = m;
      m = X;
      try {
        return O.apply(this, arguments);
      } finally {
        m = W;
      }
    };
  };
})(zw);
Fw.exports = zw;
var AR = Fw.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var CR = xe, ki = AR;
function Ee(n) {
  for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1; t < arguments.length; t++)
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return "Minified React error #" + n + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var Bw = /* @__PURE__ */ new Set(), sc = {};
function da(n, e) {
  Nl(n, e), Nl(n + "Capture", e);
}
function Nl(n, e) {
  for (sc[n] = e, n = 0; n < e.length; n++)
    Bw.add(e[n]);
}
var ys = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), y0 = Object.prototype.hasOwnProperty, RR = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, A1 = {}, C1 = {};
function PR(n) {
  return y0.call(C1, n) ? !0 : y0.call(A1, n) ? !1 : RR.test(n) ? C1[n] = !0 : (A1[n] = !0, !1);
}
function bR(n, e, t, i) {
  if (t !== null && t.type === 0)
    return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return i ? !1 : t !== null ? !t.acceptsBooleans : (n = n.toLowerCase().slice(0, 5), n !== "data-" && n !== "aria-");
    default:
      return !1;
  }
}
function LR(n, e, t, i) {
  if (e === null || typeof e > "u" || bR(n, e, t, i))
    return !0;
  if (i)
    return !1;
  if (t !== null)
    switch (t.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function ui(n, e, t, i, r, s, o) {
  this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = i, this.attributeNamespace = r, this.mustUseProperty = t, this.propertyName = n, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o;
}
var zn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n) {
  zn[n] = new ui(n, 0, !1, n, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n) {
  var e = n[0];
  zn[e] = new ui(e, 1, !1, n[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
  zn[n] = new ui(n, 2, !1, n.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
  zn[n] = new ui(n, 2, !1, n, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n) {
  zn[n] = new ui(n, 3, !1, n.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function(n) {
  zn[n] = new ui(n, 3, !0, n, null, !1, !1);
});
["capture", "download"].forEach(function(n) {
  zn[n] = new ui(n, 4, !1, n, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function(n) {
  zn[n] = new ui(n, 6, !1, n, null, !1, !1);
});
["rowSpan", "start"].forEach(function(n) {
  zn[n] = new ui(n, 5, !1, n.toLowerCase(), null, !1, !1);
});
var ly = /[\-:]([a-z])/g;
function uy(n) {
  return n[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n) {
  var e = n.replace(
    ly,
    uy
  );
  zn[e] = new ui(e, 1, !1, n, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n) {
  var e = n.replace(ly, uy);
  zn[e] = new ui(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(n) {
  var e = n.replace(ly, uy);
  zn[e] = new ui(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function(n) {
  zn[n] = new ui(n, 1, !1, n.toLowerCase(), null, !1, !1);
});
zn.xlinkHref = new ui("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(n) {
  zn[n] = new ui(n, 1, !1, n.toLowerCase(), null, !0, !0);
});
function cy(n, e, t, i) {
  var r = zn.hasOwnProperty(e) ? zn[e] : null;
  (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (LR(e, t, r, i) && (t = null), i || r === null ? PR(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t)) : r.mustUseProperty ? n[r.propertyName] = t === null ? r.type === 3 ? !1 : "" : t : (e = r.attributeName, i = r.attributeNamespace, t === null ? n.removeAttribute(e) : (r = r.type, t = r === 3 || r === 4 && t === !0 ? "" : "" + t, i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))));
}
var Es = CR.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, th = Symbol.for("react.element"), ll = Symbol.for("react.portal"), ul = Symbol.for("react.fragment"), fy = Symbol.for("react.strict_mode"), _0 = Symbol.for("react.profiler"), Hw = Symbol.for("react.provider"), Vw = Symbol.for("react.context"), hy = Symbol.for("react.forward_ref"), x0 = Symbol.for("react.suspense"), S0 = Symbol.for("react.suspense_list"), dy = Symbol.for("react.memo"), Vs = Symbol.for("react.lazy"), Gw = Symbol.for("react.offscreen"), R1 = Symbol.iterator;
function yu(n) {
  return n === null || typeof n != "object" ? null : (n = R1 && n[R1] || n["@@iterator"], typeof n == "function" ? n : null);
}
var tn = Object.assign, sg;
function Fu(n) {
  if (sg === void 0)
    try {
      throw Error();
    } catch (t) {
      var e = t.stack.trim().match(/\n( *(at )?)/);
      sg = e && e[1] || "";
    }
  return `
` + sg + n;
}
var og = !1;
function ag(n, e) {
  if (!n || og)
    return "";
  og = !0;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (e = function() {
        throw Error();
      }, Object.defineProperty(e.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(e, []);
        } catch (f) {
          var i = f;
        }
        Reflect.construct(n, [], e);
      } else {
        try {
          e.call();
        } catch (f) {
          i = f;
        }
        n.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (f) {
        i = f;
      }
      n();
    }
  } catch (f) {
    if (f && i && typeof f.stack == "string") {
      for (var r = f.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, l = s.length - 1; 1 <= o && 0 <= l && r[o] !== s[l]; )
        l--;
      for (; 1 <= o && 0 <= l; o--, l--)
        if (r[o] !== s[l]) {
          if (o !== 1 || l !== 1)
            do
              if (o--, l--, 0 > l || r[o] !== s[l]) {
                var c = `
` + r[o].replace(" at new ", " at ");
                return n.displayName && c.includes("<anonymous>") && (c = c.replace("<anonymous>", n.displayName)), c;
              }
            while (1 <= o && 0 <= l);
          break;
        }
    }
  } finally {
    og = !1, Error.prepareStackTrace = t;
  }
  return (n = n ? n.displayName || n.name : "") ? Fu(n) : "";
}
function IR(n) {
  switch (n.tag) {
    case 5:
      return Fu(n.type);
    case 16:
      return Fu("Lazy");
    case 13:
      return Fu("Suspense");
    case 19:
      return Fu("SuspenseList");
    case 0:
    case 2:
    case 15:
      return n = ag(n.type, !1), n;
    case 11:
      return n = ag(n.type.render, !1), n;
    case 1:
      return n = ag(n.type, !0), n;
    default:
      return "";
  }
}
function M0(n) {
  if (n == null)
    return null;
  if (typeof n == "function")
    return n.displayName || n.name || null;
  if (typeof n == "string")
    return n;
  switch (n) {
    case ul:
      return "Fragment";
    case ll:
      return "Portal";
    case _0:
      return "Profiler";
    case fy:
      return "StrictMode";
    case x0:
      return "Suspense";
    case S0:
      return "SuspenseList";
  }
  if (typeof n == "object")
    switch (n.$$typeof) {
      case Vw:
        return (n.displayName || "Context") + ".Consumer";
      case Hw:
        return (n._context.displayName || "Context") + ".Provider";
      case hy:
        var e = n.render;
        return n = n.displayName, n || (n = e.displayName || e.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n;
      case dy:
        return e = n.displayName || null, e !== null ? e : M0(n.type) || "Memo";
      case Vs:
        e = n._payload, n = n._init;
        try {
          return M0(n(e));
        } catch {
        }
    }
  return null;
}
function NR(n) {
  var e = n.type;
  switch (n.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return n = e.render, n = n.displayName || n.name || "", e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return M0(e);
    case 8:
      return e === fy ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
  }
  return null;
}
function oo(n) {
  switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n;
    case "object":
      return n;
    default:
      return "";
  }
}
function Ww(n) {
  var e = n.type;
  return (n = n.nodeName) && n.toLowerCase() === "input" && (e === "checkbox" || e === "radio");
}
function DR(n) {
  var e = Ww(n) ? "checked" : "value", t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e), i = "" + n[e];
  if (!n.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") {
    var r = t.get, s = t.set;
    return Object.defineProperty(n, e, { configurable: !0, get: function() {
      return r.call(this);
    }, set: function(o) {
      i = "" + o, s.call(this, o);
    } }), Object.defineProperty(n, e, { enumerable: t.enumerable }), { getValue: function() {
      return i;
    }, setValue: function(o) {
      i = "" + o;
    }, stopTracking: function() {
      n._valueTracker = null, delete n[e];
    } };
  }
}
function nh(n) {
  n._valueTracker || (n._valueTracker = DR(n));
}
function Xw(n) {
  if (!n)
    return !1;
  var e = n._valueTracker;
  if (!e)
    return !0;
  var t = e.getValue(), i = "";
  return n && (i = Ww(n) ? n.checked ? "true" : "false" : n.value), n = i, n !== t ? (e.setValue(n), !0) : !1;
}
function Pd(n) {
  if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u")
    return null;
  try {
    return n.activeElement || n.body;
  } catch {
    return n.body;
  }
}
function w0(n, e) {
  var t = e.checked;
  return tn({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: t ?? n._wrapperState.initialChecked });
}
function P1(n, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue, i = e.checked != null ? e.checked : e.defaultChecked;
  t = oo(e.value != null ? e.value : t), n._wrapperState = { initialChecked: i, initialValue: t, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null };
}
function jw(n, e) {
  e = e.checked, e != null && cy(n, "checked", e, !1);
}
function E0(n, e) {
  jw(n, e);
  var t = oo(e.value), i = e.type;
  if (t != null)
    i === "number" ? (t === 0 && n.value === "" || n.value != t) && (n.value = "" + t) : n.value !== "" + t && (n.value = "" + t);
  else if (i === "submit" || i === "reset") {
    n.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value") ? T0(n, e.type, t) : e.hasOwnProperty("defaultValue") && T0(n, e.type, oo(e.defaultValue)), e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked);
}
function b1(n, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null))
      return;
    e = "" + n._wrapperState.initialValue, t || e === n.value || (n.value = e), n.defaultValue = e;
  }
  t = n.name, t !== "" && (n.name = ""), n.defaultChecked = !!n._wrapperState.initialChecked, t !== "" && (n.name = t);
}
function T0(n, e, t) {
  (e !== "number" || Pd(n.ownerDocument) !== n) && (t == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + t && (n.defaultValue = "" + t));
}
var zu = Array.isArray;
function Tl(n, e, t, i) {
  if (n = n.options, e) {
    e = {};
    for (var r = 0; r < t.length; r++)
      e["$" + t[r]] = !0;
    for (t = 0; t < n.length; t++)
      r = e.hasOwnProperty("$" + n[t].value), n[t].selected !== r && (n[t].selected = r), r && i && (n[t].defaultSelected = !0);
  } else {
    for (t = "" + oo(t), e = null, r = 0; r < n.length; r++) {
      if (n[r].value === t) {
        n[r].selected = !0, i && (n[r].defaultSelected = !0);
        return;
      }
      e !== null || n[r].disabled || (e = n[r]);
    }
    e !== null && (e.selected = !0);
  }
}
function A0(n, e) {
  if (e.dangerouslySetInnerHTML != null)
    throw Error(Ee(91));
  return tn({}, e, { value: void 0, defaultValue: void 0, children: "" + n._wrapperState.initialValue });
}
function L1(n, e) {
  var t = e.value;
  if (t == null) {
    if (t = e.children, e = e.defaultValue, t != null) {
      if (e != null)
        throw Error(Ee(92));
      if (zu(t)) {
        if (1 < t.length)
          throw Error(Ee(93));
        t = t[0];
      }
      e = t;
    }
    e == null && (e = ""), t = e;
  }
  n._wrapperState = { initialValue: oo(t) };
}
function Yw(n, e) {
  var t = oo(e.value), i = oo(e.defaultValue);
  t != null && (t = "" + t, t !== n.value && (n.value = t), e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)), i != null && (n.defaultValue = "" + i);
}
function I1(n) {
  var e = n.textContent;
  e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e);
}
function qw(n) {
  switch (n) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function C0(n, e) {
  return n == null || n === "http://www.w3.org/1999/xhtml" ? qw(e) : n === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n;
}
var ih, Zw = function(n) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, t, i, r) {
    MSApp.execUnsafeLocalFunction(function() {
      return n(e, t, i, r);
    });
  } : n;
}(function(n, e) {
  if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
    n.innerHTML = e;
  else {
    for (ih = ih || document.createElement("div"), ih.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = ih.firstChild; n.firstChild; )
      n.removeChild(n.firstChild);
    for (; e.firstChild; )
      n.appendChild(e.firstChild);
  }
});
function oc(n, e) {
  if (e) {
    var t = n.firstChild;
    if (t && t === n.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n.textContent = e;
}
var Wu = {
  animationIterationCount: !0,
  aspectRatio: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
}, UR = ["Webkit", "ms", "Moz", "O"];
Object.keys(Wu).forEach(function(n) {
  UR.forEach(function(e) {
    e = e + n.charAt(0).toUpperCase() + n.substring(1), Wu[e] = Wu[n];
  });
});
function Kw(n, e, t) {
  return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || Wu.hasOwnProperty(n) && Wu[n] ? ("" + e).trim() : e + "px";
}
function Jw(n, e) {
  n = n.style;
  for (var t in e)
    if (e.hasOwnProperty(t)) {
      var i = t.indexOf("--") === 0, r = Kw(t, e[t], i);
      t === "float" && (t = "cssFloat"), i ? n.setProperty(t, r) : n[t] = r;
    }
}
var OR = tn({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function R0(n, e) {
  if (e) {
    if (OR[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(Ee(137, n));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null)
        throw Error(Ee(60));
      if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML))
        throw Error(Ee(61));
    }
    if (e.style != null && typeof e.style != "object")
      throw Error(Ee(62));
  }
}
function P0(n, e) {
  if (n.indexOf("-") === -1)
    return typeof e.is == "string";
  switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var b0 = null;
function py(n) {
  return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n;
}
var L0 = null, Al = null, Cl = null;
function N1(n) {
  if (n = Gc(n)) {
    if (typeof L0 != "function")
      throw Error(Ee(280));
    var e = n.stateNode;
    e && (e = cp(e), L0(n.stateNode, n.type, e));
  }
}
function Qw(n) {
  Al ? Cl ? Cl.push(n) : Cl = [n] : Al = n;
}
function $w() {
  if (Al) {
    var n = Al, e = Cl;
    if (Cl = Al = null, N1(n), e)
      for (n = 0; n < e.length; n++)
        N1(e[n]);
  }
}
function eE(n, e) {
  return n(e);
}
function tE() {
}
var lg = !1;
function nE(n, e, t) {
  if (lg)
    return n(e, t);
  lg = !0;
  try {
    return eE(n, e, t);
  } finally {
    lg = !1, (Al !== null || Cl !== null) && (tE(), $w());
  }
}
function ac(n, e) {
  var t = n.stateNode;
  if (t === null)
    return null;
  var i = cp(t);
  if (i === null)
    return null;
  t = i[e];
  e:
    switch (e) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (i = !i.disabled) || (n = n.type, i = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !i;
        break e;
      default:
        n = !1;
    }
  if (n)
    return null;
  if (t && typeof t != "function")
    throw Error(Ee(231, e, typeof t));
  return t;
}
var I0 = !1;
if (ys)
  try {
    var _u = {};
    Object.defineProperty(_u, "passive", { get: function() {
      I0 = !0;
    } }), window.addEventListener("test", _u, _u), window.removeEventListener("test", _u, _u);
  } catch {
    I0 = !1;
  }
function kR(n, e, t, i, r, s, o, l, c) {
  var f = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, f);
  } catch (h) {
    this.onError(h);
  }
}
var Xu = !1, bd = null, Ld = !1, N0 = null, FR = { onError: function(n) {
  Xu = !0, bd = n;
} };
function zR(n, e, t, i, r, s, o, l, c) {
  Xu = !1, bd = null, kR.apply(FR, arguments);
}
function BR(n, e, t, i, r, s, o, l, c) {
  if (zR.apply(this, arguments), Xu) {
    if (Xu) {
      var f = bd;
      Xu = !1, bd = null;
    } else
      throw Error(Ee(198));
    Ld || (Ld = !0, N0 = f);
  }
}
function pa(n) {
  var e = n, t = n;
  if (n.alternate)
    for (; e.return; )
      e = e.return;
  else {
    n = e;
    do
      e = n, e.flags & 4098 && (t = e.return), n = e.return;
    while (n);
  }
  return e.tag === 3 ? t : null;
}
function iE(n) {
  if (n.tag === 13) {
    var e = n.memoizedState;
    if (e === null && (n = n.alternate, n !== null && (e = n.memoizedState)), e !== null)
      return e.dehydrated;
  }
  return null;
}
function D1(n) {
  if (pa(n) !== n)
    throw Error(Ee(188));
}
function HR(n) {
  var e = n.alternate;
  if (!e) {
    if (e = pa(n), e === null)
      throw Error(Ee(188));
    return e !== n ? null : n;
  }
  for (var t = n, i = e; ; ) {
    var r = t.return;
    if (r === null)
      break;
    var s = r.alternate;
    if (s === null) {
      if (i = r.return, i !== null) {
        t = i;
        continue;
      }
      break;
    }
    if (r.child === s.child) {
      for (s = r.child; s; ) {
        if (s === t)
          return D1(r), n;
        if (s === i)
          return D1(r), e;
        s = s.sibling;
      }
      throw Error(Ee(188));
    }
    if (t.return !== i.return)
      t = r, i = s;
    else {
      for (var o = !1, l = r.child; l; ) {
        if (l === t) {
          o = !0, t = r, i = s;
          break;
        }
        if (l === i) {
          o = !0, i = r, t = s;
          break;
        }
        l = l.sibling;
      }
      if (!o) {
        for (l = s.child; l; ) {
          if (l === t) {
            o = !0, t = s, i = r;
            break;
          }
          if (l === i) {
            o = !0, i = s, t = r;
            break;
          }
          l = l.sibling;
        }
        if (!o)
          throw Error(Ee(189));
      }
    }
    if (t.alternate !== i)
      throw Error(Ee(190));
  }
  if (t.tag !== 3)
    throw Error(Ee(188));
  return t.stateNode.current === t ? n : e;
}
function rE(n) {
  return n = HR(n), n !== null ? sE(n) : null;
}
function sE(n) {
  if (n.tag === 5 || n.tag === 6)
    return n;
  for (n = n.child; n !== null; ) {
    var e = sE(n);
    if (e !== null)
      return e;
    n = n.sibling;
  }
  return null;
}
var oE = ki.unstable_scheduleCallback, U1 = ki.unstable_cancelCallback, VR = ki.unstable_shouldYield, GR = ki.unstable_requestPaint, dn = ki.unstable_now, WR = ki.unstable_getCurrentPriorityLevel, my = ki.unstable_ImmediatePriority, aE = ki.unstable_UserBlockingPriority, Id = ki.unstable_NormalPriority, XR = ki.unstable_LowPriority, lE = ki.unstable_IdlePriority, op = null, zr = null;
function jR(n) {
  if (zr && typeof zr.onCommitFiberRoot == "function")
    try {
      zr.onCommitFiberRoot(op, n, void 0, (n.current.flags & 128) === 128);
    } catch {
    }
}
var vr = Math.clz32 ? Math.clz32 : ZR, YR = Math.log, qR = Math.LN2;
function ZR(n) {
  return n >>>= 0, n === 0 ? 32 : 31 - (YR(n) / qR | 0) | 0;
}
var rh = 64, sh = 4194304;
function Bu(n) {
  switch (n & -n) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n;
  }
}
function Nd(n, e) {
  var t = n.pendingLanes;
  if (t === 0)
    return 0;
  var i = 0, r = n.suspendedLanes, s = n.pingedLanes, o = t & 268435455;
  if (o !== 0) {
    var l = o & ~r;
    l !== 0 ? i = Bu(l) : (s &= o, s !== 0 && (i = Bu(s)));
  } else
    o = t & ~r, o !== 0 ? i = Bu(o) : s !== 0 && (i = Bu(s));
  if (i === 0)
    return 0;
  if (e !== 0 && e !== i && !(e & r) && (r = i & -i, s = e & -e, r >= s || r === 16 && (s & 4194240) !== 0))
    return e;
  if (i & 4 && (i |= t & 16), e = n.entangledLanes, e !== 0)
    for (n = n.entanglements, e &= i; 0 < e; )
      t = 31 - vr(e), r = 1 << t, i |= n[t], e &= ~r;
  return i;
}
function KR(n, e) {
  switch (n) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function JR(n, e) {
  for (var t = n.suspendedLanes, i = n.pingedLanes, r = n.expirationTimes, s = n.pendingLanes; 0 < s; ) {
    var o = 31 - vr(s), l = 1 << o, c = r[o];
    c === -1 ? (!(l & t) || l & i) && (r[o] = KR(l, e)) : c <= e && (n.expiredLanes |= l), s &= ~l;
  }
}
function D0(n) {
  return n = n.pendingLanes & -1073741825, n !== 0 ? n : n & 1073741824 ? 1073741824 : 0;
}
function uE() {
  var n = rh;
  return rh <<= 1, !(rh & 4194240) && (rh = 64), n;
}
function ug(n) {
  for (var e = [], t = 0; 31 > t; t++)
    e.push(n);
  return e;
}
function Hc(n, e, t) {
  n.pendingLanes |= e, e !== 536870912 && (n.suspendedLanes = 0, n.pingedLanes = 0), n = n.eventTimes, e = 31 - vr(e), n[e] = t;
}
function QR(n, e) {
  var t = n.pendingLanes & ~e;
  n.pendingLanes = e, n.suspendedLanes = 0, n.pingedLanes = 0, n.expiredLanes &= e, n.mutableReadLanes &= e, n.entangledLanes &= e, e = n.entanglements;
  var i = n.eventTimes;
  for (n = n.expirationTimes; 0 < t; ) {
    var r = 31 - vr(t), s = 1 << r;
    e[r] = 0, i[r] = -1, n[r] = -1, t &= ~s;
  }
}
function gy(n, e) {
  var t = n.entangledLanes |= e;
  for (n = n.entanglements; t; ) {
    var i = 31 - vr(t), r = 1 << i;
    r & e | n[i] & e && (n[i] |= e), t &= ~r;
  }
}
var Ft = 0;
function cE(n) {
  return n &= -n, 1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1;
}
var fE, vy, hE, dE, pE, U0 = !1, oh = [], qs = null, Zs = null, Ks = null, lc = /* @__PURE__ */ new Map(), uc = /* @__PURE__ */ new Map(), Ws = [], $R = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function O1(n, e) {
  switch (n) {
    case "focusin":
    case "focusout":
      qs = null;
      break;
    case "dragenter":
    case "dragleave":
      Zs = null;
      break;
    case "mouseover":
    case "mouseout":
      Ks = null;
      break;
    case "pointerover":
    case "pointerout":
      lc.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      uc.delete(e.pointerId);
  }
}
function xu(n, e, t, i, r, s) {
  return n === null || n.nativeEvent !== s ? (n = { blockedOn: e, domEventName: t, eventSystemFlags: i, nativeEvent: s, targetContainers: [r] }, e !== null && (e = Gc(e), e !== null && vy(e)), n) : (n.eventSystemFlags |= i, e = n.targetContainers, r !== null && e.indexOf(r) === -1 && e.push(r), n);
}
function eP(n, e, t, i, r) {
  switch (e) {
    case "focusin":
      return qs = xu(qs, n, e, t, i, r), !0;
    case "dragenter":
      return Zs = xu(Zs, n, e, t, i, r), !0;
    case "mouseover":
      return Ks = xu(Ks, n, e, t, i, r), !0;
    case "pointerover":
      var s = r.pointerId;
      return lc.set(s, xu(lc.get(s) || null, n, e, t, i, r)), !0;
    case "gotpointercapture":
      return s = r.pointerId, uc.set(s, xu(uc.get(s) || null, n, e, t, i, r)), !0;
  }
  return !1;
}
function mE(n) {
  var e = Xo(n.target);
  if (e !== null) {
    var t = pa(e);
    if (t !== null) {
      if (e = t.tag, e === 13) {
        if (e = iE(t), e !== null) {
          n.blockedOn = e, pE(n.priority, function() {
            hE(t);
          });
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n.blockedOn = null;
}
function cd(n) {
  if (n.blockedOn !== null)
    return !1;
  for (var e = n.targetContainers; 0 < e.length; ) {
    var t = O0(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
    if (t === null) {
      t = n.nativeEvent;
      var i = new t.constructor(t.type, t);
      b0 = i, t.target.dispatchEvent(i), b0 = null;
    } else
      return e = Gc(t), e !== null && vy(e), n.blockedOn = t, !1;
    e.shift();
  }
  return !0;
}
function k1(n, e, t) {
  cd(n) && t.delete(e);
}
function tP() {
  U0 = !1, qs !== null && cd(qs) && (qs = null), Zs !== null && cd(Zs) && (Zs = null), Ks !== null && cd(Ks) && (Ks = null), lc.forEach(k1), uc.forEach(k1);
}
function Su(n, e) {
  n.blockedOn === e && (n.blockedOn = null, U0 || (U0 = !0, ki.unstable_scheduleCallback(ki.unstable_NormalPriority, tP)));
}
function cc(n) {
  function e(r) {
    return Su(r, n);
  }
  if (0 < oh.length) {
    Su(oh[0], n);
    for (var t = 1; t < oh.length; t++) {
      var i = oh[t];
      i.blockedOn === n && (i.blockedOn = null);
    }
  }
  for (qs !== null && Su(qs, n), Zs !== null && Su(Zs, n), Ks !== null && Su(Ks, n), lc.forEach(e), uc.forEach(e), t = 0; t < Ws.length; t++)
    i = Ws[t], i.blockedOn === n && (i.blockedOn = null);
  for (; 0 < Ws.length && (t = Ws[0], t.blockedOn === null); )
    mE(t), t.blockedOn === null && Ws.shift();
}
var Rl = Es.ReactCurrentBatchConfig, Dd = !0;
function nP(n, e, t, i) {
  var r = Ft, s = Rl.transition;
  Rl.transition = null;
  try {
    Ft = 1, yy(n, e, t, i);
  } finally {
    Ft = r, Rl.transition = s;
  }
}
function iP(n, e, t, i) {
  var r = Ft, s = Rl.transition;
  Rl.transition = null;
  try {
    Ft = 4, yy(n, e, t, i);
  } finally {
    Ft = r, Rl.transition = s;
  }
}
function yy(n, e, t, i) {
  if (Dd) {
    var r = O0(n, e, t, i);
    if (r === null)
      _g(n, e, i, Ud, t), O1(n, i);
    else if (eP(r, n, e, t, i))
      i.stopPropagation();
    else if (O1(n, i), e & 4 && -1 < $R.indexOf(n)) {
      for (; r !== null; ) {
        var s = Gc(r);
        if (s !== null && fE(s), s = O0(n, e, t, i), s === null && _g(n, e, i, Ud, t), s === r)
          break;
        r = s;
      }
      r !== null && i.stopPropagation();
    } else
      _g(n, e, i, null, t);
  }
}
var Ud = null;
function O0(n, e, t, i) {
  if (Ud = null, n = py(i), n = Xo(n), n !== null)
    if (e = pa(n), e === null)
      n = null;
    else if (t = e.tag, t === 13) {
      if (n = iE(e), n !== null)
        return n;
      n = null;
    } else if (t === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      n = null;
    } else
      e !== n && (n = null);
  return Ud = n, null;
}
function gE(n) {
  switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (WR()) {
        case my:
          return 1;
        case aE:
          return 4;
        case Id:
        case XR:
          return 16;
        case lE:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var js = null, _y = null, fd = null;
function vE() {
  if (fd)
    return fd;
  var n, e = _y, t = e.length, i, r = "value" in js ? js.value : js.textContent, s = r.length;
  for (n = 0; n < t && e[n] === r[n]; n++)
    ;
  var o = t - n;
  for (i = 1; i <= o && e[t - i] === r[s - i]; i++)
    ;
  return fd = r.slice(n, 1 < i ? 1 - i : void 0);
}
function hd(n) {
  var e = n.keyCode;
  return "charCode" in n ? (n = n.charCode, n === 0 && e === 13 && (n = 13)) : n = e, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0;
}
function ah() {
  return !0;
}
function F1() {
  return !1;
}
function zi(n) {
  function e(t, i, r, s, o) {
    this._reactName = t, this._targetInst = r, this.type = i, this.nativeEvent = s, this.target = o, this.currentTarget = null;
    for (var l in n)
      n.hasOwnProperty(l) && (t = n[l], this[l] = t ? t(s) : s[l]);
    return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? ah : F1, this.isPropagationStopped = F1, this;
  }
  return tn(e.prototype, { preventDefault: function() {
    this.defaultPrevented = !0;
    var t = this.nativeEvent;
    t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1), this.isDefaultPrevented = ah);
  }, stopPropagation: function() {
    var t = this.nativeEvent;
    t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0), this.isPropagationStopped = ah);
  }, persist: function() {
  }, isPersistent: ah }), e;
}
var jl = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(n) {
  return n.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, xy = zi(jl), Vc = tn({}, jl, { view: 0, detail: 0 }), rP = zi(Vc), cg, fg, Mu, ap = tn({}, Vc, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Sy, button: 0, buttons: 0, relatedTarget: function(n) {
  return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget;
}, movementX: function(n) {
  return "movementX" in n ? n.movementX : (n !== Mu && (Mu && n.type === "mousemove" ? (cg = n.screenX - Mu.screenX, fg = n.screenY - Mu.screenY) : fg = cg = 0, Mu = n), cg);
}, movementY: function(n) {
  return "movementY" in n ? n.movementY : fg;
} }), z1 = zi(ap), sP = tn({}, ap, { dataTransfer: 0 }), oP = zi(sP), aP = tn({}, Vc, { relatedTarget: 0 }), hg = zi(aP), lP = tn({}, jl, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), uP = zi(lP), cP = tn({}, jl, { clipboardData: function(n) {
  return "clipboardData" in n ? n.clipboardData : window.clipboardData;
} }), fP = zi(cP), hP = tn({}, jl, { data: 0 }), B1 = zi(hP), dP = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, pP = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, mP = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function gP(n) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n) : (n = mP[n]) ? !!e[n] : !1;
}
function Sy() {
  return gP;
}
var vP = tn({}, Vc, { key: function(n) {
  if (n.key) {
    var e = dP[n.key] || n.key;
    if (e !== "Unidentified")
      return e;
  }
  return n.type === "keypress" ? (n = hd(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? pP[n.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Sy, charCode: function(n) {
  return n.type === "keypress" ? hd(n) : 0;
}, keyCode: function(n) {
  return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
}, which: function(n) {
  return n.type === "keypress" ? hd(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
} }), yP = zi(vP), _P = tn({}, ap, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), H1 = zi(_P), xP = tn({}, Vc, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Sy }), SP = zi(xP), MP = tn({}, jl, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), wP = zi(MP), EP = tn({}, ap, {
  deltaX: function(n) {
    return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
  },
  deltaY: function(n) {
    return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), TP = zi(EP), AP = [9, 13, 27, 32], My = ys && "CompositionEvent" in window, ju = null;
ys && "documentMode" in document && (ju = document.documentMode);
var CP = ys && "TextEvent" in window && !ju, yE = ys && (!My || ju && 8 < ju && 11 >= ju), V1 = String.fromCharCode(32), G1 = !1;
function _E(n, e) {
  switch (n) {
    case "keyup":
      return AP.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function xE(n) {
  return n = n.detail, typeof n == "object" && "data" in n ? n.data : null;
}
var cl = !1;
function RP(n, e) {
  switch (n) {
    case "compositionend":
      return xE(e);
    case "keypress":
      return e.which !== 32 ? null : (G1 = !0, V1);
    case "textInput":
      return n = e.data, n === V1 && G1 ? null : n;
    default:
      return null;
  }
}
function PP(n, e) {
  if (cl)
    return n === "compositionend" || !My && _E(n, e) ? (n = vE(), fd = _y = js = null, cl = !1, n) : null;
  switch (n) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
        if (e.char && 1 < e.char.length)
          return e.char;
        if (e.which)
          return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return yE && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var bP = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function W1(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return e === "input" ? !!bP[n.type] : e === "textarea";
}
function SE(n, e, t, i) {
  Qw(i), e = Od(e, "onChange"), 0 < e.length && (t = new xy("onChange", "change", null, t, i), n.push({ event: t, listeners: e }));
}
var Yu = null, fc = null;
function LP(n) {
  IE(n, 0);
}
function lp(n) {
  var e = dl(n);
  if (Xw(e))
    return n;
}
function IP(n, e) {
  if (n === "change")
    return e;
}
var ME = !1;
if (ys) {
  var dg;
  if (ys) {
    var pg = "oninput" in document;
    if (!pg) {
      var X1 = document.createElement("div");
      X1.setAttribute("oninput", "return;"), pg = typeof X1.oninput == "function";
    }
    dg = pg;
  } else
    dg = !1;
  ME = dg && (!document.documentMode || 9 < document.documentMode);
}
function j1() {
  Yu && (Yu.detachEvent("onpropertychange", wE), fc = Yu = null);
}
function wE(n) {
  if (n.propertyName === "value" && lp(fc)) {
    var e = [];
    SE(e, fc, n, py(n)), nE(LP, e);
  }
}
function NP(n, e, t) {
  n === "focusin" ? (j1(), Yu = e, fc = t, Yu.attachEvent("onpropertychange", wE)) : n === "focusout" && j1();
}
function DP(n) {
  if (n === "selectionchange" || n === "keyup" || n === "keydown")
    return lp(fc);
}
function UP(n, e) {
  if (n === "click")
    return lp(e);
}
function OP(n, e) {
  if (n === "input" || n === "change")
    return lp(e);
}
function kP(n, e) {
  return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e;
}
var xr = typeof Object.is == "function" ? Object.is : kP;
function hc(n, e) {
  if (xr(n, e))
    return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  var t = Object.keys(n), i = Object.keys(e);
  if (t.length !== i.length)
    return !1;
  for (i = 0; i < t.length; i++) {
    var r = t[i];
    if (!y0.call(e, r) || !xr(n[r], e[r]))
      return !1;
  }
  return !0;
}
function Y1(n) {
  for (; n && n.firstChild; )
    n = n.firstChild;
  return n;
}
function q1(n, e) {
  var t = Y1(n);
  n = 0;
  for (var i; t; ) {
    if (t.nodeType === 3) {
      if (i = n + t.textContent.length, n <= e && i >= e)
        return { node: t, offset: e - n };
      n = i;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = Y1(t);
  }
}
function EE(n, e) {
  return n && e ? n === e ? !0 : n && n.nodeType === 3 ? !1 : e && e.nodeType === 3 ? EE(n, e.parentNode) : "contains" in n ? n.contains(e) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(e) & 16) : !1 : !1;
}
function TE() {
  for (var n = window, e = Pd(); e instanceof n.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = !1;
    }
    if (t)
      n = e.contentWindow;
    else
      break;
    e = Pd(n.document);
  }
  return e;
}
function wy(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return e && (e === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || e === "textarea" || n.contentEditable === "true");
}
function FP(n) {
  var e = TE(), t = n.focusedElem, i = n.selectionRange;
  if (e !== t && t && t.ownerDocument && EE(t.ownerDocument.documentElement, t)) {
    if (i !== null && wy(t)) {
      if (e = i.start, n = i.end, n === void 0 && (n = e), "selectionStart" in t)
        t.selectionStart = e, t.selectionEnd = Math.min(n, t.value.length);
      else if (n = (e = t.ownerDocument || document) && e.defaultView || window, n.getSelection) {
        n = n.getSelection();
        var r = t.textContent.length, s = Math.min(i.start, r);
        i = i.end === void 0 ? s : Math.min(i.end, r), !n.extend && s > i && (r = i, i = s, s = r), r = q1(t, s);
        var o = q1(
          t,
          i
        );
        r && o && (n.rangeCount !== 1 || n.anchorNode !== r.node || n.anchorOffset !== r.offset || n.focusNode !== o.node || n.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(r.node, r.offset), n.removeAllRanges(), s > i ? (n.addRange(e), n.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), n.addRange(e)));
      }
    }
    for (e = [], n = t; n = n.parentNode; )
      n.nodeType === 1 && e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)
      n = e[t], n.element.scrollLeft = n.left, n.element.scrollTop = n.top;
  }
}
var zP = ys && "documentMode" in document && 11 >= document.documentMode, fl = null, k0 = null, qu = null, F0 = !1;
function Z1(n, e, t) {
  var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  F0 || fl == null || fl !== Pd(i) || (i = fl, "selectionStart" in i && wy(i) ? i = { start: i.selectionStart, end: i.selectionEnd } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = { anchorNode: i.anchorNode, anchorOffset: i.anchorOffset, focusNode: i.focusNode, focusOffset: i.focusOffset }), qu && hc(qu, i) || (qu = i, i = Od(k0, "onSelect"), 0 < i.length && (e = new xy("onSelect", "select", null, e, t), n.push({ event: e, listeners: i }), e.target = fl)));
}
function lh(n, e) {
  var t = {};
  return t[n.toLowerCase()] = e.toLowerCase(), t["Webkit" + n] = "webkit" + e, t["Moz" + n] = "moz" + e, t;
}
var hl = { animationend: lh("Animation", "AnimationEnd"), animationiteration: lh("Animation", "AnimationIteration"), animationstart: lh("Animation", "AnimationStart"), transitionend: lh("Transition", "TransitionEnd") }, mg = {}, AE = {};
ys && (AE = document.createElement("div").style, "AnimationEvent" in window || (delete hl.animationend.animation, delete hl.animationiteration.animation, delete hl.animationstart.animation), "TransitionEvent" in window || delete hl.transitionend.transition);
function up(n) {
  if (mg[n])
    return mg[n];
  if (!hl[n])
    return n;
  var e = hl[n], t;
  for (t in e)
    if (e.hasOwnProperty(t) && t in AE)
      return mg[n] = e[t];
  return n;
}
var CE = up("animationend"), RE = up("animationiteration"), PE = up("animationstart"), bE = up("transitionend"), LE = /* @__PURE__ */ new Map(), K1 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ho(n, e) {
  LE.set(n, e), da(e, [n]);
}
for (var gg = 0; gg < K1.length; gg++) {
  var vg = K1[gg], BP = vg.toLowerCase(), HP = vg[0].toUpperCase() + vg.slice(1);
  ho(BP, "on" + HP);
}
ho(CE, "onAnimationEnd");
ho(RE, "onAnimationIteration");
ho(PE, "onAnimationStart");
ho("dblclick", "onDoubleClick");
ho("focusin", "onFocus");
ho("focusout", "onBlur");
ho(bE, "onTransitionEnd");
Nl("onMouseEnter", ["mouseout", "mouseover"]);
Nl("onMouseLeave", ["mouseout", "mouseover"]);
Nl("onPointerEnter", ["pointerout", "pointerover"]);
Nl("onPointerLeave", ["pointerout", "pointerover"]);
da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Hu = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), VP = new Set("cancel close invalid load scroll toggle".split(" ").concat(Hu));
function J1(n, e, t) {
  var i = n.type || "unknown-event";
  n.currentTarget = t, BR(i, e, void 0, n), n.currentTarget = null;
}
function IE(n, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n.length; t++) {
    var i = n[t], r = i.event;
    i = i.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var o = i.length - 1; 0 <= o; o--) {
          var l = i[o], c = l.instance, f = l.currentTarget;
          if (l = l.listener, c !== s && r.isPropagationStopped())
            break e;
          J1(r, l, f), s = c;
        }
      else
        for (o = 0; o < i.length; o++) {
          if (l = i[o], c = l.instance, f = l.currentTarget, l = l.listener, c !== s && r.isPropagationStopped())
            break e;
          J1(r, l, f), s = c;
        }
    }
  }
  if (Ld)
    throw n = N0, Ld = !1, N0 = null, n;
}
function Xt(n, e) {
  var t = e[G0];
  t === void 0 && (t = e[G0] = /* @__PURE__ */ new Set());
  var i = n + "__bubble";
  t.has(i) || (NE(e, n, 2, !1), t.add(i));
}
function yg(n, e, t) {
  var i = 0;
  e && (i |= 4), NE(t, n, i, e);
}
var uh = "_reactListening" + Math.random().toString(36).slice(2);
function dc(n) {
  if (!n[uh]) {
    n[uh] = !0, Bw.forEach(function(t) {
      t !== "selectionchange" && (VP.has(t) || yg(t, !1, n), yg(t, !0, n));
    });
    var e = n.nodeType === 9 ? n : n.ownerDocument;
    e === null || e[uh] || (e[uh] = !0, yg("selectionchange", !1, e));
  }
}
function NE(n, e, t, i) {
  switch (gE(e)) {
    case 1:
      var r = nP;
      break;
    case 4:
      r = iP;
      break;
    default:
      r = yy;
  }
  t = r.bind(null, e, t, n), r = void 0, !I0 || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0), i ? r !== void 0 ? n.addEventListener(e, t, { capture: !0, passive: r }) : n.addEventListener(e, t, !0) : r !== void 0 ? n.addEventListener(e, t, { passive: r }) : n.addEventListener(e, t, !1);
}
function _g(n, e, t, i, r) {
  var s = i;
  if (!(e & 1) && !(e & 2) && i !== null)
    e:
      for (; ; ) {
        if (i === null)
          return;
        var o = i.tag;
        if (o === 3 || o === 4) {
          var l = i.stateNode.containerInfo;
          if (l === r || l.nodeType === 8 && l.parentNode === r)
            break;
          if (o === 4)
            for (o = i.return; o !== null; ) {
              var c = o.tag;
              if ((c === 3 || c === 4) && (c = o.stateNode.containerInfo, c === r || c.nodeType === 8 && c.parentNode === r))
                return;
              o = o.return;
            }
          for (; l !== null; ) {
            if (o = Xo(l), o === null)
              return;
            if (c = o.tag, c === 5 || c === 6) {
              i = s = o;
              continue e;
            }
            l = l.parentNode;
          }
        }
        i = i.return;
      }
  nE(function() {
    var f = s, h = py(t), d = [];
    e: {
      var m = LE.get(n);
      if (m !== void 0) {
        var v = xy, _ = n;
        switch (n) {
          case "keypress":
            if (hd(t) === 0)
              break e;
          case "keydown":
          case "keyup":
            v = yP;
            break;
          case "focusin":
            _ = "focus", v = hg;
            break;
          case "focusout":
            _ = "blur", v = hg;
            break;
          case "beforeblur":
          case "afterblur":
            v = hg;
            break;
          case "click":
            if (t.button === 2)
              break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            v = z1;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            v = oP;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            v = SP;
            break;
          case CE:
          case RE:
          case PE:
            v = uP;
            break;
          case bE:
            v = wP;
            break;
          case "scroll":
            v = rP;
            break;
          case "wheel":
            v = TP;
            break;
          case "copy":
          case "cut":
          case "paste":
            v = fP;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            v = H1;
        }
        var w = (e & 4) !== 0, M = !w && n === "scroll", g = w ? m !== null ? m + "Capture" : null : m;
        w = [];
        for (var x = f, S; x !== null; ) {
          S = x;
          var T = S.stateNode;
          if (S.tag === 5 && T !== null && (S = T, g !== null && (T = ac(x, g), T != null && w.push(pc(x, T, S)))), M)
            break;
          x = x.return;
        }
        0 < w.length && (m = new v(m, _, null, t, h), d.push({ event: m, listeners: w }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (m = n === "mouseover" || n === "pointerover", v = n === "mouseout" || n === "pointerout", m && t !== b0 && (_ = t.relatedTarget || t.fromElement) && (Xo(_) || _[_s]))
          break e;
        if ((v || m) && (m = h.window === h ? h : (m = h.ownerDocument) ? m.defaultView || m.parentWindow : window, v ? (_ = t.relatedTarget || t.toElement, v = f, _ = _ ? Xo(_) : null, _ !== null && (M = pa(_), _ !== M || _.tag !== 5 && _.tag !== 6) && (_ = null)) : (v = null, _ = f), v !== _)) {
          if (w = z1, T = "onMouseLeave", g = "onMouseEnter", x = "mouse", (n === "pointerout" || n === "pointerover") && (w = H1, T = "onPointerLeave", g = "onPointerEnter", x = "pointer"), M = v == null ? m : dl(v), S = _ == null ? m : dl(_), m = new w(T, x + "leave", v, t, h), m.target = M, m.relatedTarget = S, T = null, Xo(h) === f && (w = new w(g, x + "enter", _, t, h), w.target = S, w.relatedTarget = M, T = w), M = T, v && _)
            t: {
              for (w = v, g = _, x = 0, S = w; S; S = Da(S))
                x++;
              for (S = 0, T = g; T; T = Da(T))
                S++;
              for (; 0 < x - S; )
                w = Da(w), x--;
              for (; 0 < S - x; )
                g = Da(g), S--;
              for (; x--; ) {
                if (w === g || g !== null && w === g.alternate)
                  break t;
                w = Da(w), g = Da(g);
              }
              w = null;
            }
          else
            w = null;
          v !== null && Q1(d, m, v, w, !1), _ !== null && M !== null && Q1(d, M, _, w, !0);
        }
      }
      e: {
        if (m = f ? dl(f) : window, v = m.nodeName && m.nodeName.toLowerCase(), v === "select" || v === "input" && m.type === "file")
          var C = IP;
        else if (W1(m))
          if (ME)
            C = OP;
          else {
            C = DP;
            var P = NP;
          }
        else
          (v = m.nodeName) && v.toLowerCase() === "input" && (m.type === "checkbox" || m.type === "radio") && (C = UP);
        if (C && (C = C(n, f))) {
          SE(d, C, t, h);
          break e;
        }
        P && P(n, m, f), n === "focusout" && (P = m._wrapperState) && P.controlled && m.type === "number" && T0(m, "number", m.value);
      }
      switch (P = f ? dl(f) : window, n) {
        case "focusin":
          (W1(P) || P.contentEditable === "true") && (fl = P, k0 = f, qu = null);
          break;
        case "focusout":
          qu = k0 = fl = null;
          break;
        case "mousedown":
          F0 = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          F0 = !1, Z1(d, t, h);
          break;
        case "selectionchange":
          if (zP)
            break;
        case "keydown":
        case "keyup":
          Z1(d, t, h);
      }
      var L;
      if (My)
        e: {
          switch (n) {
            case "compositionstart":
              var N = "onCompositionStart";
              break e;
            case "compositionend":
              N = "onCompositionEnd";
              break e;
            case "compositionupdate":
              N = "onCompositionUpdate";
              break e;
          }
          N = void 0;
        }
      else
        cl ? _E(n, t) && (N = "onCompositionEnd") : n === "keydown" && t.keyCode === 229 && (N = "onCompositionStart");
      N && (yE && t.locale !== "ko" && (cl || N !== "onCompositionStart" ? N === "onCompositionEnd" && cl && (L = vE()) : (js = h, _y = "value" in js ? js.value : js.textContent, cl = !0)), P = Od(f, N), 0 < P.length && (N = new B1(N, n, null, t, h), d.push({ event: N, listeners: P }), L ? N.data = L : (L = xE(t), L !== null && (N.data = L)))), (L = CP ? RP(n, t) : PP(n, t)) && (f = Od(f, "onBeforeInput"), 0 < f.length && (h = new B1("onBeforeInput", "beforeinput", null, t, h), d.push({ event: h, listeners: f }), h.data = L));
    }
    IE(d, e);
  });
}
function pc(n, e, t) {
  return { instance: n, listener: e, currentTarget: t };
}
function Od(n, e) {
  for (var t = e + "Capture", i = []; n !== null; ) {
    var r = n, s = r.stateNode;
    r.tag === 5 && s !== null && (r = s, s = ac(n, t), s != null && i.unshift(pc(n, s, r)), s = ac(n, e), s != null && i.push(pc(n, s, r))), n = n.return;
  }
  return i;
}
function Da(n) {
  if (n === null)
    return null;
  do
    n = n.return;
  while (n && n.tag !== 5);
  return n || null;
}
function Q1(n, e, t, i, r) {
  for (var s = e._reactName, o = []; t !== null && t !== i; ) {
    var l = t, c = l.alternate, f = l.stateNode;
    if (c !== null && c === i)
      break;
    l.tag === 5 && f !== null && (l = f, r ? (c = ac(t, s), c != null && o.unshift(pc(t, c, l))) : r || (c = ac(t, s), c != null && o.push(pc(t, c, l)))), t = t.return;
  }
  o.length !== 0 && n.push({ event: e, listeners: o });
}
var GP = /\r\n?/g, WP = /\u0000|\uFFFD/g;
function $1(n) {
  return (typeof n == "string" ? n : "" + n).replace(GP, `
`).replace(WP, "");
}
function ch(n, e, t) {
  if (e = $1(e), $1(n) !== e && t)
    throw Error(Ee(425));
}
function kd() {
}
var z0 = null, B0 = null;
function H0(n, e) {
  return n === "textarea" || n === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null;
}
var V0 = typeof setTimeout == "function" ? setTimeout : void 0, XP = typeof clearTimeout == "function" ? clearTimeout : void 0, eS = typeof Promise == "function" ? Promise : void 0, jP = typeof queueMicrotask == "function" ? queueMicrotask : typeof eS < "u" ? function(n) {
  return eS.resolve(null).then(n).catch(YP);
} : V0;
function YP(n) {
  setTimeout(function() {
    throw n;
  });
}
function xg(n, e) {
  var t = e, i = 0;
  do {
    var r = t.nextSibling;
    if (n.removeChild(t), r && r.nodeType === 8)
      if (t = r.data, t === "/$") {
        if (i === 0) {
          n.removeChild(r), cc(e);
          return;
        }
        i--;
      } else
        t !== "$" && t !== "$?" && t !== "$!" || i++;
    t = r;
  } while (t);
  cc(e);
}
function Js(n) {
  for (; n != null; n = n.nextSibling) {
    var e = n.nodeType;
    if (e === 1 || e === 3)
      break;
    if (e === 8) {
      if (e = n.data, e === "$" || e === "$!" || e === "$?")
        break;
      if (e === "/$")
        return null;
    }
  }
  return n;
}
function tS(n) {
  n = n.previousSibling;
  for (var e = 0; n; ) {
    if (n.nodeType === 8) {
      var t = n.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0)
          return n;
        e--;
      } else
        t === "/$" && e++;
    }
    n = n.previousSibling;
  }
  return null;
}
var Yl = Math.random().toString(36).slice(2), Or = "__reactFiber$" + Yl, mc = "__reactProps$" + Yl, _s = "__reactContainer$" + Yl, G0 = "__reactEvents$" + Yl, qP = "__reactListeners$" + Yl, ZP = "__reactHandles$" + Yl;
function Xo(n) {
  var e = n[Or];
  if (e)
    return e;
  for (var t = n.parentNode; t; ) {
    if (e = t[_s] || t[Or]) {
      if (t = e.alternate, e.child !== null || t !== null && t.child !== null)
        for (n = tS(n); n !== null; ) {
          if (t = n[Or])
            return t;
          n = tS(n);
        }
      return e;
    }
    n = t, t = n.parentNode;
  }
  return null;
}
function Gc(n) {
  return n = n[Or] || n[_s], !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n;
}
function dl(n) {
  if (n.tag === 5 || n.tag === 6)
    return n.stateNode;
  throw Error(Ee(33));
}
function cp(n) {
  return n[mc] || null;
}
var W0 = [], pl = -1;
function po(n) {
  return { current: n };
}
function Yt(n) {
  0 > pl || (n.current = W0[pl], W0[pl] = null, pl--);
}
function Gt(n, e) {
  pl++, W0[pl] = n.current, n.current = e;
}
var ao = {}, $n = po(ao), _i = po(!1), ra = ao;
function Dl(n, e) {
  var t = n.type.contextTypes;
  if (!t)
    return ao;
  var i = n.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
    return i.__reactInternalMemoizedMaskedChildContext;
  var r = {}, s;
  for (s in t)
    r[s] = e[s];
  return i && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = e, n.__reactInternalMemoizedMaskedChildContext = r), r;
}
function xi(n) {
  return n = n.childContextTypes, n != null;
}
function Fd() {
  Yt(_i), Yt($n);
}
function nS(n, e, t) {
  if ($n.current !== ao)
    throw Error(Ee(168));
  Gt($n, e), Gt(_i, t);
}
function DE(n, e, t) {
  var i = n.stateNode;
  if (e = e.childContextTypes, typeof i.getChildContext != "function")
    return t;
  i = i.getChildContext();
  for (var r in i)
    if (!(r in e))
      throw Error(Ee(108, NR(n) || "Unknown", r));
  return tn({}, t, i);
}
function zd(n) {
  return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || ao, ra = $n.current, Gt($n, n), Gt(_i, _i.current), !0;
}
function iS(n, e, t) {
  var i = n.stateNode;
  if (!i)
    throw Error(Ee(169));
  t ? (n = DE(n, e, ra), i.__reactInternalMemoizedMergedChildContext = n, Yt(_i), Yt($n), Gt($n, n)) : Yt(_i), Gt(_i, t);
}
var cs = null, fp = !1, Sg = !1;
function UE(n) {
  cs === null ? cs = [n] : cs.push(n);
}
function KP(n) {
  fp = !0, UE(n);
}
function mo() {
  if (!Sg && cs !== null) {
    Sg = !0;
    var n = 0, e = Ft;
    try {
      var t = cs;
      for (Ft = 1; n < t.length; n++) {
        var i = t[n];
        do
          i = i(!0);
        while (i !== null);
      }
      cs = null, fp = !1;
    } catch (r) {
      throw cs !== null && (cs = cs.slice(n + 1)), oE(my, mo), r;
    } finally {
      Ft = e, Sg = !1;
    }
  }
  return null;
}
var ml = [], gl = 0, Bd = null, Hd = 0, Ji = [], Qi = 0, sa = null, ds = 1, ps = "";
function Fo(n, e) {
  ml[gl++] = Hd, ml[gl++] = Bd, Bd = n, Hd = e;
}
function OE(n, e, t) {
  Ji[Qi++] = ds, Ji[Qi++] = ps, Ji[Qi++] = sa, sa = n;
  var i = ds;
  n = ps;
  var r = 32 - vr(i) - 1;
  i &= ~(1 << r), t += 1;
  var s = 32 - vr(e) + r;
  if (30 < s) {
    var o = r - r % 5;
    s = (i & (1 << o) - 1).toString(32), i >>= o, r -= o, ds = 1 << 32 - vr(e) + r | t << r | i, ps = s + n;
  } else
    ds = 1 << s | t << r | i, ps = n;
}
function Ey(n) {
  n.return !== null && (Fo(n, 1), OE(n, 1, 0));
}
function Ty(n) {
  for (; n === Bd; )
    Bd = ml[--gl], ml[gl] = null, Hd = ml[--gl], ml[gl] = null;
  for (; n === sa; )
    sa = Ji[--Qi], Ji[Qi] = null, ps = Ji[--Qi], Ji[Qi] = null, ds = Ji[--Qi], Ji[Qi] = null;
}
var Ui = null, Ni = null, Zt = !1, pr = null;
function kE(n, e) {
  var t = $i(5, null, null, 0);
  t.elementType = "DELETED", t.stateNode = e, t.return = n, e = n.deletions, e === null ? (n.deletions = [t], n.flags |= 16) : e.push(t);
}
function rS(n, e) {
  switch (n.tag) {
    case 5:
      var t = n.type;
      return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (n.stateNode = e, Ui = n, Ni = Js(e.firstChild), !0) : !1;
    case 6:
      return e = n.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (n.stateNode = e, Ui = n, Ni = null, !0) : !1;
    case 13:
      return e = e.nodeType !== 8 ? null : e, e !== null ? (t = sa !== null ? { id: ds, overflow: ps } : null, n.memoizedState = { dehydrated: e, treeContext: t, retryLane: 1073741824 }, t = $i(18, null, null, 0), t.stateNode = e, t.return = n, n.child = t, Ui = n, Ni = null, !0) : !1;
    default:
      return !1;
  }
}
function X0(n) {
  return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
}
function j0(n) {
  if (Zt) {
    var e = Ni;
    if (e) {
      var t = e;
      if (!rS(n, e)) {
        if (X0(n))
          throw Error(Ee(418));
        e = Js(t.nextSibling);
        var i = Ui;
        e && rS(n, e) ? kE(i, t) : (n.flags = n.flags & -4097 | 2, Zt = !1, Ui = n);
      }
    } else {
      if (X0(n))
        throw Error(Ee(418));
      n.flags = n.flags & -4097 | 2, Zt = !1, Ui = n;
    }
  }
}
function sS(n) {
  for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
    n = n.return;
  Ui = n;
}
function fh(n) {
  if (n !== Ui)
    return !1;
  if (!Zt)
    return sS(n), Zt = !0, !1;
  var e;
  if ((e = n.tag !== 3) && !(e = n.tag !== 5) && (e = n.type, e = e !== "head" && e !== "body" && !H0(n.type, n.memoizedProps)), e && (e = Ni)) {
    if (X0(n))
      throw FE(), Error(Ee(418));
    for (; e; )
      kE(n, e), e = Js(e.nextSibling);
  }
  if (sS(n), n.tag === 13) {
    if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n)
      throw Error(Ee(317));
    e: {
      for (n = n.nextSibling, e = 0; n; ) {
        if (n.nodeType === 8) {
          var t = n.data;
          if (t === "/$") {
            if (e === 0) {
              Ni = Js(n.nextSibling);
              break e;
            }
            e--;
          } else
            t !== "$" && t !== "$!" && t !== "$?" || e++;
        }
        n = n.nextSibling;
      }
      Ni = null;
    }
  } else
    Ni = Ui ? Js(n.stateNode.nextSibling) : null;
  return !0;
}
function FE() {
  for (var n = Ni; n; )
    n = Js(n.nextSibling);
}
function Ul() {
  Ni = Ui = null, Zt = !1;
}
function Ay(n) {
  pr === null ? pr = [n] : pr.push(n);
}
var JP = Es.ReactCurrentBatchConfig;
function wu(n, e, t) {
  if (n = t.ref, n !== null && typeof n != "function" && typeof n != "object") {
    if (t._owner) {
      if (t = t._owner, t) {
        if (t.tag !== 1)
          throw Error(Ee(309));
        var i = t.stateNode;
      }
      if (!i)
        throw Error(Ee(147, n));
      var r = i, s = "" + n;
      return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
        var l = r.refs;
        o === null ? delete l[s] : l[s] = o;
      }, e._stringRef = s, e);
    }
    if (typeof n != "string")
      throw Error(Ee(284));
    if (!t._owner)
      throw Error(Ee(290, n));
  }
  return n;
}
function hh(n, e) {
  throw n = Object.prototype.toString.call(e), Error(Ee(31, n === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n));
}
function oS(n) {
  var e = n._init;
  return e(n._payload);
}
function zE(n) {
  function e(g, x) {
    if (n) {
      var S = g.deletions;
      S === null ? (g.deletions = [x], g.flags |= 16) : S.push(x);
    }
  }
  function t(g, x) {
    if (!n)
      return null;
    for (; x !== null; )
      e(g, x), x = x.sibling;
    return null;
  }
  function i(g, x) {
    for (g = /* @__PURE__ */ new Map(); x !== null; )
      x.key !== null ? g.set(x.key, x) : g.set(x.index, x), x = x.sibling;
    return g;
  }
  function r(g, x) {
    return g = to(g, x), g.index = 0, g.sibling = null, g;
  }
  function s(g, x, S) {
    return g.index = S, n ? (S = g.alternate, S !== null ? (S = S.index, S < x ? (g.flags |= 2, x) : S) : (g.flags |= 2, x)) : (g.flags |= 1048576, x);
  }
  function o(g) {
    return n && g.alternate === null && (g.flags |= 2), g;
  }
  function l(g, x, S, T) {
    return x === null || x.tag !== 6 ? (x = Rg(S, g.mode, T), x.return = g, x) : (x = r(x, S), x.return = g, x);
  }
  function c(g, x, S, T) {
    var C = S.type;
    return C === ul ? h(g, x, S.props.children, T, S.key) : x !== null && (x.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Vs && oS(C) === x.type) ? (T = r(x, S.props), T.ref = wu(g, x, S), T.return = g, T) : (T = _d(S.type, S.key, S.props, null, g.mode, T), T.ref = wu(g, x, S), T.return = g, T);
  }
  function f(g, x, S, T) {
    return x === null || x.tag !== 4 || x.stateNode.containerInfo !== S.containerInfo || x.stateNode.implementation !== S.implementation ? (x = Pg(S, g.mode, T), x.return = g, x) : (x = r(x, S.children || []), x.return = g, x);
  }
  function h(g, x, S, T, C) {
    return x === null || x.tag !== 7 ? (x = $o(S, g.mode, T, C), x.return = g, x) : (x = r(x, S), x.return = g, x);
  }
  function d(g, x, S) {
    if (typeof x == "string" && x !== "" || typeof x == "number")
      return x = Rg("" + x, g.mode, S), x.return = g, x;
    if (typeof x == "object" && x !== null) {
      switch (x.$$typeof) {
        case th:
          return S = _d(x.type, x.key, x.props, null, g.mode, S), S.ref = wu(g, null, x), S.return = g, S;
        case ll:
          return x = Pg(x, g.mode, S), x.return = g, x;
        case Vs:
          var T = x._init;
          return d(g, T(x._payload), S);
      }
      if (zu(x) || yu(x))
        return x = $o(x, g.mode, S, null), x.return = g, x;
      hh(g, x);
    }
    return null;
  }
  function m(g, x, S, T) {
    var C = x !== null ? x.key : null;
    if (typeof S == "string" && S !== "" || typeof S == "number")
      return C !== null ? null : l(g, x, "" + S, T);
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case th:
          return S.key === C ? c(g, x, S, T) : null;
        case ll:
          return S.key === C ? f(g, x, S, T) : null;
        case Vs:
          return C = S._init, m(
            g,
            x,
            C(S._payload),
            T
          );
      }
      if (zu(S) || yu(S))
        return C !== null ? null : h(g, x, S, T, null);
      hh(g, S);
    }
    return null;
  }
  function v(g, x, S, T, C) {
    if (typeof T == "string" && T !== "" || typeof T == "number")
      return g = g.get(S) || null, l(x, g, "" + T, C);
    if (typeof T == "object" && T !== null) {
      switch (T.$$typeof) {
        case th:
          return g = g.get(T.key === null ? S : T.key) || null, c(x, g, T, C);
        case ll:
          return g = g.get(T.key === null ? S : T.key) || null, f(x, g, T, C);
        case Vs:
          var P = T._init;
          return v(g, x, S, P(T._payload), C);
      }
      if (zu(T) || yu(T))
        return g = g.get(S) || null, h(x, g, T, C, null);
      hh(x, T);
    }
    return null;
  }
  function _(g, x, S, T) {
    for (var C = null, P = null, L = x, N = x = 0, R = null; L !== null && N < S.length; N++) {
      L.index > N ? (R = L, L = null) : R = L.sibling;
      var b = m(g, L, S[N], T);
      if (b === null) {
        L === null && (L = R);
        break;
      }
      n && L && b.alternate === null && e(g, L), x = s(b, x, N), P === null ? C = b : P.sibling = b, P = b, L = R;
    }
    if (N === S.length)
      return t(g, L), Zt && Fo(g, N), C;
    if (L === null) {
      for (; N < S.length; N++)
        L = d(g, S[N], T), L !== null && (x = s(L, x, N), P === null ? C = L : P.sibling = L, P = L);
      return Zt && Fo(g, N), C;
    }
    for (L = i(g, L); N < S.length; N++)
      R = v(L, g, N, S[N], T), R !== null && (n && R.alternate !== null && L.delete(R.key === null ? N : R.key), x = s(R, x, N), P === null ? C = R : P.sibling = R, P = R);
    return n && L.forEach(function(G) {
      return e(g, G);
    }), Zt && Fo(g, N), C;
  }
  function w(g, x, S, T) {
    var C = yu(S);
    if (typeof C != "function")
      throw Error(Ee(150));
    if (S = C.call(S), S == null)
      throw Error(Ee(151));
    for (var P = C = null, L = x, N = x = 0, R = null, b = S.next(); L !== null && !b.done; N++, b = S.next()) {
      L.index > N ? (R = L, L = null) : R = L.sibling;
      var G = m(g, L, b.value, T);
      if (G === null) {
        L === null && (L = R);
        break;
      }
      n && L && G.alternate === null && e(g, L), x = s(G, x, N), P === null ? C = G : P.sibling = G, P = G, L = R;
    }
    if (b.done)
      return t(
        g,
        L
      ), Zt && Fo(g, N), C;
    if (L === null) {
      for (; !b.done; N++, b = S.next())
        b = d(g, b.value, T), b !== null && (x = s(b, x, N), P === null ? C = b : P.sibling = b, P = b);
      return Zt && Fo(g, N), C;
    }
    for (L = i(g, L); !b.done; N++, b = S.next())
      b = v(L, g, N, b.value, T), b !== null && (n && b.alternate !== null && L.delete(b.key === null ? N : b.key), x = s(b, x, N), P === null ? C = b : P.sibling = b, P = b);
    return n && L.forEach(function($) {
      return e(g, $);
    }), Zt && Fo(g, N), C;
  }
  function M(g, x, S, T) {
    if (typeof S == "object" && S !== null && S.type === ul && S.key === null && (S = S.props.children), typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case th:
          e: {
            for (var C = S.key, P = x; P !== null; ) {
              if (P.key === C) {
                if (C = S.type, C === ul) {
                  if (P.tag === 7) {
                    t(g, P.sibling), x = r(P, S.props.children), x.return = g, g = x;
                    break e;
                  }
                } else if (P.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Vs && oS(C) === P.type) {
                  t(g, P.sibling), x = r(P, S.props), x.ref = wu(g, P, S), x.return = g, g = x;
                  break e;
                }
                t(g, P);
                break;
              } else
                e(g, P);
              P = P.sibling;
            }
            S.type === ul ? (x = $o(S.props.children, g.mode, T, S.key), x.return = g, g = x) : (T = _d(S.type, S.key, S.props, null, g.mode, T), T.ref = wu(g, x, S), T.return = g, g = T);
          }
          return o(g);
        case ll:
          e: {
            for (P = S.key; x !== null; ) {
              if (x.key === P)
                if (x.tag === 4 && x.stateNode.containerInfo === S.containerInfo && x.stateNode.implementation === S.implementation) {
                  t(g, x.sibling), x = r(x, S.children || []), x.return = g, g = x;
                  break e;
                } else {
                  t(g, x);
                  break;
                }
              else
                e(g, x);
              x = x.sibling;
            }
            x = Pg(S, g.mode, T), x.return = g, g = x;
          }
          return o(g);
        case Vs:
          return P = S._init, M(g, x, P(S._payload), T);
      }
      if (zu(S))
        return _(g, x, S, T);
      if (yu(S))
        return w(g, x, S, T);
      hh(g, S);
    }
    return typeof S == "string" && S !== "" || typeof S == "number" ? (S = "" + S, x !== null && x.tag === 6 ? (t(g, x.sibling), x = r(x, S), x.return = g, g = x) : (t(g, x), x = Rg(S, g.mode, T), x.return = g, g = x), o(g)) : t(g, x);
  }
  return M;
}
var Ol = zE(!0), BE = zE(!1), Vd = po(null), Gd = null, vl = null, Cy = null;
function Ry() {
  Cy = vl = Gd = null;
}
function Py(n) {
  var e = Vd.current;
  Yt(Vd), n._currentValue = e;
}
function Y0(n, e, t) {
  for (; n !== null; ) {
    var i = n.alternate;
    if ((n.childLanes & e) !== e ? (n.childLanes |= e, i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e), n === t)
      break;
    n = n.return;
  }
}
function Pl(n, e) {
  Gd = n, Cy = vl = null, n = n.dependencies, n !== null && n.firstContext !== null && (n.lanes & e && (yi = !0), n.firstContext = null);
}
function tr(n) {
  var e = n._currentValue;
  if (Cy !== n)
    if (n = { context: n, memoizedValue: e, next: null }, vl === null) {
      if (Gd === null)
        throw Error(Ee(308));
      vl = n, Gd.dependencies = { lanes: 0, firstContext: n };
    } else
      vl = vl.next = n;
  return e;
}
var jo = null;
function by(n) {
  jo === null ? jo = [n] : jo.push(n);
}
function HE(n, e, t, i) {
  var r = e.interleaved;
  return r === null ? (t.next = t, by(e)) : (t.next = r.next, r.next = t), e.interleaved = t, xs(n, i);
}
function xs(n, e) {
  n.lanes |= e;
  var t = n.alternate;
  for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null; )
    n.childLanes |= e, t = n.alternate, t !== null && (t.childLanes |= e), t = n, n = n.return;
  return t.tag === 3 ? t.stateNode : null;
}
var Gs = !1;
function Ly(n) {
  n.updateQueue = { baseState: n.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function VE(n, e) {
  n = n.updateQueue, e.updateQueue === n && (e.updateQueue = { baseState: n.baseState, firstBaseUpdate: n.firstBaseUpdate, lastBaseUpdate: n.lastBaseUpdate, shared: n.shared, effects: n.effects });
}
function gs(n, e) {
  return { eventTime: n, lane: e, tag: 0, payload: null, callback: null, next: null };
}
function Qs(n, e, t) {
  var i = n.updateQueue;
  if (i === null)
    return null;
  if (i = i.shared, Rt & 2) {
    var r = i.pending;
    return r === null ? e.next = e : (e.next = r.next, r.next = e), i.pending = e, xs(n, t);
  }
  return r = i.interleaved, r === null ? (e.next = e, by(i)) : (e.next = r.next, r.next = e), i.interleaved = e, xs(n, t);
}
function dd(n, e, t) {
  if (e = e.updateQueue, e !== null && (e = e.shared, (t & 4194240) !== 0)) {
    var i = e.lanes;
    i &= n.pendingLanes, t |= i, e.lanes = t, gy(n, t);
  }
}
function aS(n, e) {
  var t = n.updateQueue, i = n.alternate;
  if (i !== null && (i = i.updateQueue, t === i)) {
    var r = null, s = null;
    if (t = t.firstBaseUpdate, t !== null) {
      do {
        var o = { eventTime: t.eventTime, lane: t.lane, tag: t.tag, payload: t.payload, callback: t.callback, next: null };
        s === null ? r = s = o : s = s.next = o, t = t.next;
      } while (t !== null);
      s === null ? r = s = e : s = s.next = e;
    } else
      r = s = e;
    t = { baseState: i.baseState, firstBaseUpdate: r, lastBaseUpdate: s, shared: i.shared, effects: i.effects }, n.updateQueue = t;
    return;
  }
  n = t.lastBaseUpdate, n === null ? t.firstBaseUpdate = e : n.next = e, t.lastBaseUpdate = e;
}
function Wd(n, e, t, i) {
  var r = n.updateQueue;
  Gs = !1;
  var s = r.firstBaseUpdate, o = r.lastBaseUpdate, l = r.shared.pending;
  if (l !== null) {
    r.shared.pending = null;
    var c = l, f = c.next;
    c.next = null, o === null ? s = f : o.next = f, o = c;
    var h = n.alternate;
    h !== null && (h = h.updateQueue, l = h.lastBaseUpdate, l !== o && (l === null ? h.firstBaseUpdate = f : l.next = f, h.lastBaseUpdate = c));
  }
  if (s !== null) {
    var d = r.baseState;
    o = 0, h = f = c = null, l = s;
    do {
      var m = l.lane, v = l.eventTime;
      if ((i & m) === m) {
        h !== null && (h = h.next = {
          eventTime: v,
          lane: 0,
          tag: l.tag,
          payload: l.payload,
          callback: l.callback,
          next: null
        });
        e: {
          var _ = n, w = l;
          switch (m = e, v = t, w.tag) {
            case 1:
              if (_ = w.payload, typeof _ == "function") {
                d = _.call(v, d, m);
                break e;
              }
              d = _;
              break e;
            case 3:
              _.flags = _.flags & -65537 | 128;
            case 0:
              if (_ = w.payload, m = typeof _ == "function" ? _.call(v, d, m) : _, m == null)
                break e;
              d = tn({}, d, m);
              break e;
            case 2:
              Gs = !0;
          }
        }
        l.callback !== null && l.lane !== 0 && (n.flags |= 64, m = r.effects, m === null ? r.effects = [l] : m.push(l));
      } else
        v = { eventTime: v, lane: m, tag: l.tag, payload: l.payload, callback: l.callback, next: null }, h === null ? (f = h = v, c = d) : h = h.next = v, o |= m;
      if (l = l.next, l === null) {
        if (l = r.shared.pending, l === null)
          break;
        m = l, l = m.next, m.next = null, r.lastBaseUpdate = m, r.shared.pending = null;
      }
    } while (1);
    if (h === null && (c = d), r.baseState = c, r.firstBaseUpdate = f, r.lastBaseUpdate = h, e = r.shared.interleaved, e !== null) {
      r = e;
      do
        o |= r.lane, r = r.next;
      while (r !== e);
    } else
      s === null && (r.shared.lanes = 0);
    aa |= o, n.lanes = o, n.memoizedState = d;
  }
}
function lS(n, e, t) {
  if (n = e.effects, e.effects = null, n !== null)
    for (e = 0; e < n.length; e++) {
      var i = n[e], r = i.callback;
      if (r !== null) {
        if (i.callback = null, i = t, typeof r != "function")
          throw Error(Ee(191, r));
        r.call(i);
      }
    }
}
var Wc = {}, Br = po(Wc), gc = po(Wc), vc = po(Wc);
function Yo(n) {
  if (n === Wc)
    throw Error(Ee(174));
  return n;
}
function Iy(n, e) {
  switch (Gt(vc, e), Gt(gc, n), Gt(Br, Wc), n = e.nodeType, n) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : C0(null, "");
      break;
    default:
      n = n === 8 ? e.parentNode : e, e = n.namespaceURI || null, n = n.tagName, e = C0(e, n);
  }
  Yt(Br), Gt(Br, e);
}
function kl() {
  Yt(Br), Yt(gc), Yt(vc);
}
function GE(n) {
  Yo(vc.current);
  var e = Yo(Br.current), t = C0(e, n.type);
  e !== t && (Gt(gc, n), Gt(Br, t));
}
function Ny(n) {
  gc.current === n && (Yt(Br), Yt(gc));
}
var Jt = po(0);
function Xd(n) {
  for (var e = n; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (t !== null && (t = t.dehydrated, t === null || t.data === "$?" || t.data === "$!"))
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128)
        return e;
    } else if (e.child !== null) {
      e.child.return = e, e = e.child;
      continue;
    }
    if (e === n)
      break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n)
        return null;
      e = e.return;
    }
    e.sibling.return = e.return, e = e.sibling;
  }
  return null;
}
var Mg = [];
function Dy() {
  for (var n = 0; n < Mg.length; n++)
    Mg[n]._workInProgressVersionPrimary = null;
  Mg.length = 0;
}
var pd = Es.ReactCurrentDispatcher, wg = Es.ReactCurrentBatchConfig, oa = 0, en = null, Tn = null, Nn = null, jd = !1, Zu = !1, yc = 0, QP = 0;
function jn() {
  throw Error(Ee(321));
}
function Uy(n, e) {
  if (e === null)
    return !1;
  for (var t = 0; t < e.length && t < n.length; t++)
    if (!xr(n[t], e[t]))
      return !1;
  return !0;
}
function Oy(n, e, t, i, r, s) {
  if (oa = s, en = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, pd.current = n === null || n.memoizedState === null ? nb : ib, n = t(i, r), Zu) {
    s = 0;
    do {
      if (Zu = !1, yc = 0, 25 <= s)
        throw Error(Ee(301));
      s += 1, Nn = Tn = null, e.updateQueue = null, pd.current = rb, n = t(i, r);
    } while (Zu);
  }
  if (pd.current = Yd, e = Tn !== null && Tn.next !== null, oa = 0, Nn = Tn = en = null, jd = !1, e)
    throw Error(Ee(300));
  return n;
}
function ky() {
  var n = yc !== 0;
  return yc = 0, n;
}
function Ur() {
  var n = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  return Nn === null ? en.memoizedState = Nn = n : Nn = Nn.next = n, Nn;
}
function nr() {
  if (Tn === null) {
    var n = en.alternate;
    n = n !== null ? n.memoizedState : null;
  } else
    n = Tn.next;
  var e = Nn === null ? en.memoizedState : Nn.next;
  if (e !== null)
    Nn = e, Tn = n;
  else {
    if (n === null)
      throw Error(Ee(310));
    Tn = n, n = { memoizedState: Tn.memoizedState, baseState: Tn.baseState, baseQueue: Tn.baseQueue, queue: Tn.queue, next: null }, Nn === null ? en.memoizedState = Nn = n : Nn = Nn.next = n;
  }
  return Nn;
}
function _c(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function Eg(n) {
  var e = nr(), t = e.queue;
  if (t === null)
    throw Error(Ee(311));
  t.lastRenderedReducer = n;
  var i = Tn, r = i.baseQueue, s = t.pending;
  if (s !== null) {
    if (r !== null) {
      var o = r.next;
      r.next = s.next, s.next = o;
    }
    i.baseQueue = r = s, t.pending = null;
  }
  if (r !== null) {
    s = r.next, i = i.baseState;
    var l = o = null, c = null, f = s;
    do {
      var h = f.lane;
      if ((oa & h) === h)
        c !== null && (c = c.next = { lane: 0, action: f.action, hasEagerState: f.hasEagerState, eagerState: f.eagerState, next: null }), i = f.hasEagerState ? f.eagerState : n(i, f.action);
      else {
        var d = {
          lane: h,
          action: f.action,
          hasEagerState: f.hasEagerState,
          eagerState: f.eagerState,
          next: null
        };
        c === null ? (l = c = d, o = i) : c = c.next = d, en.lanes |= h, aa |= h;
      }
      f = f.next;
    } while (f !== null && f !== s);
    c === null ? o = i : c.next = l, xr(i, e.memoizedState) || (yi = !0), e.memoizedState = i, e.baseState = o, e.baseQueue = c, t.lastRenderedState = i;
  }
  if (n = t.interleaved, n !== null) {
    r = n;
    do
      s = r.lane, en.lanes |= s, aa |= s, r = r.next;
    while (r !== n);
  } else
    r === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function Tg(n) {
  var e = nr(), t = e.queue;
  if (t === null)
    throw Error(Ee(311));
  t.lastRenderedReducer = n;
  var i = t.dispatch, r = t.pending, s = e.memoizedState;
  if (r !== null) {
    t.pending = null;
    var o = r = r.next;
    do
      s = n(s, o.action), o = o.next;
    while (o !== r);
    xr(s, e.memoizedState) || (yi = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), t.lastRenderedState = s;
  }
  return [s, i];
}
function WE() {
}
function XE(n, e) {
  var t = en, i = nr(), r = e(), s = !xr(i.memoizedState, r);
  if (s && (i.memoizedState = r, yi = !0), i = i.queue, Fy(qE.bind(null, t, i, n), [n]), i.getSnapshot !== e || s || Nn !== null && Nn.memoizedState.tag & 1) {
    if (t.flags |= 2048, xc(9, YE.bind(null, t, i, r, e), void 0, null), Dn === null)
      throw Error(Ee(349));
    oa & 30 || jE(t, e, r);
  }
  return r;
}
function jE(n, e, t) {
  n.flags |= 16384, n = { getSnapshot: e, value: t }, e = en.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, en.updateQueue = e, e.stores = [n]) : (t = e.stores, t === null ? e.stores = [n] : t.push(n));
}
function YE(n, e, t, i) {
  e.value = t, e.getSnapshot = i, ZE(e) && KE(n);
}
function qE(n, e, t) {
  return t(function() {
    ZE(e) && KE(n);
  });
}
function ZE(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !xr(n, t);
  } catch {
    return !0;
  }
}
function KE(n) {
  var e = xs(n, 1);
  e !== null && yr(e, n, 1, -1);
}
function uS(n) {
  var e = Ur();
  return typeof n == "function" && (n = n()), e.memoizedState = e.baseState = n, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: _c, lastRenderedState: n }, e.queue = n, n = n.dispatch = tb.bind(null, en, n), [e.memoizedState, n];
}
function xc(n, e, t, i) {
  return n = { tag: n, create: e, destroy: t, deps: i, next: null }, e = en.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, en.updateQueue = e, e.lastEffect = n.next = n) : (t = e.lastEffect, t === null ? e.lastEffect = n.next = n : (i = t.next, t.next = n, n.next = i, e.lastEffect = n)), n;
}
function JE() {
  return nr().memoizedState;
}
function md(n, e, t, i) {
  var r = Ur();
  en.flags |= n, r.memoizedState = xc(1 | e, t, void 0, i === void 0 ? null : i);
}
function hp(n, e, t, i) {
  var r = nr();
  i = i === void 0 ? null : i;
  var s = void 0;
  if (Tn !== null) {
    var o = Tn.memoizedState;
    if (s = o.destroy, i !== null && Uy(i, o.deps)) {
      r.memoizedState = xc(e, t, s, i);
      return;
    }
  }
  en.flags |= n, r.memoizedState = xc(1 | e, t, s, i);
}
function cS(n, e) {
  return md(8390656, 8, n, e);
}
function Fy(n, e) {
  return hp(2048, 8, n, e);
}
function QE(n, e) {
  return hp(4, 2, n, e);
}
function $E(n, e) {
  return hp(4, 4, n, e);
}
function eT(n, e) {
  if (typeof e == "function")
    return n = n(), e(n), function() {
      e(null);
    };
  if (e != null)
    return n = n(), e.current = n, function() {
      e.current = null;
    };
}
function tT(n, e, t) {
  return t = t != null ? t.concat([n]) : null, hp(4, 4, eT.bind(null, e, n), t);
}
function zy() {
}
function nT(n, e) {
  var t = nr();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && Uy(e, i[1]) ? i[0] : (t.memoizedState = [n, e], n);
}
function iT(n, e) {
  var t = nr();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && Uy(e, i[1]) ? i[0] : (n = n(), t.memoizedState = [n, e], n);
}
function rT(n, e, t) {
  return oa & 21 ? (xr(t, e) || (t = uE(), en.lanes |= t, aa |= t, n.baseState = !0), e) : (n.baseState && (n.baseState = !1, yi = !0), n.memoizedState = t);
}
function $P(n, e) {
  var t = Ft;
  Ft = t !== 0 && 4 > t ? t : 4, n(!0);
  var i = wg.transition;
  wg.transition = {};
  try {
    n(!1), e();
  } finally {
    Ft = t, wg.transition = i;
  }
}
function sT() {
  return nr().memoizedState;
}
function eb(n, e, t) {
  var i = eo(n);
  if (t = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null }, oT(n))
    aT(e, t);
  else if (t = HE(n, e, t, i), t !== null) {
    var r = oi();
    yr(t, n, i, r), lT(t, e, i);
  }
}
function tb(n, e, t) {
  var i = eo(n), r = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null };
  if (oT(n))
    aT(e, r);
  else {
    var s = n.alternate;
    if (n.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null))
      try {
        var o = e.lastRenderedState, l = s(o, t);
        if (r.hasEagerState = !0, r.eagerState = l, xr(l, o)) {
          var c = e.interleaved;
          c === null ? (r.next = r, by(e)) : (r.next = c.next, c.next = r), e.interleaved = r;
          return;
        }
      } catch {
      } finally {
      }
    t = HE(n, e, r, i), t !== null && (r = oi(), yr(t, n, i, r), lT(t, e, i));
  }
}
function oT(n) {
  var e = n.alternate;
  return n === en || e !== null && e === en;
}
function aT(n, e) {
  Zu = jd = !0;
  var t = n.pending;
  t === null ? e.next = e : (e.next = t.next, t.next = e), n.pending = e;
}
function lT(n, e, t) {
  if (t & 4194240) {
    var i = e.lanes;
    i &= n.pendingLanes, t |= i, e.lanes = t, gy(n, t);
  }
}
var Yd = { readContext: tr, useCallback: jn, useContext: jn, useEffect: jn, useImperativeHandle: jn, useInsertionEffect: jn, useLayoutEffect: jn, useMemo: jn, useReducer: jn, useRef: jn, useState: jn, useDebugValue: jn, useDeferredValue: jn, useTransition: jn, useMutableSource: jn, useSyncExternalStore: jn, useId: jn, unstable_isNewReconciler: !1 }, nb = { readContext: tr, useCallback: function(n, e) {
  return Ur().memoizedState = [n, e === void 0 ? null : e], n;
}, useContext: tr, useEffect: cS, useImperativeHandle: function(n, e, t) {
  return t = t != null ? t.concat([n]) : null, md(
    4194308,
    4,
    eT.bind(null, e, n),
    t
  );
}, useLayoutEffect: function(n, e) {
  return md(4194308, 4, n, e);
}, useInsertionEffect: function(n, e) {
  return md(4, 2, n, e);
}, useMemo: function(n, e) {
  var t = Ur();
  return e = e === void 0 ? null : e, n = n(), t.memoizedState = [n, e], n;
}, useReducer: function(n, e, t) {
  var i = Ur();
  return e = t !== void 0 ? t(e) : e, i.memoizedState = i.baseState = e, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: n, lastRenderedState: e }, i.queue = n, n = n.dispatch = eb.bind(null, en, n), [i.memoizedState, n];
}, useRef: function(n) {
  var e = Ur();
  return n = { current: n }, e.memoizedState = n;
}, useState: uS, useDebugValue: zy, useDeferredValue: function(n) {
  return Ur().memoizedState = n;
}, useTransition: function() {
  var n = uS(!1), e = n[0];
  return n = $P.bind(null, n[1]), Ur().memoizedState = n, [e, n];
}, useMutableSource: function() {
}, useSyncExternalStore: function(n, e, t) {
  var i = en, r = Ur();
  if (Zt) {
    if (t === void 0)
      throw Error(Ee(407));
    t = t();
  } else {
    if (t = e(), Dn === null)
      throw Error(Ee(349));
    oa & 30 || jE(i, e, t);
  }
  r.memoizedState = t;
  var s = { value: t, getSnapshot: e };
  return r.queue = s, cS(qE.bind(
    null,
    i,
    s,
    n
  ), [n]), i.flags |= 2048, xc(9, YE.bind(null, i, s, t, e), void 0, null), t;
}, useId: function() {
  var n = Ur(), e = Dn.identifierPrefix;
  if (Zt) {
    var t = ps, i = ds;
    t = (i & ~(1 << 32 - vr(i) - 1)).toString(32) + t, e = ":" + e + "R" + t, t = yc++, 0 < t && (e += "H" + t.toString(32)), e += ":";
  } else
    t = QP++, e = ":" + e + "r" + t.toString(32) + ":";
  return n.memoizedState = e;
}, unstable_isNewReconciler: !1 }, ib = {
  readContext: tr,
  useCallback: nT,
  useContext: tr,
  useEffect: Fy,
  useImperativeHandle: tT,
  useInsertionEffect: QE,
  useLayoutEffect: $E,
  useMemo: iT,
  useReducer: Eg,
  useRef: JE,
  useState: function() {
    return Eg(_c);
  },
  useDebugValue: zy,
  useDeferredValue: function(n) {
    var e = nr();
    return rT(e, Tn.memoizedState, n);
  },
  useTransition: function() {
    var n = Eg(_c)[0], e = nr().memoizedState;
    return [n, e];
  },
  useMutableSource: WE,
  useSyncExternalStore: XE,
  useId: sT,
  unstable_isNewReconciler: !1
}, rb = { readContext: tr, useCallback: nT, useContext: tr, useEffect: Fy, useImperativeHandle: tT, useInsertionEffect: QE, useLayoutEffect: $E, useMemo: iT, useReducer: Tg, useRef: JE, useState: function() {
  return Tg(_c);
}, useDebugValue: zy, useDeferredValue: function(n) {
  var e = nr();
  return Tn === null ? e.memoizedState = n : rT(e, Tn.memoizedState, n);
}, useTransition: function() {
  var n = Tg(_c)[0], e = nr().memoizedState;
  return [n, e];
}, useMutableSource: WE, useSyncExternalStore: XE, useId: sT, unstable_isNewReconciler: !1 };
function fr(n, e) {
  if (n && n.defaultProps) {
    e = tn({}, e), n = n.defaultProps;
    for (var t in n)
      e[t] === void 0 && (e[t] = n[t]);
    return e;
  }
  return e;
}
function q0(n, e, t, i) {
  e = n.memoizedState, t = t(i, e), t = t == null ? e : tn({}, e, t), n.memoizedState = t, n.lanes === 0 && (n.updateQueue.baseState = t);
}
var dp = { isMounted: function(n) {
  return (n = n._reactInternals) ? pa(n) === n : !1;
}, enqueueSetState: function(n, e, t) {
  n = n._reactInternals;
  var i = oi(), r = eo(n), s = gs(i, r);
  s.payload = e, t != null && (s.callback = t), e = Qs(n, s, r), e !== null && (yr(e, n, r, i), dd(e, n, r));
}, enqueueReplaceState: function(n, e, t) {
  n = n._reactInternals;
  var i = oi(), r = eo(n), s = gs(i, r);
  s.tag = 1, s.payload = e, t != null && (s.callback = t), e = Qs(n, s, r), e !== null && (yr(e, n, r, i), dd(e, n, r));
}, enqueueForceUpdate: function(n, e) {
  n = n._reactInternals;
  var t = oi(), i = eo(n), r = gs(t, i);
  r.tag = 2, e != null && (r.callback = e), e = Qs(n, r, i), e !== null && (yr(e, n, i, t), dd(e, n, i));
} };
function fS(n, e, t, i, r, s, o) {
  return n = n.stateNode, typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(i, s, o) : e.prototype && e.prototype.isPureReactComponent ? !hc(t, i) || !hc(r, s) : !0;
}
function uT(n, e, t) {
  var i = !1, r = ao, s = e.contextType;
  return typeof s == "object" && s !== null ? s = tr(s) : (r = xi(e) ? ra : $n.current, i = e.contextTypes, s = (i = i != null) ? Dl(n, r) : ao), e = new e(t, s), n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = dp, n.stateNode = e, e._reactInternals = n, i && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = r, n.__reactInternalMemoizedMaskedChildContext = s), e;
}
function hS(n, e, t, i) {
  n = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, i), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, i), e.state !== n && dp.enqueueReplaceState(e, e.state, null);
}
function Z0(n, e, t, i) {
  var r = n.stateNode;
  r.props = t, r.state = n.memoizedState, r.refs = {}, Ly(n);
  var s = e.contextType;
  typeof s == "object" && s !== null ? r.context = tr(s) : (s = xi(e) ? ra : $n.current, r.context = Dl(n, s)), r.state = n.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (q0(n, e, s, t), r.state = n.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), e !== r.state && dp.enqueueReplaceState(r, r.state, null), Wd(n, t, r, i), r.state = n.memoizedState), typeof r.componentDidMount == "function" && (n.flags |= 4194308);
}
function Fl(n, e) {
  try {
    var t = "", i = e;
    do
      t += IR(i), i = i.return;
    while (i);
    var r = t;
  } catch (s) {
    r = `
Error generating stack: ` + s.message + `
` + s.stack;
  }
  return { value: n, source: e, stack: r, digest: null };
}
function Ag(n, e, t) {
  return { value: n, source: null, stack: t ?? null, digest: e ?? null };
}
function K0(n, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function() {
      throw t;
    });
  }
}
var sb = typeof WeakMap == "function" ? WeakMap : Map;
function cT(n, e, t) {
  t = gs(-1, t), t.tag = 3, t.payload = { element: null };
  var i = e.value;
  return t.callback = function() {
    Zd || (Zd = !0, ov = i), K0(n, e);
  }, t;
}
function fT(n, e, t) {
  t = gs(-1, t), t.tag = 3;
  var i = n.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var r = e.value;
    t.payload = function() {
      return i(r);
    }, t.callback = function() {
      K0(n, e);
    };
  }
  var s = n.stateNode;
  return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function() {
    K0(n, e), typeof i != "function" && ($s === null ? $s = /* @__PURE__ */ new Set([this]) : $s.add(this));
    var o = e.stack;
    this.componentDidCatch(e.value, { componentStack: o !== null ? o : "" });
  }), t;
}
function dS(n, e, t) {
  var i = n.pingCache;
  if (i === null) {
    i = n.pingCache = new sb();
    var r = /* @__PURE__ */ new Set();
    i.set(e, r);
  } else
    r = i.get(e), r === void 0 && (r = /* @__PURE__ */ new Set(), i.set(e, r));
  r.has(t) || (r.add(t), n = _b.bind(null, n, e, t), e.then(n, n));
}
function pS(n) {
  do {
    var e;
    if ((e = n.tag === 13) && (e = n.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e)
      return n;
    n = n.return;
  } while (n !== null);
  return null;
}
function mS(n, e, t, i, r) {
  return n.mode & 1 ? (n.flags |= 65536, n.lanes = r, n) : (n === e ? n.flags |= 65536 : (n.flags |= 128, t.flags |= 131072, t.flags &= -52805, t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = gs(-1, 1), e.tag = 2, Qs(t, e, 1))), t.lanes |= 1), n);
}
var ob = Es.ReactCurrentOwner, yi = !1;
function si(n, e, t, i) {
  e.child = n === null ? BE(e, null, t, i) : Ol(e, n.child, t, i);
}
function gS(n, e, t, i, r) {
  t = t.render;
  var s = e.ref;
  return Pl(e, r), i = Oy(n, e, t, i, s, r), t = ky(), n !== null && !yi ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~r, Ss(n, e, r)) : (Zt && t && Ey(e), e.flags |= 1, si(n, e, i, r), e.child);
}
function vS(n, e, t, i, r) {
  if (n === null) {
    var s = t.type;
    return typeof s == "function" && !Yy(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15, e.type = s, hT(n, e, s, i, r)) : (n = _d(t.type, null, i, e, e.mode, r), n.ref = e.ref, n.return = e, e.child = n);
  }
  if (s = n.child, !(n.lanes & r)) {
    var o = s.memoizedProps;
    if (t = t.compare, t = t !== null ? t : hc, t(o, i) && n.ref === e.ref)
      return Ss(n, e, r);
  }
  return e.flags |= 1, n = to(s, i), n.ref = e.ref, n.return = e, e.child = n;
}
function hT(n, e, t, i, r) {
  if (n !== null) {
    var s = n.memoizedProps;
    if (hc(s, i) && n.ref === e.ref)
      if (yi = !1, e.pendingProps = i = s, (n.lanes & r) !== 0)
        n.flags & 131072 && (yi = !0);
      else
        return e.lanes = n.lanes, Ss(n, e, r);
  }
  return J0(n, e, t, i, r);
}
function dT(n, e, t) {
  var i = e.pendingProps, r = i.children, s = n !== null ? n.memoizedState : null;
  if (i.mode === "hidden")
    if (!(e.mode & 1))
      e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Gt(_l, Ii), Ii |= t;
    else {
      if (!(t & 1073741824))
        return n = s !== null ? s.baseLanes | t : t, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: n, cachePool: null, transitions: null }, e.updateQueue = null, Gt(_l, Ii), Ii |= n, null;
      e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, i = s !== null ? s.baseLanes : t, Gt(_l, Ii), Ii |= i;
    }
  else
    s !== null ? (i = s.baseLanes | t, e.memoizedState = null) : i = t, Gt(_l, Ii), Ii |= i;
  return si(n, e, r, t), e.child;
}
function pT(n, e) {
  var t = e.ref;
  (n === null && t !== null || n !== null && n.ref !== t) && (e.flags |= 512, e.flags |= 2097152);
}
function J0(n, e, t, i, r) {
  var s = xi(t) ? ra : $n.current;
  return s = Dl(e, s), Pl(e, r), t = Oy(n, e, t, i, s, r), i = ky(), n !== null && !yi ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~r, Ss(n, e, r)) : (Zt && i && Ey(e), e.flags |= 1, si(n, e, t, r), e.child);
}
function yS(n, e, t, i, r) {
  if (xi(t)) {
    var s = !0;
    zd(e);
  } else
    s = !1;
  if (Pl(e, r), e.stateNode === null)
    gd(n, e), uT(e, t, i), Z0(e, t, i, r), i = !0;
  else if (n === null) {
    var o = e.stateNode, l = e.memoizedProps;
    o.props = l;
    var c = o.context, f = t.contextType;
    typeof f == "object" && f !== null ? f = tr(f) : (f = xi(t) ? ra : $n.current, f = Dl(e, f));
    var h = t.getDerivedStateFromProps, d = typeof h == "function" || typeof o.getSnapshotBeforeUpdate == "function";
    d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (l !== i || c !== f) && hS(e, o, i, f), Gs = !1;
    var m = e.memoizedState;
    o.state = m, Wd(e, i, o, r), c = e.memoizedState, l !== i || m !== c || _i.current || Gs ? (typeof h == "function" && (q0(e, t, h, i), c = e.memoizedState), (l = Gs || fS(e, t, l, i, m, c, f)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = i, e.memoizedState = c), o.props = i, o.state = c, o.context = f, i = l) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), i = !1);
  } else {
    o = e.stateNode, VE(n, e), l = e.memoizedProps, f = e.type === e.elementType ? l : fr(e.type, l), o.props = f, d = e.pendingProps, m = o.context, c = t.contextType, typeof c == "object" && c !== null ? c = tr(c) : (c = xi(t) ? ra : $n.current, c = Dl(e, c));
    var v = t.getDerivedStateFromProps;
    (h = typeof v == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (l !== d || m !== c) && hS(e, o, i, c), Gs = !1, m = e.memoizedState, o.state = m, Wd(e, i, o, r);
    var _ = e.memoizedState;
    l !== d || m !== _ || _i.current || Gs ? (typeof v == "function" && (q0(e, t, v, i), _ = e.memoizedState), (f = Gs || fS(e, t, f, i, m, _, c) || !1) ? (h || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, _, c), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, _, c)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || l === n.memoizedProps && m === n.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || l === n.memoizedProps && m === n.memoizedState || (e.flags |= 1024), e.memoizedProps = i, e.memoizedState = _), o.props = i, o.state = _, o.context = c, i = f) : (typeof o.componentDidUpdate != "function" || l === n.memoizedProps && m === n.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || l === n.memoizedProps && m === n.memoizedState || (e.flags |= 1024), i = !1);
  }
  return Q0(n, e, t, i, s, r);
}
function Q0(n, e, t, i, r, s) {
  pT(n, e);
  var o = (e.flags & 128) !== 0;
  if (!i && !o)
    return r && iS(e, t, !1), Ss(n, e, s);
  i = e.stateNode, ob.current = e;
  var l = o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
  return e.flags |= 1, n !== null && o ? (e.child = Ol(e, n.child, null, s), e.child = Ol(e, null, l, s)) : si(n, e, l, s), e.memoizedState = i.state, r && iS(e, t, !0), e.child;
}
function mT(n) {
  var e = n.stateNode;
  e.pendingContext ? nS(n, e.pendingContext, e.pendingContext !== e.context) : e.context && nS(n, e.context, !1), Iy(n, e.containerInfo);
}
function _S(n, e, t, i, r) {
  return Ul(), Ay(r), e.flags |= 256, si(n, e, t, i), e.child;
}
var $0 = { dehydrated: null, treeContext: null, retryLane: 0 };
function ev(n) {
  return { baseLanes: n, cachePool: null, transitions: null };
}
function gT(n, e, t) {
  var i = e.pendingProps, r = Jt.current, s = !1, o = (e.flags & 128) !== 0, l;
  if ((l = o) || (l = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0), l ? (s = !0, e.flags &= -129) : (n === null || n.memoizedState !== null) && (r |= 1), Gt(Jt, r & 1), n === null)
    return j0(e), n = e.memoizedState, n !== null && (n = n.dehydrated, n !== null) ? (e.mode & 1 ? n.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = i.children, n = i.fallback, s ? (i = e.mode, s = e.child, o = { mode: "hidden", children: o }, !(i & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = gp(o, i, 0, null), n = $o(n, i, t, null), s.return = e, n.return = e, s.sibling = n, e.child = s, e.child.memoizedState = ev(t), e.memoizedState = $0, n) : By(e, o));
  if (r = n.memoizedState, r !== null && (l = r.dehydrated, l !== null))
    return ab(n, e, o, i, l, r, t);
  if (s) {
    s = i.fallback, o = e.mode, r = n.child, l = r.sibling;
    var c = { mode: "hidden", children: i.children };
    return !(o & 1) && e.child !== r ? (i = e.child, i.childLanes = 0, i.pendingProps = c, e.deletions = null) : (i = to(r, c), i.subtreeFlags = r.subtreeFlags & 14680064), l !== null ? s = to(l, s) : (s = $o(s, o, t, null), s.flags |= 2), s.return = e, i.return = e, i.sibling = s, e.child = i, i = s, s = e.child, o = n.child.memoizedState, o = o === null ? ev(t) : { baseLanes: o.baseLanes | t, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = n.childLanes & ~t, e.memoizedState = $0, i;
  }
  return s = n.child, n = s.sibling, i = to(s, { mode: "visible", children: i.children }), !(e.mode & 1) && (i.lanes = t), i.return = e, i.sibling = null, n !== null && (t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n)), e.child = i, e.memoizedState = null, i;
}
function By(n, e) {
  return e = gp({ mode: "visible", children: e }, n.mode, 0, null), e.return = n, n.child = e;
}
function dh(n, e, t, i) {
  return i !== null && Ay(i), Ol(e, n.child, null, t), n = By(e, e.pendingProps.children), n.flags |= 2, e.memoizedState = null, n;
}
function ab(n, e, t, i, r, s, o) {
  if (t)
    return e.flags & 256 ? (e.flags &= -257, i = Ag(Error(Ee(422))), dh(n, e, o, i)) : e.memoizedState !== null ? (e.child = n.child, e.flags |= 128, null) : (s = i.fallback, r = e.mode, i = gp({ mode: "visible", children: i.children }, r, 0, null), s = $o(s, r, o, null), s.flags |= 2, i.return = e, s.return = e, i.sibling = s, e.child = i, e.mode & 1 && Ol(e, n.child, null, o), e.child.memoizedState = ev(o), e.memoizedState = $0, s);
  if (!(e.mode & 1))
    return dh(n, e, o, null);
  if (r.data === "$!") {
    if (i = r.nextSibling && r.nextSibling.dataset, i)
      var l = i.dgst;
    return i = l, s = Error(Ee(419)), i = Ag(s, i, void 0), dh(n, e, o, i);
  }
  if (l = (o & n.childLanes) !== 0, yi || l) {
    if (i = Dn, i !== null) {
      switch (o & -o) {
        case 4:
          r = 2;
          break;
        case 16:
          r = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          r = 32;
          break;
        case 536870912:
          r = 268435456;
          break;
        default:
          r = 0;
      }
      r = r & (i.suspendedLanes | o) ? 0 : r, r !== 0 && r !== s.retryLane && (s.retryLane = r, xs(n, r), yr(i, n, r, -1));
    }
    return jy(), i = Ag(Error(Ee(421))), dh(n, e, o, i);
  }
  return r.data === "$?" ? (e.flags |= 128, e.child = n.child, e = xb.bind(null, n), r._reactRetry = e, null) : (n = s.treeContext, Ni = Js(r.nextSibling), Ui = e, Zt = !0, pr = null, n !== null && (Ji[Qi++] = ds, Ji[Qi++] = ps, Ji[Qi++] = sa, ds = n.id, ps = n.overflow, sa = e), e = By(e, i.children), e.flags |= 4096, e);
}
function xS(n, e, t) {
  n.lanes |= e;
  var i = n.alternate;
  i !== null && (i.lanes |= e), Y0(n.return, e, t);
}
function Cg(n, e, t, i, r) {
  var s = n.memoizedState;
  s === null ? n.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: i, tail: t, tailMode: r } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = i, s.tail = t, s.tailMode = r);
}
function vT(n, e, t) {
  var i = e.pendingProps, r = i.revealOrder, s = i.tail;
  if (si(n, e, i.children, t), i = Jt.current, i & 2)
    i = i & 1 | 2, e.flags |= 128;
  else {
    if (n !== null && n.flags & 128)
      e:
        for (n = e.child; n !== null; ) {
          if (n.tag === 13)
            n.memoizedState !== null && xS(n, t, e);
          else if (n.tag === 19)
            xS(n, t, e);
          else if (n.child !== null) {
            n.child.return = n, n = n.child;
            continue;
          }
          if (n === e)
            break e;
          for (; n.sibling === null; ) {
            if (n.return === null || n.return === e)
              break e;
            n = n.return;
          }
          n.sibling.return = n.return, n = n.sibling;
        }
    i &= 1;
  }
  if (Gt(Jt, i), !(e.mode & 1))
    e.memoizedState = null;
  else
    switch (r) {
      case "forwards":
        for (t = e.child, r = null; t !== null; )
          n = t.alternate, n !== null && Xd(n) === null && (r = t), t = t.sibling;
        t = r, t === null ? (r = e.child, e.child = null) : (r = t.sibling, t.sibling = null), Cg(e, !1, r, t, s);
        break;
      case "backwards":
        for (t = null, r = e.child, e.child = null; r !== null; ) {
          if (n = r.alternate, n !== null && Xd(n) === null) {
            e.child = r;
            break;
          }
          n = r.sibling, r.sibling = t, t = r, r = n;
        }
        Cg(e, !0, t, null, s);
        break;
      case "together":
        Cg(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function gd(n, e) {
  !(e.mode & 1) && n !== null && (n.alternate = null, e.alternate = null, e.flags |= 2);
}
function Ss(n, e, t) {
  if (n !== null && (e.dependencies = n.dependencies), aa |= e.lanes, !(t & e.childLanes))
    return null;
  if (n !== null && e.child !== n.child)
    throw Error(Ee(153));
  if (e.child !== null) {
    for (n = e.child, t = to(n, n.pendingProps), e.child = t, t.return = e; n.sibling !== null; )
      n = n.sibling, t = t.sibling = to(n, n.pendingProps), t.return = e;
    t.sibling = null;
  }
  return e.child;
}
function lb(n, e, t) {
  switch (e.tag) {
    case 3:
      mT(e), Ul();
      break;
    case 5:
      GE(e);
      break;
    case 1:
      xi(e.type) && zd(e);
      break;
    case 4:
      Iy(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context, r = e.memoizedProps.value;
      Gt(Vd, i._currentValue), i._currentValue = r;
      break;
    case 13:
      if (i = e.memoizedState, i !== null)
        return i.dehydrated !== null ? (Gt(Jt, Jt.current & 1), e.flags |= 128, null) : t & e.child.childLanes ? gT(n, e, t) : (Gt(Jt, Jt.current & 1), n = Ss(n, e, t), n !== null ? n.sibling : null);
      Gt(Jt, Jt.current & 1);
      break;
    case 19:
      if (i = (t & e.childLanes) !== 0, n.flags & 128) {
        if (i)
          return vT(n, e, t);
        e.flags |= 128;
      }
      if (r = e.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), Gt(Jt, Jt.current), i)
        break;
      return null;
    case 22:
    case 23:
      return e.lanes = 0, dT(n, e, t);
  }
  return Ss(n, e, t);
}
var yT, tv, _T, xT;
yT = function(n, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6)
      n.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      t.child.return = t, t = t.child;
      continue;
    }
    if (t === e)
      break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e)
        return;
      t = t.return;
    }
    t.sibling.return = t.return, t = t.sibling;
  }
};
tv = function() {
};
_T = function(n, e, t, i) {
  var r = n.memoizedProps;
  if (r !== i) {
    n = e.stateNode, Yo(Br.current);
    var s = null;
    switch (t) {
      case "input":
        r = w0(n, r), i = w0(n, i), s = [];
        break;
      case "select":
        r = tn({}, r, { value: void 0 }), i = tn({}, i, { value: void 0 }), s = [];
        break;
      case "textarea":
        r = A0(n, r), i = A0(n, i), s = [];
        break;
      default:
        typeof r.onClick != "function" && typeof i.onClick == "function" && (n.onclick = kd);
    }
    R0(t, i);
    var o;
    t = null;
    for (f in r)
      if (!i.hasOwnProperty(f) && r.hasOwnProperty(f) && r[f] != null)
        if (f === "style") {
          var l = r[f];
          for (o in l)
            l.hasOwnProperty(o) && (t || (t = {}), t[o] = "");
        } else
          f !== "dangerouslySetInnerHTML" && f !== "children" && f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && f !== "autoFocus" && (sc.hasOwnProperty(f) ? s || (s = []) : (s = s || []).push(f, null));
    for (f in i) {
      var c = i[f];
      if (l = r != null ? r[f] : void 0, i.hasOwnProperty(f) && c !== l && (c != null || l != null))
        if (f === "style")
          if (l) {
            for (o in l)
              !l.hasOwnProperty(o) || c && c.hasOwnProperty(o) || (t || (t = {}), t[o] = "");
            for (o in c)
              c.hasOwnProperty(o) && l[o] !== c[o] && (t || (t = {}), t[o] = c[o]);
          } else
            t || (s || (s = []), s.push(
              f,
              t
            )), t = c;
        else
          f === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0, l = l ? l.__html : void 0, c != null && l !== c && (s = s || []).push(f, c)) : f === "children" ? typeof c != "string" && typeof c != "number" || (s = s || []).push(f, "" + c) : f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && (sc.hasOwnProperty(f) ? (c != null && f === "onScroll" && Xt("scroll", n), s || l === c || (s = [])) : (s = s || []).push(f, c));
    }
    t && (s = s || []).push("style", t);
    var f = s;
    (e.updateQueue = f) && (e.flags |= 4);
  }
};
xT = function(n, e, t, i) {
  t !== i && (e.flags |= 4);
};
function Eu(n, e) {
  if (!Zt)
    switch (n.tailMode) {
      case "hidden":
        e = n.tail;
        for (var t = null; e !== null; )
          e.alternate !== null && (t = e), e = e.sibling;
        t === null ? n.tail = null : t.sibling = null;
        break;
      case "collapsed":
        t = n.tail;
        for (var i = null; t !== null; )
          t.alternate !== null && (i = t), t = t.sibling;
        i === null ? e || n.tail === null ? n.tail = null : n.tail.sibling = null : i.sibling = null;
    }
}
function Yn(n) {
  var e = n.alternate !== null && n.alternate.child === n.child, t = 0, i = 0;
  if (e)
    for (var r = n.child; r !== null; )
      t |= r.lanes | r.childLanes, i |= r.subtreeFlags & 14680064, i |= r.flags & 14680064, r.return = n, r = r.sibling;
  else
    for (r = n.child; r !== null; )
      t |= r.lanes | r.childLanes, i |= r.subtreeFlags, i |= r.flags, r.return = n, r = r.sibling;
  return n.subtreeFlags |= i, n.childLanes = t, e;
}
function ub(n, e, t) {
  var i = e.pendingProps;
  switch (Ty(e), e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Yn(e), null;
    case 1:
      return xi(e.type) && Fd(), Yn(e), null;
    case 3:
      return i = e.stateNode, kl(), Yt(_i), Yt($n), Dy(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), (n === null || n.child === null) && (fh(e) ? e.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, pr !== null && (uv(pr), pr = null))), tv(n, e), Yn(e), null;
    case 5:
      Ny(e);
      var r = Yo(vc.current);
      if (t = e.type, n !== null && e.stateNode != null)
        _T(n, e, t, i, r), n.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
      else {
        if (!i) {
          if (e.stateNode === null)
            throw Error(Ee(166));
          return Yn(e), null;
        }
        if (n = Yo(Br.current), fh(e)) {
          i = e.stateNode, t = e.type;
          var s = e.memoizedProps;
          switch (i[Or] = e, i[mc] = s, n = (e.mode & 1) !== 0, t) {
            case "dialog":
              Xt("cancel", i), Xt("close", i);
              break;
            case "iframe":
            case "object":
            case "embed":
              Xt("load", i);
              break;
            case "video":
            case "audio":
              for (r = 0; r < Hu.length; r++)
                Xt(Hu[r], i);
              break;
            case "source":
              Xt("error", i);
              break;
            case "img":
            case "image":
            case "link":
              Xt(
                "error",
                i
              ), Xt("load", i);
              break;
            case "details":
              Xt("toggle", i);
              break;
            case "input":
              P1(i, s), Xt("invalid", i);
              break;
            case "select":
              i._wrapperState = { wasMultiple: !!s.multiple }, Xt("invalid", i);
              break;
            case "textarea":
              L1(i, s), Xt("invalid", i);
          }
          R0(t, s), r = null;
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var l = s[o];
              o === "children" ? typeof l == "string" ? i.textContent !== l && (s.suppressHydrationWarning !== !0 && ch(i.textContent, l, n), r = ["children", l]) : typeof l == "number" && i.textContent !== "" + l && (s.suppressHydrationWarning !== !0 && ch(
                i.textContent,
                l,
                n
              ), r = ["children", "" + l]) : sc.hasOwnProperty(o) && l != null && o === "onScroll" && Xt("scroll", i);
            }
          switch (t) {
            case "input":
              nh(i), b1(i, s, !0);
              break;
            case "textarea":
              nh(i), I1(i);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (i.onclick = kd);
          }
          i = r, e.updateQueue = i, i !== null && (e.flags |= 4);
        } else {
          o = r.nodeType === 9 ? r : r.ownerDocument, n === "http://www.w3.org/1999/xhtml" && (n = qw(t)), n === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n = o.createElement("div"), n.innerHTML = "<script><\/script>", n = n.removeChild(n.firstChild)) : typeof i.is == "string" ? n = o.createElement(t, { is: i.is }) : (n = o.createElement(t), t === "select" && (o = n, i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : n = o.createElementNS(n, t), n[Or] = e, n[mc] = i, yT(n, e, !1, !1), e.stateNode = n;
          e: {
            switch (o = P0(t, i), t) {
              case "dialog":
                Xt("cancel", n), Xt("close", n), r = i;
                break;
              case "iframe":
              case "object":
              case "embed":
                Xt("load", n), r = i;
                break;
              case "video":
              case "audio":
                for (r = 0; r < Hu.length; r++)
                  Xt(Hu[r], n);
                r = i;
                break;
              case "source":
                Xt("error", n), r = i;
                break;
              case "img":
              case "image":
              case "link":
                Xt(
                  "error",
                  n
                ), Xt("load", n), r = i;
                break;
              case "details":
                Xt("toggle", n), r = i;
                break;
              case "input":
                P1(n, i), r = w0(n, i), Xt("invalid", n);
                break;
              case "option":
                r = i;
                break;
              case "select":
                n._wrapperState = { wasMultiple: !!i.multiple }, r = tn({}, i, { value: void 0 }), Xt("invalid", n);
                break;
              case "textarea":
                L1(n, i), r = A0(n, i), Xt("invalid", n);
                break;
              default:
                r = i;
            }
            R0(t, r), l = r;
            for (s in l)
              if (l.hasOwnProperty(s)) {
                var c = l[s];
                s === "style" ? Jw(n, c) : s === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0, c != null && Zw(n, c)) : s === "children" ? typeof c == "string" ? (t !== "textarea" || c !== "") && oc(n, c) : typeof c == "number" && oc(n, "" + c) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (sc.hasOwnProperty(s) ? c != null && s === "onScroll" && Xt("scroll", n) : c != null && cy(n, s, c, o));
              }
            switch (t) {
              case "input":
                nh(n), b1(n, i, !1);
                break;
              case "textarea":
                nh(n), I1(n);
                break;
              case "option":
                i.value != null && n.setAttribute("value", "" + oo(i.value));
                break;
              case "select":
                n.multiple = !!i.multiple, s = i.value, s != null ? Tl(n, !!i.multiple, s, !1) : i.defaultValue != null && Tl(
                  n,
                  !!i.multiple,
                  i.defaultValue,
                  !0
                );
                break;
              default:
                typeof r.onClick == "function" && (n.onclick = kd);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && (e.flags |= 512, e.flags |= 2097152);
      }
      return Yn(e), null;
    case 6:
      if (n && e.stateNode != null)
        xT(n, e, n.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null)
          throw Error(Ee(166));
        if (t = Yo(vc.current), Yo(Br.current), fh(e)) {
          if (i = e.stateNode, t = e.memoizedProps, i[Or] = e, (s = i.nodeValue !== t) && (n = Ui, n !== null))
            switch (n.tag) {
              case 3:
                ch(i.nodeValue, t, (n.mode & 1) !== 0);
                break;
              case 5:
                n.memoizedProps.suppressHydrationWarning !== !0 && ch(i.nodeValue, t, (n.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i), i[Or] = e, e.stateNode = i;
      }
      return Yn(e), null;
    case 13:
      if (Yt(Jt), i = e.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
        if (Zt && Ni !== null && e.mode & 1 && !(e.flags & 128))
          FE(), Ul(), e.flags |= 98560, s = !1;
        else if (s = fh(e), i !== null && i.dehydrated !== null) {
          if (n === null) {
            if (!s)
              throw Error(Ee(318));
            if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s)
              throw Error(Ee(317));
            s[Or] = e;
          } else
            Ul(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4;
          Yn(e), s = !1;
        } else
          pr !== null && (uv(pr), pr = null), s = !0;
        if (!s)
          return e.flags & 65536 ? e : null;
      }
      return e.flags & 128 ? (e.lanes = t, e) : (i = i !== null, i !== (n !== null && n.memoizedState !== null) && i && (e.child.flags |= 8192, e.mode & 1 && (n === null || Jt.current & 1 ? An === 0 && (An = 3) : jy())), e.updateQueue !== null && (e.flags |= 4), Yn(e), null);
    case 4:
      return kl(), tv(n, e), n === null && dc(e.stateNode.containerInfo), Yn(e), null;
    case 10:
      return Py(e.type._context), Yn(e), null;
    case 17:
      return xi(e.type) && Fd(), Yn(e), null;
    case 19:
      if (Yt(Jt), s = e.memoizedState, s === null)
        return Yn(e), null;
      if (i = (e.flags & 128) !== 0, o = s.rendering, o === null)
        if (i)
          Eu(s, !1);
        else {
          if (An !== 0 || n !== null && n.flags & 128)
            for (n = e.child; n !== null; ) {
              if (o = Xd(n), o !== null) {
                for (e.flags |= 128, Eu(s, !1), i = o.updateQueue, i !== null && (e.updateQueue = i, e.flags |= 4), e.subtreeFlags = 0, i = t, t = e.child; t !== null; )
                  s = t, n = i, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = n, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, n = o.dependencies, s.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }), t = t.sibling;
                return Gt(Jt, Jt.current & 1 | 2), e.child;
              }
              n = n.sibling;
            }
          s.tail !== null && dn() > zl && (e.flags |= 128, i = !0, Eu(s, !1), e.lanes = 4194304);
        }
      else {
        if (!i)
          if (n = Xd(o), n !== null) {
            if (e.flags |= 128, i = !0, t = n.updateQueue, t !== null && (e.updateQueue = t, e.flags |= 4), Eu(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !Zt)
              return Yn(e), null;
          } else
            2 * dn() - s.renderingStartTime > zl && t !== 1073741824 && (e.flags |= 128, i = !0, Eu(s, !1), e.lanes = 4194304);
        s.isBackwards ? (o.sibling = e.child, e.child = o) : (t = s.last, t !== null ? t.sibling = o : e.child = o, s.last = o);
      }
      return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = dn(), e.sibling = null, t = Jt.current, Gt(Jt, i ? t & 1 | 2 : t & 1), e) : (Yn(e), null);
    case 22:
    case 23:
      return Xy(), i = e.memoizedState !== null, n !== null && n.memoizedState !== null !== i && (e.flags |= 8192), i && e.mode & 1 ? Ii & 1073741824 && (Yn(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Yn(e), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(Ee(156, e.tag));
}
function cb(n, e) {
  switch (Ty(e), e.tag) {
    case 1:
      return xi(e.type) && Fd(), n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null;
    case 3:
      return kl(), Yt(_i), Yt($n), Dy(), n = e.flags, n & 65536 && !(n & 128) ? (e.flags = n & -65537 | 128, e) : null;
    case 5:
      return Ny(e), null;
    case 13:
      if (Yt(Jt), n = e.memoizedState, n !== null && n.dehydrated !== null) {
        if (e.alternate === null)
          throw Error(Ee(340));
        Ul();
      }
      return n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null;
    case 19:
      return Yt(Jt), null;
    case 4:
      return kl(), null;
    case 10:
      return Py(e.type._context), null;
    case 22:
    case 23:
      return Xy(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var ph = !1, Kn = !1, fb = typeof WeakSet == "function" ? WeakSet : Set, Ge = null;
function yl(n, e) {
  var t = n.ref;
  if (t !== null)
    if (typeof t == "function")
      try {
        t(null);
      } catch (i) {
        ln(n, e, i);
      }
    else
      t.current = null;
}
function nv(n, e, t) {
  try {
    t();
  } catch (i) {
    ln(n, e, i);
  }
}
var SS = !1;
function hb(n, e) {
  if (z0 = Dd, n = TE(), wy(n)) {
    if ("selectionStart" in n)
      var t = { start: n.selectionStart, end: n.selectionEnd };
    else
      e: {
        t = (t = n.ownerDocument) && t.defaultView || window;
        var i = t.getSelection && t.getSelection();
        if (i && i.rangeCount !== 0) {
          t = i.anchorNode;
          var r = i.anchorOffset, s = i.focusNode;
          i = i.focusOffset;
          try {
            t.nodeType, s.nodeType;
          } catch {
            t = null;
            break e;
          }
          var o = 0, l = -1, c = -1, f = 0, h = 0, d = n, m = null;
          t:
            for (; ; ) {
              for (var v; d !== t || r !== 0 && d.nodeType !== 3 || (l = o + r), d !== s || i !== 0 && d.nodeType !== 3 || (c = o + i), d.nodeType === 3 && (o += d.nodeValue.length), (v = d.firstChild) !== null; )
                m = d, d = v;
              for (; ; ) {
                if (d === n)
                  break t;
                if (m === t && ++f === r && (l = o), m === s && ++h === i && (c = o), (v = d.nextSibling) !== null)
                  break;
                d = m, m = d.parentNode;
              }
              d = v;
            }
          t = l === -1 || c === -1 ? null : { start: l, end: c };
        } else
          t = null;
      }
    t = t || { start: 0, end: 0 };
  } else
    t = null;
  for (B0 = { focusedElem: n, selectionRange: t }, Dd = !1, Ge = e; Ge !== null; )
    if (e = Ge, n = e.child, (e.subtreeFlags & 1028) !== 0 && n !== null)
      n.return = e, Ge = n;
    else
      for (; Ge !== null; ) {
        e = Ge;
        try {
          var _ = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (_ !== null) {
                  var w = _.memoizedProps, M = _.memoizedState, g = e.stateNode, x = g.getSnapshotBeforeUpdate(e.elementType === e.type ? w : fr(e.type, w), M);
                  g.__reactInternalSnapshotBeforeUpdate = x;
                }
                break;
              case 3:
                var S = e.stateNode.containerInfo;
                S.nodeType === 1 ? S.textContent = "" : S.nodeType === 9 && S.documentElement && S.removeChild(S.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(Ee(163));
            }
        } catch (T) {
          ln(e, e.return, T);
        }
        if (n = e.sibling, n !== null) {
          n.return = e.return, Ge = n;
          break;
        }
        Ge = e.return;
      }
  return _ = SS, SS = !1, _;
}
function Ku(n, e, t) {
  var i = e.updateQueue;
  if (i = i !== null ? i.lastEffect : null, i !== null) {
    var r = i = i.next;
    do {
      if ((r.tag & n) === n) {
        var s = r.destroy;
        r.destroy = void 0, s !== void 0 && nv(e, t, s);
      }
      r = r.next;
    } while (r !== i);
  }
}
function pp(n, e) {
  if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
    var t = e = e.next;
    do {
      if ((t.tag & n) === n) {
        var i = t.create;
        t.destroy = i();
      }
      t = t.next;
    } while (t !== e);
  }
}
function iv(n) {
  var e = n.ref;
  if (e !== null) {
    var t = n.stateNode;
    switch (n.tag) {
      case 5:
        n = t;
        break;
      default:
        n = t;
    }
    typeof e == "function" ? e(n) : e.current = n;
  }
}
function ST(n) {
  var e = n.alternate;
  e !== null && (n.alternate = null, ST(e)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (e = n.stateNode, e !== null && (delete e[Or], delete e[mc], delete e[G0], delete e[qP], delete e[ZP])), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null;
}
function MT(n) {
  return n.tag === 5 || n.tag === 3 || n.tag === 4;
}
function MS(n) {
  e:
    for (; ; ) {
      for (; n.sibling === null; ) {
        if (n.return === null || MT(n.return))
          return null;
        n = n.return;
      }
      for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
        if (n.flags & 2 || n.child === null || n.tag === 4)
          continue e;
        n.child.return = n, n = n.child;
      }
      if (!(n.flags & 2))
        return n.stateNode;
    }
}
function rv(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    n = n.stateNode, e ? t.nodeType === 8 ? t.parentNode.insertBefore(n, e) : t.insertBefore(n, e) : (t.nodeType === 8 ? (e = t.parentNode, e.insertBefore(n, t)) : (e = t, e.appendChild(n)), t = t._reactRootContainer, t != null || e.onclick !== null || (e.onclick = kd));
  else if (i !== 4 && (n = n.child, n !== null))
    for (rv(n, e, t), n = n.sibling; n !== null; )
      rv(n, e, t), n = n.sibling;
}
function sv(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    n = n.stateNode, e ? t.insertBefore(n, e) : t.appendChild(n);
  else if (i !== 4 && (n = n.child, n !== null))
    for (sv(n, e, t), n = n.sibling; n !== null; )
      sv(n, e, t), n = n.sibling;
}
var On = null, dr = !1;
function Os(n, e, t) {
  for (t = t.child; t !== null; )
    wT(n, e, t), t = t.sibling;
}
function wT(n, e, t) {
  if (zr && typeof zr.onCommitFiberUnmount == "function")
    try {
      zr.onCommitFiberUnmount(op, t);
    } catch {
    }
  switch (t.tag) {
    case 5:
      Kn || yl(t, e);
    case 6:
      var i = On, r = dr;
      On = null, Os(n, e, t), On = i, dr = r, On !== null && (dr ? (n = On, t = t.stateNode, n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t)) : On.removeChild(t.stateNode));
      break;
    case 18:
      On !== null && (dr ? (n = On, t = t.stateNode, n.nodeType === 8 ? xg(n.parentNode, t) : n.nodeType === 1 && xg(n, t), cc(n)) : xg(On, t.stateNode));
      break;
    case 4:
      i = On, r = dr, On = t.stateNode.containerInfo, dr = !0, Os(n, e, t), On = i, dr = r;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!Kn && (i = t.updateQueue, i !== null && (i = i.lastEffect, i !== null))) {
        r = i = i.next;
        do {
          var s = r, o = s.destroy;
          s = s.tag, o !== void 0 && (s & 2 || s & 4) && nv(t, e, o), r = r.next;
        } while (r !== i);
      }
      Os(n, e, t);
      break;
    case 1:
      if (!Kn && (yl(t, e), i = t.stateNode, typeof i.componentWillUnmount == "function"))
        try {
          i.props = t.memoizedProps, i.state = t.memoizedState, i.componentWillUnmount();
        } catch (l) {
          ln(t, e, l);
        }
      Os(n, e, t);
      break;
    case 21:
      Os(n, e, t);
      break;
    case 22:
      t.mode & 1 ? (Kn = (i = Kn) || t.memoizedState !== null, Os(n, e, t), Kn = i) : Os(n, e, t);
      break;
    default:
      Os(n, e, t);
  }
}
function wS(n) {
  var e = n.updateQueue;
  if (e !== null) {
    n.updateQueue = null;
    var t = n.stateNode;
    t === null && (t = n.stateNode = new fb()), e.forEach(function(i) {
      var r = Sb.bind(null, n, i);
      t.has(i) || (t.add(i), i.then(r, r));
    });
  }
}
function ar(n, e) {
  var t = e.deletions;
  if (t !== null)
    for (var i = 0; i < t.length; i++) {
      var r = t[i];
      try {
        var s = n, o = e, l = o;
        e:
          for (; l !== null; ) {
            switch (l.tag) {
              case 5:
                On = l.stateNode, dr = !1;
                break e;
              case 3:
                On = l.stateNode.containerInfo, dr = !0;
                break e;
              case 4:
                On = l.stateNode.containerInfo, dr = !0;
                break e;
            }
            l = l.return;
          }
        if (On === null)
          throw Error(Ee(160));
        wT(s, o, r), On = null, dr = !1;
        var c = r.alternate;
        c !== null && (c.return = null), r.return = null;
      } catch (f) {
        ln(r, e, f);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; )
      ET(e, n), e = e.sibling;
}
function ET(n, e) {
  var t = n.alternate, i = n.flags;
  switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (ar(e, n), Dr(n), i & 4) {
        try {
          Ku(3, n, n.return), pp(3, n);
        } catch (w) {
          ln(n, n.return, w);
        }
        try {
          Ku(5, n, n.return);
        } catch (w) {
          ln(n, n.return, w);
        }
      }
      break;
    case 1:
      ar(e, n), Dr(n), i & 512 && t !== null && yl(t, t.return);
      break;
    case 5:
      if (ar(e, n), Dr(n), i & 512 && t !== null && yl(t, t.return), n.flags & 32) {
        var r = n.stateNode;
        try {
          oc(r, "");
        } catch (w) {
          ln(n, n.return, w);
        }
      }
      if (i & 4 && (r = n.stateNode, r != null)) {
        var s = n.memoizedProps, o = t !== null ? t.memoizedProps : s, l = n.type, c = n.updateQueue;
        if (n.updateQueue = null, c !== null)
          try {
            l === "input" && s.type === "radio" && s.name != null && jw(r, s), P0(l, o);
            var f = P0(l, s);
            for (o = 0; o < c.length; o += 2) {
              var h = c[o], d = c[o + 1];
              h === "style" ? Jw(r, d) : h === "dangerouslySetInnerHTML" ? Zw(r, d) : h === "children" ? oc(r, d) : cy(r, h, d, f);
            }
            switch (l) {
              case "input":
                E0(r, s);
                break;
              case "textarea":
                Yw(r, s);
                break;
              case "select":
                var m = r._wrapperState.wasMultiple;
                r._wrapperState.wasMultiple = !!s.multiple;
                var v = s.value;
                v != null ? Tl(r, !!s.multiple, v, !1) : m !== !!s.multiple && (s.defaultValue != null ? Tl(
                  r,
                  !!s.multiple,
                  s.defaultValue,
                  !0
                ) : Tl(r, !!s.multiple, s.multiple ? [] : "", !1));
            }
            r[mc] = s;
          } catch (w) {
            ln(n, n.return, w);
          }
      }
      break;
    case 6:
      if (ar(e, n), Dr(n), i & 4) {
        if (n.stateNode === null)
          throw Error(Ee(162));
        r = n.stateNode, s = n.memoizedProps;
        try {
          r.nodeValue = s;
        } catch (w) {
          ln(n, n.return, w);
        }
      }
      break;
    case 3:
      if (ar(e, n), Dr(n), i & 4 && t !== null && t.memoizedState.isDehydrated)
        try {
          cc(e.containerInfo);
        } catch (w) {
          ln(n, n.return, w);
        }
      break;
    case 4:
      ar(e, n), Dr(n);
      break;
    case 13:
      ar(e, n), Dr(n), r = n.child, r.flags & 8192 && (s = r.memoizedState !== null, r.stateNode.isHidden = s, !s || r.alternate !== null && r.alternate.memoizedState !== null || (Gy = dn())), i & 4 && wS(n);
      break;
    case 22:
      if (h = t !== null && t.memoizedState !== null, n.mode & 1 ? (Kn = (f = Kn) || h, ar(e, n), Kn = f) : ar(e, n), Dr(n), i & 8192) {
        if (f = n.memoizedState !== null, (n.stateNode.isHidden = f) && !h && n.mode & 1)
          for (Ge = n, h = n.child; h !== null; ) {
            for (d = Ge = h; Ge !== null; ) {
              switch (m = Ge, v = m.child, m.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Ku(4, m, m.return);
                  break;
                case 1:
                  yl(m, m.return);
                  var _ = m.stateNode;
                  if (typeof _.componentWillUnmount == "function") {
                    i = m, t = m.return;
                    try {
                      e = i, _.props = e.memoizedProps, _.state = e.memoizedState, _.componentWillUnmount();
                    } catch (w) {
                      ln(i, t, w);
                    }
                  }
                  break;
                case 5:
                  yl(m, m.return);
                  break;
                case 22:
                  if (m.memoizedState !== null) {
                    TS(d);
                    continue;
                  }
              }
              v !== null ? (v.return = m, Ge = v) : TS(d);
            }
            h = h.sibling;
          }
        e:
          for (h = null, d = n; ; ) {
            if (d.tag === 5) {
              if (h === null) {
                h = d;
                try {
                  r = d.stateNode, f ? (s = r.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (l = d.stateNode, c = d.memoizedProps.style, o = c != null && c.hasOwnProperty("display") ? c.display : null, l.style.display = Kw("display", o));
                } catch (w) {
                  ln(n, n.return, w);
                }
              }
            } else if (d.tag === 6) {
              if (h === null)
                try {
                  d.stateNode.nodeValue = f ? "" : d.memoizedProps;
                } catch (w) {
                  ln(n, n.return, w);
                }
            } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === n) && d.child !== null) {
              d.child.return = d, d = d.child;
              continue;
            }
            if (d === n)
              break e;
            for (; d.sibling === null; ) {
              if (d.return === null || d.return === n)
                break e;
              h === d && (h = null), d = d.return;
            }
            h === d && (h = null), d.sibling.return = d.return, d = d.sibling;
          }
      }
      break;
    case 19:
      ar(e, n), Dr(n), i & 4 && wS(n);
      break;
    case 21:
      break;
    default:
      ar(
        e,
        n
      ), Dr(n);
  }
}
function Dr(n) {
  var e = n.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n.return; t !== null; ) {
          if (MT(t)) {
            var i = t;
            break e;
          }
          t = t.return;
        }
        throw Error(Ee(160));
      }
      switch (i.tag) {
        case 5:
          var r = i.stateNode;
          i.flags & 32 && (oc(r, ""), i.flags &= -33);
          var s = MS(n);
          sv(n, s, r);
          break;
        case 3:
        case 4:
          var o = i.stateNode.containerInfo, l = MS(n);
          rv(n, l, o);
          break;
        default:
          throw Error(Ee(161));
      }
    } catch (c) {
      ln(n, n.return, c);
    }
    n.flags &= -3;
  }
  e & 4096 && (n.flags &= -4097);
}
function db(n, e, t) {
  Ge = n, TT(n);
}
function TT(n, e, t) {
  for (var i = (n.mode & 1) !== 0; Ge !== null; ) {
    var r = Ge, s = r.child;
    if (r.tag === 22 && i) {
      var o = r.memoizedState !== null || ph;
      if (!o) {
        var l = r.alternate, c = l !== null && l.memoizedState !== null || Kn;
        l = ph;
        var f = Kn;
        if (ph = o, (Kn = c) && !f)
          for (Ge = r; Ge !== null; )
            o = Ge, c = o.child, o.tag === 22 && o.memoizedState !== null ? AS(r) : c !== null ? (c.return = o, Ge = c) : AS(r);
        for (; s !== null; )
          Ge = s, TT(s), s = s.sibling;
        Ge = r, ph = l, Kn = f;
      }
      ES(n);
    } else
      r.subtreeFlags & 8772 && s !== null ? (s.return = r, Ge = s) : ES(n);
  }
}
function ES(n) {
  for (; Ge !== null; ) {
    var e = Ge;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              Kn || pp(5, e);
              break;
            case 1:
              var i = e.stateNode;
              if (e.flags & 4 && !Kn)
                if (t === null)
                  i.componentDidMount();
                else {
                  var r = e.elementType === e.type ? t.memoizedProps : fr(e.type, t.memoizedProps);
                  i.componentDidUpdate(r, t.memoizedState, i.__reactInternalSnapshotBeforeUpdate);
                }
              var s = e.updateQueue;
              s !== null && lS(e, s, i);
              break;
            case 3:
              var o = e.updateQueue;
              if (o !== null) {
                if (t = null, e.child !== null)
                  switch (e.child.tag) {
                    case 5:
                      t = e.child.stateNode;
                      break;
                    case 1:
                      t = e.child.stateNode;
                  }
                lS(e, o, t);
              }
              break;
            case 5:
              var l = e.stateNode;
              if (t === null && e.flags & 4) {
                t = l;
                var c = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    c.autoFocus && t.focus();
                    break;
                  case "img":
                    c.src && (t.src = c.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var f = e.alternate;
                if (f !== null) {
                  var h = f.memoizedState;
                  if (h !== null) {
                    var d = h.dehydrated;
                    d !== null && cc(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(Ee(163));
          }
        Kn || e.flags & 512 && iv(e);
      } catch (m) {
        ln(e, e.return, m);
      }
    }
    if (e === n) {
      Ge = null;
      break;
    }
    if (t = e.sibling, t !== null) {
      t.return = e.return, Ge = t;
      break;
    }
    Ge = e.return;
  }
}
function TS(n) {
  for (; Ge !== null; ) {
    var e = Ge;
    if (e === n) {
      Ge = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      t.return = e.return, Ge = t;
      break;
    }
    Ge = e.return;
  }
}
function AS(n) {
  for (; Ge !== null; ) {
    var e = Ge;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            pp(4, e);
          } catch (c) {
            ln(e, t, c);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var r = e.return;
            try {
              i.componentDidMount();
            } catch (c) {
              ln(e, r, c);
            }
          }
          var s = e.return;
          try {
            iv(e);
          } catch (c) {
            ln(e, s, c);
          }
          break;
        case 5:
          var o = e.return;
          try {
            iv(e);
          } catch (c) {
            ln(e, o, c);
          }
      }
    } catch (c) {
      ln(e, e.return, c);
    }
    if (e === n) {
      Ge = null;
      break;
    }
    var l = e.sibling;
    if (l !== null) {
      l.return = e.return, Ge = l;
      break;
    }
    Ge = e.return;
  }
}
var pb = Math.ceil, qd = Es.ReactCurrentDispatcher, Hy = Es.ReactCurrentOwner, er = Es.ReactCurrentBatchConfig, Rt = 0, Dn = null, xn = null, Fn = 0, Ii = 0, _l = po(0), An = 0, Sc = null, aa = 0, mp = 0, Vy = 0, Ju = null, mi = null, Gy = 0, zl = 1 / 0, us = null, Zd = !1, ov = null, $s = null, mh = !1, Ys = null, Kd = 0, Qu = 0, av = null, vd = -1, yd = 0;
function oi() {
  return Rt & 6 ? dn() : vd !== -1 ? vd : vd = dn();
}
function eo(n) {
  return n.mode & 1 ? Rt & 2 && Fn !== 0 ? Fn & -Fn : JP.transition !== null ? (yd === 0 && (yd = uE()), yd) : (n = Ft, n !== 0 || (n = window.event, n = n === void 0 ? 16 : gE(n.type)), n) : 1;
}
function yr(n, e, t, i) {
  if (50 < Qu)
    throw Qu = 0, av = null, Error(Ee(185));
  Hc(n, t, i), (!(Rt & 2) || n !== Dn) && (n === Dn && (!(Rt & 2) && (mp |= t), An === 4 && Xs(n, Fn)), Si(n, i), t === 1 && Rt === 0 && !(e.mode & 1) && (zl = dn() + 500, fp && mo()));
}
function Si(n, e) {
  var t = n.callbackNode;
  JR(n, e);
  var i = Nd(n, n === Dn ? Fn : 0);
  if (i === 0)
    t !== null && U1(t), n.callbackNode = null, n.callbackPriority = 0;
  else if (e = i & -i, n.callbackPriority !== e) {
    if (t != null && U1(t), e === 1)
      n.tag === 0 ? KP(CS.bind(null, n)) : UE(CS.bind(null, n)), jP(function() {
        !(Rt & 6) && mo();
      }), t = null;
    else {
      switch (cE(i)) {
        case 1:
          t = my;
          break;
        case 4:
          t = aE;
          break;
        case 16:
          t = Id;
          break;
        case 536870912:
          t = lE;
          break;
        default:
          t = Id;
      }
      t = NT(t, AT.bind(null, n));
    }
    n.callbackPriority = e, n.callbackNode = t;
  }
}
function AT(n, e) {
  if (vd = -1, yd = 0, Rt & 6)
    throw Error(Ee(327));
  var t = n.callbackNode;
  if (bl() && n.callbackNode !== t)
    return null;
  var i = Nd(n, n === Dn ? Fn : 0);
  if (i === 0)
    return null;
  if (i & 30 || i & n.expiredLanes || e)
    e = Jd(n, i);
  else {
    e = i;
    var r = Rt;
    Rt |= 2;
    var s = RT();
    (Dn !== n || Fn !== e) && (us = null, zl = dn() + 500, Qo(n, e));
    do
      try {
        vb();
        break;
      } catch (l) {
        CT(n, l);
      }
    while (1);
    Ry(), qd.current = s, Rt = r, xn !== null ? e = 0 : (Dn = null, Fn = 0, e = An);
  }
  if (e !== 0) {
    if (e === 2 && (r = D0(n), r !== 0 && (i = r, e = lv(n, r))), e === 1)
      throw t = Sc, Qo(n, 0), Xs(n, i), Si(n, dn()), t;
    if (e === 6)
      Xs(n, i);
    else {
      if (r = n.current.alternate, !(i & 30) && !mb(r) && (e = Jd(n, i), e === 2 && (s = D0(n), s !== 0 && (i = s, e = lv(n, s))), e === 1))
        throw t = Sc, Qo(n, 0), Xs(n, i), Si(n, dn()), t;
      switch (n.finishedWork = r, n.finishedLanes = i, e) {
        case 0:
        case 1:
          throw Error(Ee(345));
        case 2:
          zo(n, mi, us);
          break;
        case 3:
          if (Xs(n, i), (i & 130023424) === i && (e = Gy + 500 - dn(), 10 < e)) {
            if (Nd(n, 0) !== 0)
              break;
            if (r = n.suspendedLanes, (r & i) !== i) {
              oi(), n.pingedLanes |= n.suspendedLanes & r;
              break;
            }
            n.timeoutHandle = V0(zo.bind(null, n, mi, us), e);
            break;
          }
          zo(n, mi, us);
          break;
        case 4:
          if (Xs(n, i), (i & 4194240) === i)
            break;
          for (e = n.eventTimes, r = -1; 0 < i; ) {
            var o = 31 - vr(i);
            s = 1 << o, o = e[o], o > r && (r = o), i &= ~s;
          }
          if (i = r, i = dn() - i, i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * pb(i / 1960)) - i, 10 < i) {
            n.timeoutHandle = V0(zo.bind(null, n, mi, us), i);
            break;
          }
          zo(n, mi, us);
          break;
        case 5:
          zo(n, mi, us);
          break;
        default:
          throw Error(Ee(329));
      }
    }
  }
  return Si(n, dn()), n.callbackNode === t ? AT.bind(null, n) : null;
}
function lv(n, e) {
  var t = Ju;
  return n.current.memoizedState.isDehydrated && (Qo(n, e).flags |= 256), n = Jd(n, e), n !== 2 && (e = mi, mi = t, e !== null && uv(e)), n;
}
function uv(n) {
  mi === null ? mi = n : mi.push.apply(mi, n);
}
function mb(n) {
  for (var e = n; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && (t = t.stores, t !== null))
        for (var i = 0; i < t.length; i++) {
          var r = t[i], s = r.getSnapshot;
          r = r.value;
          try {
            if (!xr(s(), r))
              return !1;
          } catch {
            return !1;
          }
        }
    }
    if (t = e.child, e.subtreeFlags & 16384 && t !== null)
      t.return = e, e = t;
    else {
      if (e === n)
        break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n)
          return !0;
        e = e.return;
      }
      e.sibling.return = e.return, e = e.sibling;
    }
  }
  return !0;
}
function Xs(n, e) {
  for (e &= ~Vy, e &= ~mp, n.suspendedLanes |= e, n.pingedLanes &= ~e, n = n.expirationTimes; 0 < e; ) {
    var t = 31 - vr(e), i = 1 << t;
    n[t] = -1, e &= ~i;
  }
}
function CS(n) {
  if (Rt & 6)
    throw Error(Ee(327));
  bl();
  var e = Nd(n, 0);
  if (!(e & 1))
    return Si(n, dn()), null;
  var t = Jd(n, e);
  if (n.tag !== 0 && t === 2) {
    var i = D0(n);
    i !== 0 && (e = i, t = lv(n, i));
  }
  if (t === 1)
    throw t = Sc, Qo(n, 0), Xs(n, e), Si(n, dn()), t;
  if (t === 6)
    throw Error(Ee(345));
  return n.finishedWork = n.current.alternate, n.finishedLanes = e, zo(n, mi, us), Si(n, dn()), null;
}
function Wy(n, e) {
  var t = Rt;
  Rt |= 1;
  try {
    return n(e);
  } finally {
    Rt = t, Rt === 0 && (zl = dn() + 500, fp && mo());
  }
}
function la(n) {
  Ys !== null && Ys.tag === 0 && !(Rt & 6) && bl();
  var e = Rt;
  Rt |= 1;
  var t = er.transition, i = Ft;
  try {
    if (er.transition = null, Ft = 1, n)
      return n();
  } finally {
    Ft = i, er.transition = t, Rt = e, !(Rt & 6) && mo();
  }
}
function Xy() {
  Ii = _l.current, Yt(_l);
}
function Qo(n, e) {
  n.finishedWork = null, n.finishedLanes = 0;
  var t = n.timeoutHandle;
  if (t !== -1 && (n.timeoutHandle = -1, XP(t)), xn !== null)
    for (t = xn.return; t !== null; ) {
      var i = t;
      switch (Ty(i), i.tag) {
        case 1:
          i = i.type.childContextTypes, i != null && Fd();
          break;
        case 3:
          kl(), Yt(_i), Yt($n), Dy();
          break;
        case 5:
          Ny(i);
          break;
        case 4:
          kl();
          break;
        case 13:
          Yt(Jt);
          break;
        case 19:
          Yt(Jt);
          break;
        case 10:
          Py(i.type._context);
          break;
        case 22:
        case 23:
          Xy();
      }
      t = t.return;
    }
  if (Dn = n, xn = n = to(n.current, null), Fn = Ii = e, An = 0, Sc = null, Vy = mp = aa = 0, mi = Ju = null, jo !== null) {
    for (e = 0; e < jo.length; e++)
      if (t = jo[e], i = t.interleaved, i !== null) {
        t.interleaved = null;
        var r = i.next, s = t.pending;
        if (s !== null) {
          var o = s.next;
          s.next = r, i.next = o;
        }
        t.pending = i;
      }
    jo = null;
  }
  return n;
}
function CT(n, e) {
  do {
    var t = xn;
    try {
      if (Ry(), pd.current = Yd, jd) {
        for (var i = en.memoizedState; i !== null; ) {
          var r = i.queue;
          r !== null && (r.pending = null), i = i.next;
        }
        jd = !1;
      }
      if (oa = 0, Nn = Tn = en = null, Zu = !1, yc = 0, Hy.current = null, t === null || t.return === null) {
        An = 1, Sc = e, xn = null;
        break;
      }
      e: {
        var s = n, o = t.return, l = t, c = e;
        if (e = Fn, l.flags |= 32768, c !== null && typeof c == "object" && typeof c.then == "function") {
          var f = c, h = l, d = h.tag;
          if (!(h.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var m = h.alternate;
            m ? (h.updateQueue = m.updateQueue, h.memoizedState = m.memoizedState, h.lanes = m.lanes) : (h.updateQueue = null, h.memoizedState = null);
          }
          var v = pS(o);
          if (v !== null) {
            v.flags &= -257, mS(v, o, l, s, e), v.mode & 1 && dS(s, f, e), e = v, c = f;
            var _ = e.updateQueue;
            if (_ === null) {
              var w = /* @__PURE__ */ new Set();
              w.add(c), e.updateQueue = w;
            } else
              _.add(c);
            break e;
          } else {
            if (!(e & 1)) {
              dS(s, f, e), jy();
              break e;
            }
            c = Error(Ee(426));
          }
        } else if (Zt && l.mode & 1) {
          var M = pS(o);
          if (M !== null) {
            !(M.flags & 65536) && (M.flags |= 256), mS(M, o, l, s, e), Ay(Fl(c, l));
            break e;
          }
        }
        s = c = Fl(c, l), An !== 4 && (An = 2), Ju === null ? Ju = [s] : Ju.push(s), s = o;
        do {
          switch (s.tag) {
            case 3:
              s.flags |= 65536, e &= -e, s.lanes |= e;
              var g = cT(s, c, e);
              aS(s, g);
              break e;
            case 1:
              l = c;
              var x = s.type, S = s.stateNode;
              if (!(s.flags & 128) && (typeof x.getDerivedStateFromError == "function" || S !== null && typeof S.componentDidCatch == "function" && ($s === null || !$s.has(S)))) {
                s.flags |= 65536, e &= -e, s.lanes |= e;
                var T = fT(s, l, e);
                aS(s, T);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      bT(t);
    } catch (C) {
      e = C, xn === t && t !== null && (xn = t = t.return);
      continue;
    }
    break;
  } while (1);
}
function RT() {
  var n = qd.current;
  return qd.current = Yd, n === null ? Yd : n;
}
function jy() {
  (An === 0 || An === 3 || An === 2) && (An = 4), Dn === null || !(aa & 268435455) && !(mp & 268435455) || Xs(Dn, Fn);
}
function Jd(n, e) {
  var t = Rt;
  Rt |= 2;
  var i = RT();
  (Dn !== n || Fn !== e) && (us = null, Qo(n, e));
  do
    try {
      gb();
      break;
    } catch (r) {
      CT(n, r);
    }
  while (1);
  if (Ry(), Rt = t, qd.current = i, xn !== null)
    throw Error(Ee(261));
  return Dn = null, Fn = 0, An;
}
function gb() {
  for (; xn !== null; )
    PT(xn);
}
function vb() {
  for (; xn !== null && !VR(); )
    PT(xn);
}
function PT(n) {
  var e = IT(n.alternate, n, Ii);
  n.memoizedProps = n.pendingProps, e === null ? bT(n) : xn = e, Hy.current = null;
}
function bT(n) {
  var e = n;
  do {
    var t = e.alternate;
    if (n = e.return, e.flags & 32768) {
      if (t = cb(t, e), t !== null) {
        t.flags &= 32767, xn = t;
        return;
      }
      if (n !== null)
        n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null;
      else {
        An = 6, xn = null;
        return;
      }
    } else if (t = ub(t, e, Ii), t !== null) {
      xn = t;
      return;
    }
    if (e = e.sibling, e !== null) {
      xn = e;
      return;
    }
    xn = e = n;
  } while (e !== null);
  An === 0 && (An = 5);
}
function zo(n, e, t) {
  var i = Ft, r = er.transition;
  try {
    er.transition = null, Ft = 1, yb(n, e, t, i);
  } finally {
    er.transition = r, Ft = i;
  }
  return null;
}
function yb(n, e, t, i) {
  do
    bl();
  while (Ys !== null);
  if (Rt & 6)
    throw Error(Ee(327));
  t = n.finishedWork;
  var r = n.finishedLanes;
  if (t === null)
    return null;
  if (n.finishedWork = null, n.finishedLanes = 0, t === n.current)
    throw Error(Ee(177));
  n.callbackNode = null, n.callbackPriority = 0;
  var s = t.lanes | t.childLanes;
  if (QR(n, s), n === Dn && (xn = Dn = null, Fn = 0), !(t.subtreeFlags & 2064) && !(t.flags & 2064) || mh || (mh = !0, NT(Id, function() {
    return bl(), null;
  })), s = (t.flags & 15990) !== 0, t.subtreeFlags & 15990 || s) {
    s = er.transition, er.transition = null;
    var o = Ft;
    Ft = 1;
    var l = Rt;
    Rt |= 4, Hy.current = null, hb(n, t), ET(t, n), FP(B0), Dd = !!z0, B0 = z0 = null, n.current = t, db(t), GR(), Rt = l, Ft = o, er.transition = s;
  } else
    n.current = t;
  if (mh && (mh = !1, Ys = n, Kd = r), s = n.pendingLanes, s === 0 && ($s = null), jR(t.stateNode), Si(n, dn()), e !== null)
    for (i = n.onRecoverableError, t = 0; t < e.length; t++)
      r = e[t], i(r.value, { componentStack: r.stack, digest: r.digest });
  if (Zd)
    throw Zd = !1, n = ov, ov = null, n;
  return Kd & 1 && n.tag !== 0 && bl(), s = n.pendingLanes, s & 1 ? n === av ? Qu++ : (Qu = 0, av = n) : Qu = 0, mo(), null;
}
function bl() {
  if (Ys !== null) {
    var n = cE(Kd), e = er.transition, t = Ft;
    try {
      if (er.transition = null, Ft = 16 > n ? 16 : n, Ys === null)
        var i = !1;
      else {
        if (n = Ys, Ys = null, Kd = 0, Rt & 6)
          throw Error(Ee(331));
        var r = Rt;
        for (Rt |= 4, Ge = n.current; Ge !== null; ) {
          var s = Ge, o = s.child;
          if (Ge.flags & 16) {
            var l = s.deletions;
            if (l !== null) {
              for (var c = 0; c < l.length; c++) {
                var f = l[c];
                for (Ge = f; Ge !== null; ) {
                  var h = Ge;
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ku(8, h, s);
                  }
                  var d = h.child;
                  if (d !== null)
                    d.return = h, Ge = d;
                  else
                    for (; Ge !== null; ) {
                      h = Ge;
                      var m = h.sibling, v = h.return;
                      if (ST(h), h === f) {
                        Ge = null;
                        break;
                      }
                      if (m !== null) {
                        m.return = v, Ge = m;
                        break;
                      }
                      Ge = v;
                    }
                }
              }
              var _ = s.alternate;
              if (_ !== null) {
                var w = _.child;
                if (w !== null) {
                  _.child = null;
                  do {
                    var M = w.sibling;
                    w.sibling = null, w = M;
                  } while (w !== null);
                }
              }
              Ge = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null)
            o.return = s, Ge = o;
          else
            e:
              for (; Ge !== null; ) {
                if (s = Ge, s.flags & 2048)
                  switch (s.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ku(9, s, s.return);
                  }
                var g = s.sibling;
                if (g !== null) {
                  g.return = s.return, Ge = g;
                  break e;
                }
                Ge = s.return;
              }
        }
        var x = n.current;
        for (Ge = x; Ge !== null; ) {
          o = Ge;
          var S = o.child;
          if (o.subtreeFlags & 2064 && S !== null)
            S.return = o, Ge = S;
          else
            e:
              for (o = x; Ge !== null; ) {
                if (l = Ge, l.flags & 2048)
                  try {
                    switch (l.tag) {
                      case 0:
                      case 11:
                      case 15:
                        pp(9, l);
                    }
                  } catch (C) {
                    ln(l, l.return, C);
                  }
                if (l === o) {
                  Ge = null;
                  break e;
                }
                var T = l.sibling;
                if (T !== null) {
                  T.return = l.return, Ge = T;
                  break e;
                }
                Ge = l.return;
              }
        }
        if (Rt = r, mo(), zr && typeof zr.onPostCommitFiberRoot == "function")
          try {
            zr.onPostCommitFiberRoot(op, n);
          } catch {
          }
        i = !0;
      }
      return i;
    } finally {
      Ft = t, er.transition = e;
    }
  }
  return !1;
}
function RS(n, e, t) {
  e = Fl(t, e), e = cT(n, e, 1), n = Qs(n, e, 1), e = oi(), n !== null && (Hc(n, 1, e), Si(n, e));
}
function ln(n, e, t) {
  if (n.tag === 3)
    RS(n, n, t);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        RS(e, n, t);
        break;
      } else if (e.tag === 1) {
        var i = e.stateNode;
        if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && ($s === null || !$s.has(i))) {
          n = Fl(t, n), n = fT(e, n, 1), e = Qs(e, n, 1), n = oi(), e !== null && (Hc(e, 1, n), Si(e, n));
          break;
        }
      }
      e = e.return;
    }
}
function _b(n, e, t) {
  var i = n.pingCache;
  i !== null && i.delete(e), e = oi(), n.pingedLanes |= n.suspendedLanes & t, Dn === n && (Fn & t) === t && (An === 4 || An === 3 && (Fn & 130023424) === Fn && 500 > dn() - Gy ? Qo(n, 0) : Vy |= t), Si(n, e);
}
function LT(n, e) {
  e === 0 && (n.mode & 1 ? (e = sh, sh <<= 1, !(sh & 130023424) && (sh = 4194304)) : e = 1);
  var t = oi();
  n = xs(n, e), n !== null && (Hc(n, e, t), Si(n, t));
}
function xb(n) {
  var e = n.memoizedState, t = 0;
  e !== null && (t = e.retryLane), LT(n, t);
}
function Sb(n, e) {
  var t = 0;
  switch (n.tag) {
    case 13:
      var i = n.stateNode, r = n.memoizedState;
      r !== null && (t = r.retryLane);
      break;
    case 19:
      i = n.stateNode;
      break;
    default:
      throw Error(Ee(314));
  }
  i !== null && i.delete(e), LT(n, t);
}
var IT;
IT = function(n, e, t) {
  if (n !== null)
    if (n.memoizedProps !== e.pendingProps || _i.current)
      yi = !0;
    else {
      if (!(n.lanes & t) && !(e.flags & 128))
        return yi = !1, lb(n, e, t);
      yi = !!(n.flags & 131072);
    }
  else
    yi = !1, Zt && e.flags & 1048576 && OE(e, Hd, e.index);
  switch (e.lanes = 0, e.tag) {
    case 2:
      var i = e.type;
      gd(n, e), n = e.pendingProps;
      var r = Dl(e, $n.current);
      Pl(e, t), r = Oy(null, e, i, n, r, t);
      var s = ky();
      return e.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, xi(i) ? (s = !0, zd(e)) : s = !1, e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, Ly(e), r.updater = dp, e.stateNode = r, r._reactInternals = e, Z0(e, i, n, t), e = Q0(null, e, i, !0, s, t)) : (e.tag = 0, Zt && s && Ey(e), si(null, e, r, t), e = e.child), e;
    case 16:
      i = e.elementType;
      e: {
        switch (gd(n, e), n = e.pendingProps, r = i._init, i = r(i._payload), e.type = i, r = e.tag = wb(i), n = fr(i, n), r) {
          case 0:
            e = J0(null, e, i, n, t);
            break e;
          case 1:
            e = yS(null, e, i, n, t);
            break e;
          case 11:
            e = gS(null, e, i, n, t);
            break e;
          case 14:
            e = vS(null, e, i, fr(i.type, n), t);
            break e;
        }
        throw Error(Ee(
          306,
          i,
          ""
        ));
      }
      return e;
    case 0:
      return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : fr(i, r), J0(n, e, i, r, t);
    case 1:
      return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : fr(i, r), yS(n, e, i, r, t);
    case 3:
      e: {
        if (mT(e), n === null)
          throw Error(Ee(387));
        i = e.pendingProps, s = e.memoizedState, r = s.element, VE(n, e), Wd(e, i, null, t);
        var o = e.memoizedState;
        if (i = o.element, s.isDehydrated)
          if (s = { element: i, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) {
            r = Fl(Error(Ee(423)), e), e = _S(n, e, i, t, r);
            break e;
          } else if (i !== r) {
            r = Fl(Error(Ee(424)), e), e = _S(n, e, i, t, r);
            break e;
          } else
            for (Ni = Js(e.stateNode.containerInfo.firstChild), Ui = e, Zt = !0, pr = null, t = BE(e, null, i, t), e.child = t; t; )
              t.flags = t.flags & -3 | 4096, t = t.sibling;
        else {
          if (Ul(), i === r) {
            e = Ss(n, e, t);
            break e;
          }
          si(n, e, i, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return GE(e), n === null && j0(e), i = e.type, r = e.pendingProps, s = n !== null ? n.memoizedProps : null, o = r.children, H0(i, r) ? o = null : s !== null && H0(i, s) && (e.flags |= 32), pT(n, e), si(n, e, o, t), e.child;
    case 6:
      return n === null && j0(e), null;
    case 13:
      return gT(n, e, t);
    case 4:
      return Iy(e, e.stateNode.containerInfo), i = e.pendingProps, n === null ? e.child = Ol(e, null, i, t) : si(n, e, i, t), e.child;
    case 11:
      return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : fr(i, r), gS(n, e, i, r, t);
    case 7:
      return si(n, e, e.pendingProps, t), e.child;
    case 8:
      return si(n, e, e.pendingProps.children, t), e.child;
    case 12:
      return si(n, e, e.pendingProps.children, t), e.child;
    case 10:
      e: {
        if (i = e.type._context, r = e.pendingProps, s = e.memoizedProps, o = r.value, Gt(Vd, i._currentValue), i._currentValue = o, s !== null)
          if (xr(s.value, o)) {
            if (s.children === r.children && !_i.current) {
              e = Ss(n, e, t);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var l = s.dependencies;
              if (l !== null) {
                o = s.child;
                for (var c = l.firstContext; c !== null; ) {
                  if (c.context === i) {
                    if (s.tag === 1) {
                      c = gs(-1, t & -t), c.tag = 2;
                      var f = s.updateQueue;
                      if (f !== null) {
                        f = f.shared;
                        var h = f.pending;
                        h === null ? c.next = c : (c.next = h.next, h.next = c), f.pending = c;
                      }
                    }
                    s.lanes |= t, c = s.alternate, c !== null && (c.lanes |= t), Y0(
                      s.return,
                      t,
                      e
                    ), l.lanes |= t;
                    break;
                  }
                  c = c.next;
                }
              } else if (s.tag === 10)
                o = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (o = s.return, o === null)
                  throw Error(Ee(341));
                o.lanes |= t, l = o.alternate, l !== null && (l.lanes |= t), Y0(o, t, e), o = s.sibling;
              } else
                o = s.child;
              if (o !== null)
                o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === e) {
                    o = null;
                    break;
                  }
                  if (s = o.sibling, s !== null) {
                    s.return = o.return, o = s;
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        si(n, e, r.children, t), e = e.child;
      }
      return e;
    case 9:
      return r = e.type, i = e.pendingProps.children, Pl(e, t), r = tr(r), i = i(r), e.flags |= 1, si(n, e, i, t), e.child;
    case 14:
      return i = e.type, r = fr(i, e.pendingProps), r = fr(i.type, r), vS(n, e, i, r, t);
    case 15:
      return hT(n, e, e.type, e.pendingProps, t);
    case 17:
      return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : fr(i, r), gd(n, e), e.tag = 1, xi(i) ? (n = !0, zd(e)) : n = !1, Pl(e, t), uT(e, i, r), Z0(e, i, r, t), Q0(null, e, i, !0, n, t);
    case 19:
      return vT(n, e, t);
    case 22:
      return dT(n, e, t);
  }
  throw Error(Ee(156, e.tag));
};
function NT(n, e) {
  return oE(n, e);
}
function Mb(n, e, t, i) {
  this.tag = n, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
}
function $i(n, e, t, i) {
  return new Mb(n, e, t, i);
}
function Yy(n) {
  return n = n.prototype, !(!n || !n.isReactComponent);
}
function wb(n) {
  if (typeof n == "function")
    return Yy(n) ? 1 : 0;
  if (n != null) {
    if (n = n.$$typeof, n === hy)
      return 11;
    if (n === dy)
      return 14;
  }
  return 2;
}
function to(n, e) {
  var t = n.alternate;
  return t === null ? (t = $i(n.tag, e, n.key, n.mode), t.elementType = n.elementType, t.type = n.type, t.stateNode = n.stateNode, t.alternate = n, n.alternate = t) : (t.pendingProps = e, t.type = n.type, t.flags = 0, t.subtreeFlags = 0, t.deletions = null), t.flags = n.flags & 14680064, t.childLanes = n.childLanes, t.lanes = n.lanes, t.child = n.child, t.memoizedProps = n.memoizedProps, t.memoizedState = n.memoizedState, t.updateQueue = n.updateQueue, e = n.dependencies, t.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, t.sibling = n.sibling, t.index = n.index, t.ref = n.ref, t;
}
function _d(n, e, t, i, r, s) {
  var o = 2;
  if (i = n, typeof n == "function")
    Yy(n) && (o = 1);
  else if (typeof n == "string")
    o = 5;
  else
    e:
      switch (n) {
        case ul:
          return $o(t.children, r, s, e);
        case fy:
          o = 8, r |= 8;
          break;
        case _0:
          return n = $i(12, t, e, r | 2), n.elementType = _0, n.lanes = s, n;
        case x0:
          return n = $i(13, t, e, r), n.elementType = x0, n.lanes = s, n;
        case S0:
          return n = $i(19, t, e, r), n.elementType = S0, n.lanes = s, n;
        case Gw:
          return gp(t, r, s, e);
        default:
          if (typeof n == "object" && n !== null)
            switch (n.$$typeof) {
              case Hw:
                o = 10;
                break e;
              case Vw:
                o = 9;
                break e;
              case hy:
                o = 11;
                break e;
              case dy:
                o = 14;
                break e;
              case Vs:
                o = 16, i = null;
                break e;
            }
          throw Error(Ee(130, n == null ? n : typeof n, ""));
      }
  return e = $i(o, t, e, r), e.elementType = n, e.type = i, e.lanes = s, e;
}
function $o(n, e, t, i) {
  return n = $i(7, n, i, e), n.lanes = t, n;
}
function gp(n, e, t, i) {
  return n = $i(22, n, i, e), n.elementType = Gw, n.lanes = t, n.stateNode = { isHidden: !1 }, n;
}
function Rg(n, e, t) {
  return n = $i(6, n, null, e), n.lanes = t, n;
}
function Pg(n, e, t) {
  return e = $i(4, n.children !== null ? n.children : [], n.key, e), e.lanes = t, e.stateNode = { containerInfo: n.containerInfo, pendingChildren: null, implementation: n.implementation }, e;
}
function Eb(n, e, t, i, r) {
  this.tag = e, this.containerInfo = n, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = ug(0), this.expirationTimes = ug(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ug(0), this.identifierPrefix = i, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null;
}
function qy(n, e, t, i, r, s, o, l, c) {
  return n = new Eb(n, e, t, l, c), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = $i(3, null, null, e), n.current = s, s.stateNode = n, s.memoizedState = { element: i, isDehydrated: t, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Ly(s), n;
}
function Tb(n, e, t) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: ll, key: i == null ? null : "" + i, children: n, containerInfo: e, implementation: t };
}
function DT(n) {
  if (!n)
    return ao;
  n = n._reactInternals;
  e: {
    if (pa(n) !== n || n.tag !== 1)
      throw Error(Ee(170));
    var e = n;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (xi(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(Ee(171));
  }
  if (n.tag === 1) {
    var t = n.type;
    if (xi(t))
      return DE(n, t, e);
  }
  return e;
}
function UT(n, e, t, i, r, s, o, l, c) {
  return n = qy(t, i, !0, n, r, s, o, l, c), n.context = DT(null), t = n.current, i = oi(), r = eo(t), s = gs(i, r), s.callback = e ?? null, Qs(t, s, r), n.current.lanes = r, Hc(n, r, i), Si(n, i), n;
}
function vp(n, e, t, i) {
  var r = e.current, s = oi(), o = eo(r);
  return t = DT(t), e.context === null ? e.context = t : e.pendingContext = t, e = gs(s, o), e.payload = { element: n }, i = i === void 0 ? null : i, i !== null && (e.callback = i), n = Qs(r, e, o), n !== null && (yr(n, r, o, s), dd(n, r, o)), o;
}
function Qd(n) {
  if (n = n.current, !n.child)
    return null;
  switch (n.child.tag) {
    case 5:
      return n.child.stateNode;
    default:
      return n.child.stateNode;
  }
}
function PS(n, e) {
  if (n = n.memoizedState, n !== null && n.dehydrated !== null) {
    var t = n.retryLane;
    n.retryLane = t !== 0 && t < e ? t : e;
  }
}
function Zy(n, e) {
  PS(n, e), (n = n.alternate) && PS(n, e);
}
function Ab() {
  return null;
}
var OT = typeof reportError == "function" ? reportError : function(n) {
  console.error(n);
};
function Ky(n) {
  this._internalRoot = n;
}
yp.prototype.render = Ky.prototype.render = function(n) {
  var e = this._internalRoot;
  if (e === null)
    throw Error(Ee(409));
  vp(n, e, null, null);
};
yp.prototype.unmount = Ky.prototype.unmount = function() {
  var n = this._internalRoot;
  if (n !== null) {
    this._internalRoot = null;
    var e = n.containerInfo;
    la(function() {
      vp(null, n, null, null);
    }), e[_s] = null;
  }
};
function yp(n) {
  this._internalRoot = n;
}
yp.prototype.unstable_scheduleHydration = function(n) {
  if (n) {
    var e = dE();
    n = { blockedOn: null, target: n, priority: e };
    for (var t = 0; t < Ws.length && e !== 0 && e < Ws[t].priority; t++)
      ;
    Ws.splice(t, 0, n), t === 0 && mE(n);
  }
};
function Jy(n) {
  return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11);
}
function _p(n) {
  return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "));
}
function bS() {
}
function Cb(n, e, t, i, r) {
  if (r) {
    if (typeof i == "function") {
      var s = i;
      i = function() {
        var f = Qd(o);
        s.call(f);
      };
    }
    var o = UT(e, i, n, 0, null, !1, !1, "", bS);
    return n._reactRootContainer = o, n[_s] = o.current, dc(n.nodeType === 8 ? n.parentNode : n), la(), o;
  }
  for (; r = n.lastChild; )
    n.removeChild(r);
  if (typeof i == "function") {
    var l = i;
    i = function() {
      var f = Qd(c);
      l.call(f);
    };
  }
  var c = qy(n, 0, !1, null, null, !1, !1, "", bS);
  return n._reactRootContainer = c, n[_s] = c.current, dc(n.nodeType === 8 ? n.parentNode : n), la(function() {
    vp(e, c, t, i);
  }), c;
}
function xp(n, e, t, i, r) {
  var s = t._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof r == "function") {
      var l = r;
      r = function() {
        var c = Qd(o);
        l.call(c);
      };
    }
    vp(e, o, n, r);
  } else
    o = Cb(t, e, n, r, i);
  return Qd(o);
}
fE = function(n) {
  switch (n.tag) {
    case 3:
      var e = n.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = Bu(e.pendingLanes);
        t !== 0 && (gy(e, t | 1), Si(e, dn()), !(Rt & 6) && (zl = dn() + 500, mo()));
      }
      break;
    case 13:
      la(function() {
        var i = xs(n, 1);
        if (i !== null) {
          var r = oi();
          yr(i, n, 1, r);
        }
      }), Zy(n, 1);
  }
};
vy = function(n) {
  if (n.tag === 13) {
    var e = xs(n, 134217728);
    if (e !== null) {
      var t = oi();
      yr(e, n, 134217728, t);
    }
    Zy(n, 134217728);
  }
};
hE = function(n) {
  if (n.tag === 13) {
    var e = eo(n), t = xs(n, e);
    if (t !== null) {
      var i = oi();
      yr(t, n, e, i);
    }
    Zy(n, e);
  }
};
dE = function() {
  return Ft;
};
pE = function(n, e) {
  var t = Ft;
  try {
    return Ft = n, e();
  } finally {
    Ft = t;
  }
};
L0 = function(n, e, t) {
  switch (e) {
    case "input":
      if (E0(n, t), e = t.name, t.type === "radio" && e != null) {
        for (t = n; t.parentNode; )
          t = t.parentNode;
        for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < t.length; e++) {
          var i = t[e];
          if (i !== n && i.form === n.form) {
            var r = cp(i);
            if (!r)
              throw Error(Ee(90));
            Xw(i), E0(i, r);
          }
        }
      }
      break;
    case "textarea":
      Yw(n, t);
      break;
    case "select":
      e = t.value, e != null && Tl(n, !!t.multiple, e, !1);
  }
};
eE = Wy;
tE = la;
var Rb = { usingClientEntryPoint: !1, Events: [Gc, dl, cp, Qw, $w, Wy] }, Tu = { findFiberByHostInstance: Xo, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, Pb = { bundleType: Tu.bundleType, version: Tu.version, rendererPackageName: Tu.rendererPackageName, rendererConfig: Tu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Es.ReactCurrentDispatcher, findHostInstanceByFiber: function(n) {
  return n = rE(n), n === null ? null : n.stateNode;
}, findFiberByHostInstance: Tu.findFiberByHostInstance || Ab, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var gh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!gh.isDisabled && gh.supportsFiber)
    try {
      op = gh.inject(Pb), zr = gh;
    } catch {
    }
}
Fi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Rb;
Fi.createPortal = function(n, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!Jy(e))
    throw Error(Ee(200));
  return Tb(n, e, null, t);
};
Fi.createRoot = function(n, e) {
  if (!Jy(n))
    throw Error(Ee(299));
  var t = !1, i = "", r = OT;
  return e != null && (e.unstable_strictMode === !0 && (t = !0), e.identifierPrefix !== void 0 && (i = e.identifierPrefix), e.onRecoverableError !== void 0 && (r = e.onRecoverableError)), e = qy(n, 1, !1, null, null, t, !1, i, r), n[_s] = e.current, dc(n.nodeType === 8 ? n.parentNode : n), new Ky(e);
};
Fi.findDOMNode = function(n) {
  if (n == null)
    return null;
  if (n.nodeType === 1)
    return n;
  var e = n._reactInternals;
  if (e === void 0)
    throw typeof n.render == "function" ? Error(Ee(188)) : (n = Object.keys(n).join(","), Error(Ee(268, n)));
  return n = rE(e), n = n === null ? null : n.stateNode, n;
};
Fi.flushSync = function(n) {
  return la(n);
};
Fi.hydrate = function(n, e, t) {
  if (!_p(e))
    throw Error(Ee(200));
  return xp(null, n, e, !0, t);
};
Fi.hydrateRoot = function(n, e, t) {
  if (!Jy(n))
    throw Error(Ee(405));
  var i = t != null && t.hydratedSources || null, r = !1, s = "", o = OT;
  if (t != null && (t.unstable_strictMode === !0 && (r = !0), t.identifierPrefix !== void 0 && (s = t.identifierPrefix), t.onRecoverableError !== void 0 && (o = t.onRecoverableError)), e = UT(e, null, n, 1, t ?? null, r, !1, s, o), n[_s] = e.current, dc(n), i)
    for (n = 0; n < i.length; n++)
      t = i[n], r = t._getVersion, r = r(t._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, r] : e.mutableSourceEagerHydrationData.push(
        t,
        r
      );
  return new yp(e);
};
Fi.render = function(n, e, t) {
  if (!_p(e))
    throw Error(Ee(200));
  return xp(null, n, e, !1, t);
};
Fi.unmountComponentAtNode = function(n) {
  if (!_p(n))
    throw Error(Ee(40));
  return n._reactRootContainer ? (la(function() {
    xp(null, null, n, !1, function() {
      n._reactRootContainer = null, n[_s] = null;
    });
  }), !0) : !1;
};
Fi.unstable_batchedUpdates = Wy;
Fi.unstable_renderSubtreeIntoContainer = function(n, e, t, i) {
  if (!_p(t))
    throw Error(Ee(200));
  if (n == null || n._reactInternals === void 0)
    throw Error(Ee(38));
  return xp(n, e, t, !1, i);
};
Fi.version = "18.3.1-next-f1338f8080-20240426";
function kT() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(kT);
    } catch (n) {
      console.error(n);
    }
}
kT(), kw.exports = Fi;
var bb = kw.exports, FT, LS = bb;
FT = v0.createRoot = LS.createRoot, v0.hydrateRoot = LS.hydrateRoot;
var Lb = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
const Ib = (n) => n.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), Nb = (n, e) => {
  const t = xe.forwardRef(
    ({ color: i = "currentColor", size: r = 24, strokeWidth: s = 2, absoluteStrokeWidth: o, children: l, ...c }, f) => xe.createElement(
      "svg",
      {
        ref: f,
        ...Lb,
        width: r,
        height: r,
        stroke: i,
        strokeWidth: o ? Number(s) * 24 / Number(r) : s,
        className: `lucide lucide-${Ib(n)}`,
        ...c
      },
      [
        ...e.map(([h, d]) => xe.createElement(h, d)),
        ...(Array.isArray(l) ? l : [l]) || []
      ]
    )
  );
  return t.displayName = `${n}`, t;
};
var Xr = Nb;
const cv = Xr("Activity", [
  ["path", { d: "M22 12h-4l-3 9L9 3l-3 9H2", key: "d5dnw9" }]
]), Db = Xr("Bone", [
  [
    "path",
    {
      d: "M17 10c.7-.7 1.69 0 2.5 0a2.5 2.5 0 1 0 0-5 .5.5 0 0 1-.5-.5 2.5 2.5 0 1 0-5 0c0 .81.7 1.8 0 2.5l-7 7c-.7.7-1.69 0-2.5 0a2.5 2.5 0 0 0 0 5c.28 0 .5.22.5.5a2.5 2.5 0 1 0 5 0c0-.81-.7-1.8 0-2.5Z",
      key: "w610uw"
    }
  ]
]), IS = Xr("Droplets", [
  [
    "path",
    {
      d: "M7 16.3c2.2 0 4-1.83 4-4.05 0-1.16-.57-2.26-1.71-3.19S7.29 6.75 7 5.3c-.29 1.45-1.14 2.84-2.29 3.76S3 11.1 3 12.25c0 2.22 1.8 4.05 4 4.05z",
      key: "1ptgy4"
    }
  ],
  [
    "path",
    {
      d: "M12.56 6.6A10.97 10.97 0 0 0 14 3.02c.5 2.5 2 4.9 4 6.5s3 3.5 3 5.5a6.98 6.98 0 0 1-11.91 4.97",
      key: "1sl1rz"
    }
  ]
]), NS = Xr("Flame", [
  [
    "path",
    {
      d: "M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z",
      key: "96xj49"
    }
  ]
]), Ub = Xr("Footprints", [
  [
    "path",
    {
      d: "M4 16v-2.38C4 11.5 2.97 10.5 3 8c.03-2.72 1.49-6 4.5-6C9.37 2 10 3.8 10 5.5c0 3.11-2 5.66-2 8.68V16a2 2 0 1 1-4 0Z",
      key: "1dudjm"
    }
  ],
  [
    "path",
    {
      d: "M20 20v-2.38c0-2.12 1.03-3.12 1-5.62-.03-2.72-1.49-6-4.5-6C14.63 6 14 7.8 14 9.5c0 3.11 2 5.66 2 8.68V20a2 2 0 1 0 4 0Z",
      key: "l2t8xc"
    }
  ],
  ["path", { d: "M16 17h4", key: "1dejxt" }],
  ["path", { d: "M4 13h4", key: "1bwh8b" }]
]), DS = Xr("Gauge", [
  ["path", { d: "m12 14 4-4", key: "9kzdfg" }],
  ["path", { d: "M3.34 19a10 10 0 1 1 17.32 0", key: "19p75a" }]
]), fv = Xr("Heart", [
  [
    "path",
    {
      d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z",
      key: "c3ymky"
    }
  ]
]), Ob = Xr("Percent", [
  ["line", { x1: "19", x2: "5", y1: "5", y2: "19", key: "1x9vlm" }],
  ["circle", { cx: "6.5", cy: "6.5", r: "2.5", key: "4mh3h7" }],
  ["circle", { cx: "17.5", cy: "17.5", r: "2.5", key: "1mdrzq" }]
]), zT = Xr("Scale", [
  [
    "path",
    { d: "m16 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z", key: "7g6ntu" }
  ],
  [
    "path",
    { d: "m2 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z", key: "ijws7r" }
  ],
  ["path", { d: "M7 21h10", key: "1b0cd5" }],
  ["path", { d: "M12 3v18", key: "108xh3" }],
  ["path", { d: "M3 7h2c2 0 5-1 7-2 2 1 5 2 7 2h2", key: "3gwbw2" }]
]), hv = Xr("Zap", [
  [
    "polygon",
    { points: "13 2 3 14 12 14 11 22 21 10 12 10 13 2", key: "45s27k" }
  ]
]);
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Sp = "154", Bo = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Ho = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, BT = 0, dv = 1, HT = 2, kb = 3, VT = 0, Mp = 1, $u = 2, hr = 3, Ms = 0, ai = 1, gr = 2, Fb = 2, vs = 0, ea = 1, pv = 2, mv = 3, gv = 4, GT = 5, Go = 100, WT = 101, XT = 102, vv = 103, yv = 104, jT = 200, YT = 201, qT = 202, ZT = 203, Qy = 204, $y = 205, KT = 206, JT = 207, QT = 208, $T = 209, eA = 210, tA = 0, nA = 1, iA = 2, $d = 3, rA = 4, sA = 5, oA = 6, aA = 7, Xc = 0, lA = 1, uA = 2, _r = 0, cA = 1, fA = 2, hA = 3, e_ = 4, dA = 5, wp = 300, lo = 301, uo = 302, Mc = 303, wc = 304, ql = 306, Ec = 1e3, Jn = 1001, Tc = 1002, hn = 1003, ep = 1004, zb = 1004, ec = 1005, Bb = 1005, pn = 1006, t_ = 1007, Hb = 1007, co = 1008, Vb = 1008, Hr = 1009, pA = 1010, mA = 1011, Ep = 1012, n_ = 1013, ms = 1014, kr = 1015, Bl = 1016, i_ = 1017, r_ = 1018, no = 1020, gA = 1021, vi = 1023, vA = 1024, yA = 1025, io = 1026, ua = 1027, _A = 1028, s_ = 1029, xA = 1030, o_ = 1031, a_ = 1033, xd = 33776, Sd = 33777, Md = 33778, wd = 33779, _v = 35840, xv = 35841, Sv = 35842, Mv = 35843, SA = 36196, wv = 37492, Ev = 37496, Tv = 37808, Av = 37809, Cv = 37810, Rv = 37811, Pv = 37812, bv = 37813, Lv = 37814, Iv = 37815, Nv = 37816, Dv = 37817, Uv = 37818, Ov = 37819, kv = 37820, Fv = 37821, Ed = 36492, MA = 36283, zv = 36284, Bv = 36285, Hv = 36286, wA = 2200, EA = 2201, TA = 2202, Ac = 2300, Cc = 2301, Td = 2302, qo = 2400, Zo = 2401, Rc = 2402, Tp = 2500, l_ = 2501, Gb = 0, Wb = 1, Xb = 2, u_ = 3e3, ro = 3001, AA = 3200, CA = 3201, go = 0, RA = 1, so = "", pt = "srgb", Sr = "srgb-linear", c_ = "display-p3", jb = 0, Ad = 7680, Yb = 7681, qb = 7682, Zb = 7683, Kb = 34055, Jb = 34056, Qb = 5386, $b = 512, eL = 513, tL = 514, nL = 515, iL = 516, rL = 517, sL = 518, PA = 519, bA = 512, LA = 513, IA = 514, NA = 515, DA = 516, UA = 517, OA = 518, kA = 519, Pc = 35044, oL = 35048, aL = 35040, lL = 35045, uL = 35049, cL = 35041, fL = 35046, hL = 35050, dL = 35042, pL = "100", Vv = "300 es", tp = 1035, Fr = 2e3, bc = 2001;
let Ts = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++)
        r[s].call(this, e);
      e.target = null;
    }
  }
};
const qn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let US = 1234567;
const ta = Math.PI / 180, Hl = 180 / Math.PI;
function Oi() {
  const n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (qn[n & 255] + qn[n >> 8 & 255] + qn[n >> 16 & 255] + qn[n >> 24 & 255] + "-" + qn[e & 255] + qn[e >> 8 & 255] + "-" + qn[e >> 16 & 15 | 64] + qn[e >> 24 & 255] + "-" + qn[t & 63 | 128] + qn[t >> 8 & 255] + "-" + qn[t >> 16 & 255] + qn[t >> 24 & 255] + qn[i & 255] + qn[i >> 8 & 255] + qn[i >> 16 & 255] + qn[i >> 24 & 255]).toLowerCase();
}
function un(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function f_(n, e) {
  return (n % e + e) % e;
}
function mL(n, e, t, i, r) {
  return i + (n - e) * (r - i) / (t - e);
}
function gL(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function tc(n, e, t) {
  return (1 - t) * n + t * e;
}
function vL(n, e, t, i) {
  return tc(n, e, 1 - Math.exp(-t * i));
}
function yL(n, e = 1) {
  return e - Math.abs(f_(n, e * 2) - e);
}
function _L(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n));
}
function xL(n, e, t) {
  return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10));
}
function SL(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function ML(n, e) {
  return n + Math.random() * (e - n);
}
function wL(n) {
  return n * (0.5 - Math.random());
}
function EL(n) {
  n !== void 0 && (US = n);
  let e = US += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function TL(n) {
  return n * ta;
}
function AL(n) {
  return n * Hl;
}
function Gv(n) {
  return (n & n - 1) === 0 && n !== 0;
}
function FA(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function np(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function CL(n, e, t, i, r) {
  const s = Math.cos, o = Math.sin, l = s(t / 2), c = o(t / 2), f = s((e + i) / 2), h = o((e + i) / 2), d = s((e - i) / 2), m = o((e - i) / 2), v = s((i - e) / 2), _ = o((i - e) / 2);
  switch (r) {
    case "XYX":
      n.set(l * h, c * d, c * m, l * f);
      break;
    case "YZY":
      n.set(c * m, l * h, c * d, l * f);
      break;
    case "ZXZ":
      n.set(c * d, c * m, l * h, l * f);
      break;
    case "XZX":
      n.set(l * h, c * _, c * v, l * f);
      break;
    case "YXY":
      n.set(c * v, l * h, c * _, l * f);
      break;
    case "ZYZ":
      n.set(c * _, c * v, l * h, l * f);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function Di(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function xt(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const zA = {
  DEG2RAD: ta,
  RAD2DEG: Hl,
  generateUUID: Oi,
  clamp: un,
  euclideanModulo: f_,
  mapLinear: mL,
  inverseLerp: gL,
  lerp: tc,
  damp: vL,
  pingpong: yL,
  smoothstep: _L,
  smootherstep: xL,
  randInt: SL,
  randFloat: ML,
  randFloatSpread: wL,
  seededRandom: EL,
  degToRad: TL,
  radToDeg: AL,
  isPowerOfTwo: Gv,
  ceilPowerOfTwo: FA,
  floorPowerOfTwo: np,
  setQuaternionFromProperEuler: CL,
  normalize: xt,
  denormalize: Di
};
class me {
  constructor(e = 0, t = 0) {
    me.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, r = e.elements;
    return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(un(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t), r = Math.sin(t), s = this.x - e.x, o = this.y - e.y;
    return this.x = s * i - o * r + e.x, this.y = s * r + o * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class _t {
  constructor(e, t, i, r, s, o, l, c, f) {
    _t.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, i, r, s, o, l, c, f);
  }
  set(e, t, i, r, s, o, l, c, f) {
    const h = this.elements;
    return h[0] = e, h[1] = r, h[2] = l, h[3] = t, h[4] = s, h[5] = c, h[6] = i, h[7] = o, h[8] = f, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, r = t.elements, s = this.elements, o = i[0], l = i[3], c = i[6], f = i[1], h = i[4], d = i[7], m = i[2], v = i[5], _ = i[8], w = r[0], M = r[3], g = r[6], x = r[1], S = r[4], T = r[7], C = r[2], P = r[5], L = r[8];
    return s[0] = o * w + l * x + c * C, s[3] = o * M + l * S + c * P, s[6] = o * g + l * T + c * L, s[1] = f * w + h * x + d * C, s[4] = f * M + h * S + d * P, s[7] = f * g + h * T + d * L, s[2] = m * w + v * x + _ * C, s[5] = m * M + v * S + _ * P, s[8] = m * g + v * T + _ * L, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], l = e[5], c = e[6], f = e[7], h = e[8];
    return t * o * h - t * l * f - i * s * h + i * l * c + r * s * f - r * o * c;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], l = e[5], c = e[6], f = e[7], h = e[8], d = h * o - l * f, m = l * c - h * s, v = f * s - o * c, _ = t * d + i * m + r * v;
    if (_ === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / _;
    return e[0] = d * w, e[1] = (r * f - h * i) * w, e[2] = (l * i - r * o) * w, e[3] = m * w, e[4] = (h * t - r * c) * w, e[5] = (r * s - l * t) * w, e[6] = v * w, e[7] = (i * c - f * t) * w, e[8] = (o * t - i * s) * w, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, i, r, s, o, l) {
    const c = Math.cos(s), f = Math.sin(s);
    return this.set(
      i * c,
      i * f,
      -i * (c * o + f * l) + o + e,
      -r * f,
      r * c,
      -r * (-f * o + c * l) + l + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(bg.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(bg.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(bg.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      -i,
      0,
      i,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let r = 0; r < 9; r++)
      if (t[r] !== i[r])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const bg = /* @__PURE__ */ new _t();
function BA(n) {
  for (let e = n.length - 1; e >= 0; --e)
    if (n[e] >= 65535)
      return !0;
  return !1;
}
const RL = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function xl(n, e) {
  return new RL[n](e);
}
function Lc(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
const OS = {};
function nc(n) {
  n in OS || (OS[n] = !0, console.warn(n));
}
function Ll(n) {
  return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function Lg(n) {
  return n < 31308e-7 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
const PL = /* @__PURE__ */ new _t().fromArray([
  0.8224621,
  0.0331941,
  0.0170827,
  0.177538,
  0.9668058,
  0.0723974,
  -1e-7,
  1e-7,
  0.9105199
]), bL = /* @__PURE__ */ new _t().fromArray([
  1.2249401,
  -0.0420569,
  -0.0196376,
  -0.2249404,
  1.0420571,
  -0.0786361,
  1e-7,
  0,
  1.0982735
]);
function LL(n) {
  return n.convertSRGBToLinear().applyMatrix3(bL);
}
function IL(n) {
  return n.applyMatrix3(PL).convertLinearToSRGB();
}
const NL = {
  [Sr]: (n) => n,
  [pt]: (n) => n.convertSRGBToLinear(),
  [c_]: LL
}, DL = {
  [Sr]: (n) => n,
  [pt]: (n) => n.convertLinearToSRGB(),
  [c_]: IL
}, Zi = {
  enabled: !0,
  get legacyMode() {
    return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled;
  },
  set legacyMode(n) {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !n;
  },
  get workingColorSpace() {
    return Sr;
  },
  set workingColorSpace(n) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(n, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return n;
    const i = NL[e], r = DL[t];
    if (i === void 0 || r === void 0)
      throw new Error(`Unsupported color space conversion, "${e}" to "${t}".`);
    return r(i(n));
  },
  fromWorkingColorSpace: function(n, e) {
    return this.convert(n, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(n, e) {
    return this.convert(n, e, this.workingColorSpace);
  }
};
let Ua;
class h_ {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      Ua === void 0 && (Ua = Lc("canvas")), Ua.width = e.width, Ua.height = e.height;
      const i = Ua.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = Ua;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = Lc("canvas");
      t.width = e.width, t.height = e.height;
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height), s = r.data;
      for (let o = 0; o < s.length; o++)
        s[o] = Ll(s[o] / 255) * 255;
      return i.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Ll(t[i] / 255) * 255) : t[i] = Ll(t[i]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let UL = 0;
class Ko {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: UL++ }), this.uuid = Oi(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, l = r.length; o < l; o++)
          r[o].isDataTexture ? s.push(Ig(r[o].image)) : s.push(Ig(r[o]));
      } else
        s = Ig(r);
      i.url = s;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function Ig(n) {
  return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? h_.getDataURL(n) : n.data ? {
    data: Array.from(n.data),
    width: n.width,
    height: n.height,
    type: n.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let OL = 0;
class mn extends Ts {
  constructor(e = mn.DEFAULT_IMAGE, t = mn.DEFAULT_MAPPING, i = Jn, r = Jn, s = pn, o = co, l = vi, c = Hr, f = mn.DEFAULT_ANISOTROPY, h = so) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: OL++ }), this.uuid = Oi(), this.name = "", this.source = new Ko(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = f, this.format = l, this.internalFormat = null, this.type = c, this.offset = new me(0, 0), this.repeat = new me(1, 1), this.center = new me(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new _t(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof h == "string" ? this.colorSpace = h : (nc("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = h === ro ? pt : so), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== wp)
      return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Ec:
          e.x = e.x - Math.floor(e.x);
          break;
        case Jn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Tc:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Ec:
          e.y = e.y - Math.floor(e.y);
          break;
        case Jn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Tc:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  get encoding() {
    return nc("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === pt ? ro : u_;
  }
  set encoding(e) {
    nc("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === ro ? pt : so;
  }
}
mn.DEFAULT_IMAGE = null;
mn.DEFAULT_MAPPING = wp;
mn.DEFAULT_ANISOTROPY = 1;
class kt {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    kt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return this.x = e, this.y = t, this.z = i, this.w = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, r = this.z, s = this.w, o = e.elements;
    return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s, this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s, this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s, this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const c = e.elements, f = c[0], h = c[4], d = c[8], m = c[1], v = c[5], _ = c[9], w = c[2], M = c[6], g = c[10];
    if (Math.abs(h - m) < 0.01 && Math.abs(d - w) < 0.01 && Math.abs(_ - M) < 0.01) {
      if (Math.abs(h + m) < 0.1 && Math.abs(d + w) < 0.1 && Math.abs(_ + M) < 0.1 && Math.abs(f + v + g - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const S = (f + 1) / 2, T = (v + 1) / 2, C = (g + 1) / 2, P = (h + m) / 4, L = (d + w) / 4, N = (_ + M) / 4;
      return S > T && S > C ? S < 0.01 ? (i = 0, r = 0.707106781, s = 0.707106781) : (i = Math.sqrt(S), r = P / i, s = L / i) : T > C ? T < 0.01 ? (i = 0.707106781, r = 0, s = 0.707106781) : (r = Math.sqrt(T), i = P / r, s = N / r) : C < 0.01 ? (i = 0.707106781, r = 0.707106781, s = 0) : (s = Math.sqrt(C), i = L / s, r = N / s), this.set(i, r, s, t), this;
    }
    let x = Math.sqrt((M - _) * (M - _) + (d - w) * (d - w) + (m - h) * (m - h));
    return Math.abs(x) < 1e-3 && (x = 1), this.x = (M - _) / x, this.y = (d - w) / x, this.z = (m - h) / x, this.w = Math.acos((f + v + g - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Mr extends Ts {
  constructor(e = 1, t = 1, i = {}) {
    super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new kt(0, 0, e, t), this.scissorTest = !1, this.viewport = new kt(0, 0, e, t);
    const r = { width: e, height: t, depth: 1 };
    i.encoding !== void 0 && (nc("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), i.colorSpace = i.encoding === ro ? pt : so), this.texture = new mn(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1, this.texture.internalFormat = i.internalFormat !== void 0 ? i.internalFormat : null, this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : pn, this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0, this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1, this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null, this.samples = i.samples !== void 0 ? i.samples : 0;
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new Ko(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Ap extends mn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = hn, this.minFilter = hn, this.wrapR = Jn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class kL extends Mr {
  constructor(e = 1, t = 1, i = 1) {
    super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = i, this.texture = new Ap(null, e, t, i), this.texture.isRenderTargetTexture = !0;
  }
}
class d_ extends mn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = hn, this.minFilter = hn, this.wrapR = Jn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class FL extends Mr {
  constructor(e = 1, t = 1, i = 1) {
    super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = i, this.texture = new d_(null, e, t, i), this.texture.isRenderTargetTexture = !0;
  }
}
class zL extends Mr {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r), this.isWebGLMultipleRenderTargets = !0;
    const s = this.texture;
    this.texture = [];
    for (let o = 0; o < i; o++)
      this.texture[o] = s.clone(), this.texture[o].isRenderTargetTexture = !0;
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      this.width = e, this.height = t, this.depth = i;
      for (let r = 0, s = this.texture.length; r < s; r++)
        this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = i;
      this.dispose();
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, i = e.texture.length; t < i; t++)
      this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}
class Qn {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = r;
  }
  static slerpFlat(e, t, i, r, s, o, l) {
    let c = i[r + 0], f = i[r + 1], h = i[r + 2], d = i[r + 3];
    const m = s[o + 0], v = s[o + 1], _ = s[o + 2], w = s[o + 3];
    if (l === 0) {
      e[t + 0] = c, e[t + 1] = f, e[t + 2] = h, e[t + 3] = d;
      return;
    }
    if (l === 1) {
      e[t + 0] = m, e[t + 1] = v, e[t + 2] = _, e[t + 3] = w;
      return;
    }
    if (d !== w || c !== m || f !== v || h !== _) {
      let M = 1 - l;
      const g = c * m + f * v + h * _ + d * w, x = g >= 0 ? 1 : -1, S = 1 - g * g;
      if (S > Number.EPSILON) {
        const C = Math.sqrt(S), P = Math.atan2(C, g * x);
        M = Math.sin(M * P) / C, l = Math.sin(l * P) / C;
      }
      const T = l * x;
      if (c = c * M + m * T, f = f * M + v * T, h = h * M + _ * T, d = d * M + w * T, M === 1 - l) {
        const C = 1 / Math.sqrt(c * c + f * f + h * h + d * d);
        c *= C, f *= C, h *= C, d *= C;
      }
    }
    e[t] = c, e[t + 1] = f, e[t + 2] = h, e[t + 3] = d;
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const l = i[r], c = i[r + 1], f = i[r + 2], h = i[r + 3], d = s[o], m = s[o + 1], v = s[o + 2], _ = s[o + 3];
    return e[t] = l * _ + h * d + c * v - f * m, e[t + 1] = c * _ + h * m + f * d - l * v, e[t + 2] = f * _ + h * v + l * m - c * d, e[t + 3] = h * _ - l * d - c * m - f * v, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, i, r) {
    return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    const i = e._x, r = e._y, s = e._z, o = e._order, l = Math.cos, c = Math.sin, f = l(i / 2), h = l(r / 2), d = l(s / 2), m = c(i / 2), v = c(r / 2), _ = c(s / 2);
    switch (o) {
      case "XYZ":
        this._x = m * h * d + f * v * _, this._y = f * v * d - m * h * _, this._z = f * h * _ + m * v * d, this._w = f * h * d - m * v * _;
        break;
      case "YXZ":
        this._x = m * h * d + f * v * _, this._y = f * v * d - m * h * _, this._z = f * h * _ - m * v * d, this._w = f * h * d + m * v * _;
        break;
      case "ZXY":
        this._x = m * h * d - f * v * _, this._y = f * v * d + m * h * _, this._z = f * h * _ + m * v * d, this._w = f * h * d - m * v * _;
        break;
      case "ZYX":
        this._x = m * h * d - f * v * _, this._y = f * v * d + m * h * _, this._z = f * h * _ - m * v * d, this._w = f * h * d + m * v * _;
        break;
      case "YZX":
        this._x = m * h * d + f * v * _, this._y = f * v * d + m * h * _, this._z = f * h * _ - m * v * d, this._w = f * h * d - m * v * _;
        break;
      case "XZY":
        this._x = m * h * d - f * v * _, this._y = f * v * d - m * h * _, this._z = f * h * _ + m * v * d, this._w = f * h * d + m * v * _;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2, r = Math.sin(i);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, i = t[0], r = t[4], s = t[8], o = t[1], l = t[5], c = t[9], f = t[2], h = t[6], d = t[10], m = i + l + d;
    if (m > 0) {
      const v = 0.5 / Math.sqrt(m + 1);
      this._w = 0.25 / v, this._x = (h - c) * v, this._y = (s - f) * v, this._z = (o - r) * v;
    } else if (i > l && i > d) {
      const v = 2 * Math.sqrt(1 + i - l - d);
      this._w = (h - c) / v, this._x = 0.25 * v, this._y = (r + o) / v, this._z = (s + f) / v;
    } else if (l > d) {
      const v = 2 * Math.sqrt(1 + l - i - d);
      this._w = (s - f) / v, this._x = (r + o) / v, this._y = 0.25 * v, this._z = (c + h) / v;
    } else {
      const v = 2 * Math.sqrt(1 + d - i - l);
      this._w = (o - r) / v, this._x = (s + f) / v, this._y = (c + h) / v, this._z = 0.25 * v;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(un(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0)
      return this;
    const r = Math.min(1, t / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x, r = e._y, s = e._z, o = e._w, l = t._x, c = t._y, f = t._z, h = t._w;
    return this._x = i * h + o * l + r * f - s * c, this._y = r * h + o * c + s * l - i * f, this._z = s * h + o * f + i * c - r * l, this._w = o * h - i * l - r * c - s * f, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const i = this._x, r = this._y, s = this._z, o = this._w;
    let l = o * e._w + i * e._x + r * e._y + s * e._z;
    if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1)
      return this._w = o, this._x = i, this._y = r, this._z = s, this;
    const c = 1 - l * l;
    if (c <= Number.EPSILON) {
      const v = 1 - t;
      return this._w = v * o + t * this._w, this._x = v * i + t * this._x, this._y = v * r + t * this._y, this._z = v * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const f = Math.sqrt(c), h = Math.atan2(f, l), d = Math.sin((1 - t) * h) / f, m = Math.sin(t * h) / f;
    return this._w = o * d + this._w * m, this._x = i * d + this._x * m, this._y = r * d + this._y * m, this._z = s * d + this._z * m, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), i = Math.sqrt(e), r = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(r),
      i * Math.sin(s),
      i * Math.cos(s),
      t * Math.sin(r)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class D {
  constructor(e = 0, t = 0, i = 0) {
    D.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i;
  }
  set(e, t, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(kS.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(kS.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * i + s[6] * r, this.y = s[1] * t + s[4] * i + s[7] * r, this.z = s[2] * t + s[5] * i + s[8] * r, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o, this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o, this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, i = this.y, r = this.z, s = e.x, o = e.y, l = e.z, c = e.w, f = c * t + o * r - l * i, h = c * i + l * t - s * r, d = c * r + s * i - o * t, m = -s * t - o * i - l * r;
    return this.x = f * c + m * -s + h * -l - d * -o, this.y = h * c + m * -o + d * -s - f * -l, this.z = d * c + m * -l + f * -o - h * -s, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * i + s[8] * r, this.y = s[1] * t + s[5] * i + s[9] * r, this.z = s[2] * t + s[6] * i + s[10] * r, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x, r = e.y, s = e.z, o = t.x, l = t.y, c = t.z;
    return this.x = r * c - s * l, this.y = s * o - i * c, this.z = i * l - r * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return Ng.copy(this).projectOnVector(e), this.sub(Ng);
  }
  reflect(e) {
    return this.sub(Ng.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(un(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y, r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = i, this.z = r, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, i = Math.sqrt(1 - e ** 2);
    return this.x = i * Math.cos(t), this.y = i * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Ng = /* @__PURE__ */ new D(), kS = /* @__PURE__ */ new Qn();
class jr {
  constructor(e = new D(1 / 0, 1 / 0, 1 / 0), t = new D(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(ts.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(ts.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = ts.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if (e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0)
      e.boundingBox === null && e.computeBoundingBox(), Oa.copy(e.boundingBox), Oa.applyMatrix4(e.matrixWorld), this.union(Oa);
    else {
      const r = e.geometry;
      if (r !== void 0)
        if (t && r.attributes !== void 0 && r.attributes.position !== void 0) {
          const s = r.attributes.position;
          for (let o = 0, l = s.count; o < l; o++)
            ts.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld), this.expandByPoint(ts);
        } else
          r.boundingBox === null && r.computeBoundingBox(), Oa.copy(r.boundingBox), Oa.applyMatrix4(e.matrixWorld), this.union(Oa);
    }
    const i = e.children;
    for (let r = 0, s = i.length; r < s; r++)
      this.expandByObject(i[r], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, ts), ts.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, i;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Au), vh.subVectors(this.max, Au), ka.subVectors(e.a, Au), Fa.subVectors(e.b, Au), za.subVectors(e.c, Au), ks.subVectors(Fa, ka), Fs.subVectors(za, Fa), Po.subVectors(ka, za);
    let t = [
      0,
      -ks.z,
      ks.y,
      0,
      -Fs.z,
      Fs.y,
      0,
      -Po.z,
      Po.y,
      ks.z,
      0,
      -ks.x,
      Fs.z,
      0,
      -Fs.x,
      Po.z,
      0,
      -Po.x,
      -ks.y,
      ks.x,
      0,
      -Fs.y,
      Fs.x,
      0,
      -Po.y,
      Po.x,
      0
    ];
    return !Dg(t, ka, Fa, za, vh) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Dg(t, ka, Fa, za, vh)) ? !1 : (yh.crossVectors(ks, Fs), t = [yh.x, yh.y, yh.z], Dg(t, ka, Fa, za, vh));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ts).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(ts).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (es[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), es[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), es[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), es[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), es[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), es[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), es[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), es[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(es), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const es = [
  /* @__PURE__ */ new D(),
  /* @__PURE__ */ new D(),
  /* @__PURE__ */ new D(),
  /* @__PURE__ */ new D(),
  /* @__PURE__ */ new D(),
  /* @__PURE__ */ new D(),
  /* @__PURE__ */ new D(),
  /* @__PURE__ */ new D()
], ts = /* @__PURE__ */ new D(), Oa = /* @__PURE__ */ new jr(), ka = /* @__PURE__ */ new D(), Fa = /* @__PURE__ */ new D(), za = /* @__PURE__ */ new D(), ks = /* @__PURE__ */ new D(), Fs = /* @__PURE__ */ new D(), Po = /* @__PURE__ */ new D(), Au = /* @__PURE__ */ new D(), vh = /* @__PURE__ */ new D(), yh = /* @__PURE__ */ new D(), bo = /* @__PURE__ */ new D();
function Dg(n, e, t, i, r) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    bo.fromArray(n, s);
    const l = r.x * Math.abs(bo.x) + r.y * Math.abs(bo.y) + r.z * Math.abs(bo.z), c = e.dot(bo), f = t.dot(bo), h = i.dot(bo);
    if (Math.max(-Math.max(c, f, h), Math.min(c, f, h)) > l)
      return !1;
  }
  return !0;
}
const BL = /* @__PURE__ */ new jr(), Cu = /* @__PURE__ */ new D(), Ug = /* @__PURE__ */ new D();
class wr {
  constructor(e = new D(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : BL.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(r), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Cu.subVectors(e, this.center);
    const t = Cu.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t), r = (i - this.radius) * 0.5;
      this.center.addScaledVector(Cu, r / i), this.radius += r;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Ug.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Cu.copy(e.center).add(Ug)), this.expandByPoint(Cu.copy(e.center).sub(Ug))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ns = /* @__PURE__ */ new D(), Og = /* @__PURE__ */ new D(), _h = /* @__PURE__ */ new D(), zs = /* @__PURE__ */ new D(), kg = /* @__PURE__ */ new D(), xh = /* @__PURE__ */ new D(), Fg = /* @__PURE__ */ new D();
class ma {
  constructor(e = new D(), t = new D(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, ns)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = ns.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (ns.copy(this.origin).addScaledVector(this.direction, t), ns.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    Og.copy(e).add(t).multiplyScalar(0.5), _h.copy(t).sub(e).normalize(), zs.copy(this.origin).sub(Og);
    const s = e.distanceTo(t) * 0.5, o = -this.direction.dot(_h), l = zs.dot(this.direction), c = -zs.dot(_h), f = zs.lengthSq(), h = Math.abs(1 - o * o);
    let d, m, v, _;
    if (h > 0)
      if (d = o * c - l, m = o * l - c, _ = s * h, d >= 0)
        if (m >= -_)
          if (m <= _) {
            const w = 1 / h;
            d *= w, m *= w, v = d * (d + o * m + 2 * l) + m * (o * d + m + 2 * c) + f;
          } else
            m = s, d = Math.max(0, -(o * m + l)), v = -d * d + m * (m + 2 * c) + f;
        else
          m = -s, d = Math.max(0, -(o * m + l)), v = -d * d + m * (m + 2 * c) + f;
      else
        m <= -_ ? (d = Math.max(0, -(-o * s + l)), m = d > 0 ? -s : Math.min(Math.max(-s, -c), s), v = -d * d + m * (m + 2 * c) + f) : m <= _ ? (d = 0, m = Math.min(Math.max(-s, -c), s), v = m * (m + 2 * c) + f) : (d = Math.max(0, -(o * s + l)), m = d > 0 ? s : Math.min(Math.max(-s, -c), s), v = -d * d + m * (m + 2 * c) + f);
    else
      m = o > 0 ? -s : s, d = Math.max(0, -(o * m + l)), v = -d * d + m * (m + 2 * c) + f;
    return i && i.copy(this.origin).addScaledVector(this.direction, d), r && r.copy(Og).addScaledVector(_h, m), v;
  }
  intersectSphere(e, t) {
    ns.subVectors(e.center, this.origin);
    const i = ns.dot(this.direction), r = ns.dot(ns) - i * i, s = e.radius * e.radius;
    if (r > s)
      return null;
    const o = Math.sqrt(s - r), l = i - o, c = i + o;
    return c < 0 ? null : l < 0 ? this.at(c, t) : this.at(l, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, o, l, c;
    const f = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, m = this.origin;
    return f >= 0 ? (i = (e.min.x - m.x) * f, r = (e.max.x - m.x) * f) : (i = (e.max.x - m.x) * f, r = (e.min.x - m.x) * f), h >= 0 ? (s = (e.min.y - m.y) * h, o = (e.max.y - m.y) * h) : (s = (e.max.y - m.y) * h, o = (e.min.y - m.y) * h), i > o || s > r || ((s > i || isNaN(i)) && (i = s), (o < r || isNaN(r)) && (r = o), d >= 0 ? (l = (e.min.z - m.z) * d, c = (e.max.z - m.z) * d) : (l = (e.max.z - m.z) * d, c = (e.min.z - m.z) * d), i > c || l > r) || ((l > i || i !== i) && (i = l), (c < r || r !== r) && (r = c), r < 0) ? null : this.at(i >= 0 ? i : r, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, ns) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    kg.subVectors(t, e), xh.subVectors(i, e), Fg.crossVectors(kg, xh);
    let o = this.direction.dot(Fg), l;
    if (o > 0) {
      if (r)
        return null;
      l = 1;
    } else if (o < 0)
      l = -1, o = -o;
    else
      return null;
    zs.subVectors(this.origin, e);
    const c = l * this.direction.dot(xh.crossVectors(zs, xh));
    if (c < 0)
      return null;
    const f = l * this.direction.dot(kg.cross(zs));
    if (f < 0 || c + f > o)
      return null;
    const h = -l * zs.dot(Fg);
    return h < 0 ? null : this.at(h / o, s);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class dt {
  constructor(e, t, i, r, s, o, l, c, f, h, d, m, v, _, w, M) {
    dt.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, i, r, s, o, l, c, f, h, d, m, v, _, w, M);
  }
  set(e, t, i, r, s, o, l, c, f, h, d, m, v, _, w, M) {
    const g = this.elements;
    return g[0] = e, g[4] = t, g[8] = i, g[12] = r, g[1] = s, g[5] = o, g[9] = l, g[13] = c, g[2] = f, g[6] = h, g[10] = d, g[14] = m, g[3] = v, g[7] = _, g[11] = w, g[15] = M, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new dt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
  }
  copyPosition(e) {
    const t = this.elements, i = e.elements;
    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, i) {
    return this.set(
      e.x,
      t.x,
      i.x,
      0,
      e.y,
      t.y,
      i.y,
      0,
      e.z,
      t.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, i = e.elements, r = 1 / Ba.setFromMatrixColumn(e, 0).length(), s = 1 / Ba.setFromMatrixColumn(e, 1).length(), o = 1 / Ba.setFromMatrixColumn(e, 2).length();
    return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * o, t[9] = i[9] * o, t[10] = i[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, i = e.x, r = e.y, s = e.z, o = Math.cos(i), l = Math.sin(i), c = Math.cos(r), f = Math.sin(r), h = Math.cos(s), d = Math.sin(s);
    if (e.order === "XYZ") {
      const m = o * h, v = o * d, _ = l * h, w = l * d;
      t[0] = c * h, t[4] = -c * d, t[8] = f, t[1] = v + _ * f, t[5] = m - w * f, t[9] = -l * c, t[2] = w - m * f, t[6] = _ + v * f, t[10] = o * c;
    } else if (e.order === "YXZ") {
      const m = c * h, v = c * d, _ = f * h, w = f * d;
      t[0] = m + w * l, t[4] = _ * l - v, t[8] = o * f, t[1] = o * d, t[5] = o * h, t[9] = -l, t[2] = v * l - _, t[6] = w + m * l, t[10] = o * c;
    } else if (e.order === "ZXY") {
      const m = c * h, v = c * d, _ = f * h, w = f * d;
      t[0] = m - w * l, t[4] = -o * d, t[8] = _ + v * l, t[1] = v + _ * l, t[5] = o * h, t[9] = w - m * l, t[2] = -o * f, t[6] = l, t[10] = o * c;
    } else if (e.order === "ZYX") {
      const m = o * h, v = o * d, _ = l * h, w = l * d;
      t[0] = c * h, t[4] = _ * f - v, t[8] = m * f + w, t[1] = c * d, t[5] = w * f + m, t[9] = v * f - _, t[2] = -f, t[6] = l * c, t[10] = o * c;
    } else if (e.order === "YZX") {
      const m = o * c, v = o * f, _ = l * c, w = l * f;
      t[0] = c * h, t[4] = w - m * d, t[8] = _ * d + v, t[1] = d, t[5] = o * h, t[9] = -l * h, t[2] = -f * h, t[6] = v * d + _, t[10] = m - w * d;
    } else if (e.order === "XZY") {
      const m = o * c, v = o * f, _ = l * c, w = l * f;
      t[0] = c * h, t[4] = -d, t[8] = f * h, t[1] = m * d + w, t[5] = o * h, t[9] = v * d - _, t[2] = _ * d - v, t[6] = l * h, t[10] = w * d + m;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(HL, e, VL);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return Pi.subVectors(e, t), Pi.lengthSq() === 0 && (Pi.z = 1), Pi.normalize(), Bs.crossVectors(i, Pi), Bs.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Pi.x += 1e-4 : Pi.z += 1e-4, Pi.normalize(), Bs.crossVectors(i, Pi)), Bs.normalize(), Sh.crossVectors(Pi, Bs), r[0] = Bs.x, r[4] = Sh.x, r[8] = Pi.x, r[1] = Bs.y, r[5] = Sh.y, r[9] = Pi.y, r[2] = Bs.z, r[6] = Sh.z, r[10] = Pi.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, r = t.elements, s = this.elements, o = i[0], l = i[4], c = i[8], f = i[12], h = i[1], d = i[5], m = i[9], v = i[13], _ = i[2], w = i[6], M = i[10], g = i[14], x = i[3], S = i[7], T = i[11], C = i[15], P = r[0], L = r[4], N = r[8], R = r[12], b = r[1], G = r[5], $ = r[9], Y = r[13], K = r[2], J = r[6], oe = r[10], ne = r[14], O = r[3], X = r[7], W = r[11], V = r[15];
    return s[0] = o * P + l * b + c * K + f * O, s[4] = o * L + l * G + c * J + f * X, s[8] = o * N + l * $ + c * oe + f * W, s[12] = o * R + l * Y + c * ne + f * V, s[1] = h * P + d * b + m * K + v * O, s[5] = h * L + d * G + m * J + v * X, s[9] = h * N + d * $ + m * oe + v * W, s[13] = h * R + d * Y + m * ne + v * V, s[2] = _ * P + w * b + M * K + g * O, s[6] = _ * L + w * G + M * J + g * X, s[10] = _ * N + w * $ + M * oe + g * W, s[14] = _ * R + w * Y + M * ne + g * V, s[3] = x * P + S * b + T * K + C * O, s[7] = x * L + S * G + T * J + C * X, s[11] = x * N + S * $ + T * oe + C * W, s[15] = x * R + S * Y + T * ne + C * V, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[4], r = e[8], s = e[12], o = e[1], l = e[5], c = e[9], f = e[13], h = e[2], d = e[6], m = e[10], v = e[14], _ = e[3], w = e[7], M = e[11], g = e[15];
    return _ * (+s * c * d - r * f * d - s * l * m + i * f * m + r * l * v - i * c * v) + w * (+t * c * v - t * f * m + s * o * m - r * o * v + r * f * h - s * c * h) + M * (+t * f * d - t * l * v - s * o * d + i * o * v + s * l * h - i * f * h) + g * (-r * l * h - t * c * d + t * l * m + r * o * d - i * o * m + i * c * h);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], l = e[5], c = e[6], f = e[7], h = e[8], d = e[9], m = e[10], v = e[11], _ = e[12], w = e[13], M = e[14], g = e[15], x = d * M * f - w * m * f + w * c * v - l * M * v - d * c * g + l * m * g, S = _ * m * f - h * M * f - _ * c * v + o * M * v + h * c * g - o * m * g, T = h * w * f - _ * d * f + _ * l * v - o * w * v - h * l * g + o * d * g, C = _ * d * c - h * w * c - _ * l * m + o * w * m + h * l * M - o * d * M, P = t * x + i * S + r * T + s * C;
    if (P === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const L = 1 / P;
    return e[0] = x * L, e[1] = (w * m * s - d * M * s - w * r * v + i * M * v + d * r * g - i * m * g) * L, e[2] = (l * M * s - w * c * s + w * r * f - i * M * f - l * r * g + i * c * g) * L, e[3] = (d * c * s - l * m * s - d * r * f + i * m * f + l * r * v - i * c * v) * L, e[4] = S * L, e[5] = (h * M * s - _ * m * s + _ * r * v - t * M * v - h * r * g + t * m * g) * L, e[6] = (_ * c * s - o * M * s - _ * r * f + t * M * f + o * r * g - t * c * g) * L, e[7] = (o * m * s - h * c * s + h * r * f - t * m * f - o * r * v + t * c * v) * L, e[8] = T * L, e[9] = (_ * d * s - h * w * s - _ * i * v + t * w * v + h * i * g - t * d * g) * L, e[10] = (o * w * s - _ * l * s + _ * i * f - t * w * f - o * i * g + t * l * g) * L, e[11] = (h * l * s - o * d * s - h * i * f + t * d * f + o * i * v - t * l * v) * L, e[12] = C * L, e[13] = (h * w * r - _ * d * r + _ * i * m - t * w * m - h * i * M + t * d * M) * L, e[14] = (_ * l * r - o * w * r - _ * i * c + t * w * c + o * i * M - t * l * M) * L, e[15] = (o * d * r - h * l * r + h * i * c - t * d * c - o * i * m + t * l * m) * L, this;
  }
  scale(e) {
    const t = this.elements, i = e.x, r = e.y, s = e.z;
    return t[0] *= i, t[4] *= r, t[8] *= s, t[1] *= i, t[5] *= r, t[9] *= s, t[2] *= i, t[6] *= r, t[10] *= s, t[3] *= i, t[7] *= r, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(
      t,
      -i,
      0,
      0,
      i,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t), r = Math.sin(t), s = 1 - i, o = e.x, l = e.y, c = e.z, f = s * o, h = s * l;
    return this.set(
      f * o + i,
      f * l - r * c,
      f * c + r * l,
      0,
      f * l + r * c,
      h * l + i,
      h * c - r * o,
      0,
      f * c - r * l,
      h * c + r * o,
      s * c * c + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, i, r, s, o) {
    return this.set(
      1,
      i,
      s,
      0,
      e,
      1,
      o,
      0,
      t,
      r,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, i) {
    const r = this.elements, s = t._x, o = t._y, l = t._z, c = t._w, f = s + s, h = o + o, d = l + l, m = s * f, v = s * h, _ = s * d, w = o * h, M = o * d, g = l * d, x = c * f, S = c * h, T = c * d, C = i.x, P = i.y, L = i.z;
    return r[0] = (1 - (w + g)) * C, r[1] = (v + T) * C, r[2] = (_ - S) * C, r[3] = 0, r[4] = (v - T) * P, r[5] = (1 - (m + g)) * P, r[6] = (M + x) * P, r[7] = 0, r[8] = (_ + S) * L, r[9] = (M - x) * L, r[10] = (1 - (m + w)) * L, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = Ba.set(r[0], r[1], r[2]).length();
    const o = Ba.set(r[4], r[5], r[6]).length(), l = Ba.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], lr.copy(this);
    const f = 1 / s, h = 1 / o, d = 1 / l;
    return lr.elements[0] *= f, lr.elements[1] *= f, lr.elements[2] *= f, lr.elements[4] *= h, lr.elements[5] *= h, lr.elements[6] *= h, lr.elements[8] *= d, lr.elements[9] *= d, lr.elements[10] *= d, t.setFromRotationMatrix(lr), i.x = s, i.y = o, i.z = l, this;
  }
  makePerspective(e, t, i, r, s, o, l = Fr) {
    const c = this.elements, f = 2 * s / (t - e), h = 2 * s / (i - r), d = (t + e) / (t - e), m = (i + r) / (i - r);
    let v, _;
    if (l === Fr)
      v = -(o + s) / (o - s), _ = -2 * o * s / (o - s);
    else if (l === bc)
      v = -o / (o - s), _ = -o * s / (o - s);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return c[0] = f, c[4] = 0, c[8] = d, c[12] = 0, c[1] = 0, c[5] = h, c[9] = m, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = v, c[14] = _, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
  }
  makeOrthographic(e, t, i, r, s, o, l = Fr) {
    const c = this.elements, f = 1 / (t - e), h = 1 / (i - r), d = 1 / (o - s), m = (t + e) * f, v = (i + r) * h;
    let _, w;
    if (l === Fr)
      _ = (o + s) * d, w = -2 * d;
    else if (l === bc)
      _ = s * d, w = -1 * d;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return c[0] = 2 * f, c[4] = 0, c[8] = 0, c[12] = -m, c[1] = 0, c[5] = 2 * h, c[9] = 0, c[13] = -v, c[2] = 0, c[6] = 0, c[10] = w, c[14] = -_, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let r = 0; r < 16; r++)
      if (t[r] !== i[r])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
  }
}
const Ba = /* @__PURE__ */ new D(), lr = /* @__PURE__ */ new dt(), HL = /* @__PURE__ */ new D(0, 0, 0), VL = /* @__PURE__ */ new D(1, 1, 1), Bs = /* @__PURE__ */ new D(), Sh = /* @__PURE__ */ new D(), Pi = /* @__PURE__ */ new D(), FS = /* @__PURE__ */ new dt(), zS = /* @__PURE__ */ new Qn();
class jc {
  constructor(e = 0, t = 0, i = 0, r = jc.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, i, r = this._order) {
    return this._x = e, this._y = t, this._z = i, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements, s = r[0], o = r[4], l = r[8], c = r[1], f = r[5], h = r[9], d = r[2], m = r[6], v = r[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(un(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, v), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(m, f), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-un(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(l, v), this._z = Math.atan2(c, f)) : (this._y = Math.atan2(-d, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(un(m, -1, 1)), Math.abs(m) < 0.9999999 ? (this._y = Math.atan2(-d, v), this._z = Math.atan2(-o, f)) : (this._y = 0, this._z = Math.atan2(c, s));
        break;
      case "ZYX":
        this._y = Math.asin(-un(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(m, v), this._z = Math.atan2(c, s)) : (this._x = 0, this._z = Math.atan2(-o, f));
        break;
      case "YZX":
        this._z = Math.asin(un(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._y = Math.atan2(-d, s)) : (this._x = 0, this._y = Math.atan2(l, v));
        break;
      case "XZY":
        this._z = Math.asin(-un(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(m, f), this._y = Math.atan2(l, s)) : (this._x = Math.atan2(-h, v), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return FS.makeRotationFromQuaternion(e), this.setFromRotationMatrix(FS, t, i);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return zS.setFromEuler(this), this.setFromQuaternion(zS, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
jc.DEFAULT_ORDER = "XYZ";
class na {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let GL = 0;
const BS = /* @__PURE__ */ new D(), Ha = /* @__PURE__ */ new Qn(), is = /* @__PURE__ */ new dt(), Mh = /* @__PURE__ */ new D(), Ru = /* @__PURE__ */ new D(), WL = /* @__PURE__ */ new D(), XL = /* @__PURE__ */ new Qn(), HS = /* @__PURE__ */ new D(1, 0, 0), VS = /* @__PURE__ */ new D(0, 1, 0), GS = /* @__PURE__ */ new D(0, 0, 1), jL = { type: "added" }, WS = { type: "removed" };
class It extends Ts {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: GL++ }), this.uuid = Oi(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = It.DEFAULT_UP.clone();
    const e = new D(), t = new jc(), i = new Qn(), r = new D(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(s), i._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      modelViewMatrix: {
        value: new dt()
      },
      normalMatrix: {
        value: new _t()
      }
    }), this.matrix = new dt(), this.matrixWorld = new dt(), this.matrixAutoUpdate = It.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = It.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new na(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Ha.setFromAxisAngle(e, t), this.quaternion.multiply(Ha), this;
  }
  rotateOnWorldAxis(e, t) {
    return Ha.setFromAxisAngle(e, t), this.quaternion.premultiply(Ha), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(HS, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(VS, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(GS, e);
  }
  translateOnAxis(e, t) {
    return BS.copy(e).applyQuaternion(this.quaternion), this.position.add(BS.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(HS, e);
  }
  translateY(e) {
    return this.translateOnAxis(VS, e);
  }
  translateZ(e) {
    return this.translateOnAxis(GS, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(is.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, i) {
    e.isVector3 ? Mh.copy(e) : Mh.set(e, t, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), Ru.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? is.lookAt(Ru, Mh, this.up) : is.lookAt(Mh, Ru, this.up), this.quaternion.setFromRotationMatrix(is), r && (is.extractRotation(r.matrixWorld), Ha.setFromRotationMatrix(is), this.quaternion.premultiply(Ha.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(jL)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(WS)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      t.parent = null, t.dispatchEvent(WS);
    }
    return this.children.length = 0, this;
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), is.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), is.multiply(e.parent.matrixWorld)), e.applyMatrix4(is), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  }
  getObjectsByProperty(e, t) {
    let i = [];
    this[e] === t && i.push(this);
    for (let r = 0, s = this.children.length; r < s; r++) {
      const o = this.children[r].getObjectsByProperty(e, t);
      o.length > 0 && (i = i.concat(o));
    }
    return i;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ru, e, WL), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ru, XL, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++)
      t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++)
      t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) {
        const l = r[s];
        l.matrixWorldAutoUpdate === !0 && l.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", i = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, i.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON()));
    function s(l, c) {
      return l[c.uuid] === void 0 && (l[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const c = l.shapes;
        if (Array.isArray(c))
          for (let f = 0, h = c.length; f < h; f++) {
            const d = c[f];
            s(e.shapes, d);
          }
        else
          s(e.shapes, c);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let c = 0, f = this.material.length; c < f; c++)
          l.push(s(e.materials, this.material[c]));
        r.material = l;
      } else
        r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let l = 0; l < this.children.length; l++)
        r.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const c = this.animations[l];
        r.animations.push(s(e.animations, c));
      }
    }
    if (t) {
      const l = o(e.geometries), c = o(e.materials), f = o(e.textures), h = o(e.images), d = o(e.shapes), m = o(e.skeletons), v = o(e.animations), _ = o(e.nodes);
      l.length > 0 && (i.geometries = l), c.length > 0 && (i.materials = c), f.length > 0 && (i.textures = f), h.length > 0 && (i.images = h), d.length > 0 && (i.shapes = d), m.length > 0 && (i.skeletons = m), v.length > 0 && (i.animations = v), _.length > 0 && (i.nodes = _);
    }
    return i.object = r, i;
    function o(l) {
      const c = [];
      for (const f in l) {
        const h = l[f];
        delete h.metadata, c.push(h);
      }
      return c;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
It.DEFAULT_UP = /* @__PURE__ */ new D(0, 1, 0);
It.DEFAULT_MATRIX_AUTO_UPDATE = !0;
It.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ur = /* @__PURE__ */ new D(), rs = /* @__PURE__ */ new D(), zg = /* @__PURE__ */ new D(), ss = /* @__PURE__ */ new D(), Va = /* @__PURE__ */ new D(), Ga = /* @__PURE__ */ new D(), XS = /* @__PURE__ */ new D(), Bg = /* @__PURE__ */ new D(), Hg = /* @__PURE__ */ new D(), Vg = /* @__PURE__ */ new D();
let wh = !1;
class gi {
  constructor(e = new D(), t = new D(), i = new D()) {
    this.a = e, this.b = t, this.c = i;
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), ur.subVectors(e, t), r.cross(ur);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, i, r, s) {
    ur.subVectors(r, t), rs.subVectors(i, t), zg.subVectors(e, t);
    const o = ur.dot(ur), l = ur.dot(rs), c = ur.dot(zg), f = rs.dot(rs), h = rs.dot(zg), d = o * f - l * l;
    if (d === 0)
      return s.set(-2, -1, -1);
    const m = 1 / d, v = (f * c - l * h) * m, _ = (o * h - l * c) * m;
    return s.set(1 - v - _, _, v);
  }
  static containsPoint(e, t, i, r) {
    return this.getBarycoord(e, t, i, r, ss), ss.x >= 0 && ss.y >= 0 && ss.x + ss.y <= 1;
  }
  static getUV(e, t, i, r, s, o, l, c) {
    return wh === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), wh = !0), this.getInterpolation(e, t, i, r, s, o, l, c);
  }
  static getInterpolation(e, t, i, r, s, o, l, c) {
    return this.getBarycoord(e, t, i, r, ss), c.setScalar(0), c.addScaledVector(s, ss.x), c.addScaledVector(o, ss.y), c.addScaledVector(l, ss.z), c;
  }
  static isFrontFacing(e, t, i, r) {
    return ur.subVectors(i, t), rs.subVectors(e, t), ur.cross(rs).dot(r) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return ur.subVectors(this.c, this.b), rs.subVectors(this.a, this.b), ur.cross(rs).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return gi.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return gi.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, i, r, s) {
    return wh === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), wh = !0), gi.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  getInterpolation(e, t, i, r, s) {
    return gi.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return gi.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return gi.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a, r = this.b, s = this.c;
    let o, l;
    Va.subVectors(r, i), Ga.subVectors(s, i), Bg.subVectors(e, i);
    const c = Va.dot(Bg), f = Ga.dot(Bg);
    if (c <= 0 && f <= 0)
      return t.copy(i);
    Hg.subVectors(e, r);
    const h = Va.dot(Hg), d = Ga.dot(Hg);
    if (h >= 0 && d <= h)
      return t.copy(r);
    const m = c * d - h * f;
    if (m <= 0 && c >= 0 && h <= 0)
      return o = c / (c - h), t.copy(i).addScaledVector(Va, o);
    Vg.subVectors(e, s);
    const v = Va.dot(Vg), _ = Ga.dot(Vg);
    if (_ >= 0 && v <= _)
      return t.copy(s);
    const w = v * f - c * _;
    if (w <= 0 && f >= 0 && _ <= 0)
      return l = f / (f - _), t.copy(i).addScaledVector(Ga, l);
    const M = h * _ - v * d;
    if (M <= 0 && d - h >= 0 && v - _ >= 0)
      return XS.subVectors(s, r), l = (d - h) / (d - h + (v - _)), t.copy(r).addScaledVector(XS, l);
    const g = 1 / (M + w + m);
    return o = w * g, l = m * g, t.copy(i).addScaledVector(Va, o).addScaledVector(Ga, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let YL = 0;
class ei extends Ts {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: YL++ }), this.uuid = Oi(), this.name = "", this.type = "Material", this.blending = ea, this.side = Ms, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Qy, this.blendDst = $y, this.blendEquation = Go, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = $d, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = PA, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Ad, this.stencilZFail = Ad, this.stencilZPass = Ad, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== ea && (i.blending = this.blending), this.side !== Ms && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = this.alphaHash), this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (i.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = this.flatShading), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(s) {
      const o = [];
      for (const l in s) {
        const c = s[l];
        delete c.metadata, o.push(c);
      }
      return o;
    }
    if (t) {
      const s = r(e.textures), o = r(e.images);
      s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s)
        i[s] = t[s].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const HA = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, cr = { h: 0, s: 0, l: 0 }, Eh = { h: 0, s: 0, l: 0 };
function Gg(n, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n;
}
class ze {
  constructor(e, t, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i);
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const r = e;
      r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
    } else
      this.setRGB(e, t, i);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = pt) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Zi.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, i, r = Zi.workingColorSpace) {
    return this.r = e, this.g = t, this.b = i, Zi.toWorkingColorSpace(this, r), this;
  }
  setHSL(e, t, i, r = Zi.workingColorSpace) {
    if (e = f_(e, 1), t = un(t, 0, 1), i = un(i, 0, 1), t === 0)
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t, o = 2 * i - s;
      this.r = Gg(o, s, e + 1 / 3), this.g = Gg(o, s, e), this.b = Gg(o, s, e - 1 / 3);
    }
    return Zi.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = pt) {
    function i(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let s;
      const o = r[1], l = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(s[4]), this.setRGB(
              Math.min(255, parseInt(s[1], 10)) / 255,
              Math.min(255, parseInt(s[2], 10)) / 255,
              Math.min(255, parseInt(s[3], 10)) / 255,
              t
            );
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(s[4]), this.setRGB(
              Math.min(100, parseInt(s[1], 10)) / 100,
              Math.min(100, parseInt(s[2], 10)) / 100,
              Math.min(100, parseInt(s[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(s[4]), this.setHSL(
              parseFloat(s[1]) / 360,
              parseFloat(s[2]) / 100,
              parseFloat(s[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const s = r[1], o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (o === 6)
        return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = pt) {
    const i = HA[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Ll(e.r), this.g = Ll(e.g), this.b = Ll(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Lg(e.r), this.g = Lg(e.g), this.b = Lg(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = pt) {
    return Zi.fromWorkingColorSpace(Zn.copy(this), e), Math.round(un(Zn.r * 255, 0, 255)) * 65536 + Math.round(un(Zn.g * 255, 0, 255)) * 256 + Math.round(un(Zn.b * 255, 0, 255));
  }
  getHexString(e = pt) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Zi.workingColorSpace) {
    Zi.fromWorkingColorSpace(Zn.copy(this), t);
    const i = Zn.r, r = Zn.g, s = Zn.b, o = Math.max(i, r, s), l = Math.min(i, r, s);
    let c, f;
    const h = (l + o) / 2;
    if (l === o)
      c = 0, f = 0;
    else {
      const d = o - l;
      switch (f = h <= 0.5 ? d / (o + l) : d / (2 - o - l), o) {
        case i:
          c = (r - s) / d + (r < s ? 6 : 0);
          break;
        case r:
          c = (s - i) / d + 2;
          break;
        case s:
          c = (i - r) / d + 4;
          break;
      }
      c /= 6;
    }
    return e.h = c, e.s = f, e.l = h, e;
  }
  getRGB(e, t = Zi.workingColorSpace) {
    return Zi.fromWorkingColorSpace(Zn.copy(this), t), e.r = Zn.r, e.g = Zn.g, e.b = Zn.b, e;
  }
  getStyle(e = pt) {
    Zi.fromWorkingColorSpace(Zn.copy(this), e);
    const t = Zn.r, i = Zn.g, r = Zn.b;
    return e !== pt ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`;
  }
  offsetHSL(e, t, i) {
    return this.getHSL(cr), cr.h += e, cr.s += t, cr.l += i, this.setHSL(cr.h, cr.s, cr.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, i) {
    return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this;
  }
  lerpHSL(e, t) {
    this.getHSL(cr), e.getHSL(Eh);
    const i = tc(cr.h, Eh.h, t), r = tc(cr.s, Eh.s, t), s = tc(cr.l, Eh.l, t);
    return this.setHSL(i, r, s), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, i = this.g, r = this.b, s = e.elements;
    return this.r = s[0] * t + s[3] * i + s[6] * r, this.g = s[1] * t + s[4] * i + s[7] * r, this.b = s[2] * t + s[5] * i + s[8] * r, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Zn = /* @__PURE__ */ new ze();
ze.NAMES = HA;
class vo extends ei {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new ze(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Xc, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const hs = /* @__PURE__ */ qL();
function qL() {
  const n = new ArrayBuffer(4), e = new Float32Array(n), t = new Uint32Array(n), i = new Uint32Array(512), r = new Uint32Array(512);
  for (let c = 0; c < 256; ++c) {
    const f = c - 127;
    f < -27 ? (i[c] = 0, i[c | 256] = 32768, r[c] = 24, r[c | 256] = 24) : f < -14 ? (i[c] = 1024 >> -f - 14, i[c | 256] = 1024 >> -f - 14 | 32768, r[c] = -f - 1, r[c | 256] = -f - 1) : f <= 15 ? (i[c] = f + 15 << 10, i[c | 256] = f + 15 << 10 | 32768, r[c] = 13, r[c | 256] = 13) : f < 128 ? (i[c] = 31744, i[c | 256] = 64512, r[c] = 24, r[c | 256] = 24) : (i[c] = 31744, i[c | 256] = 64512, r[c] = 13, r[c | 256] = 13);
  }
  const s = new Uint32Array(2048), o = new Uint32Array(64), l = new Uint32Array(64);
  for (let c = 1; c < 1024; ++c) {
    let f = c << 13, h = 0;
    for (; !(f & 8388608); )
      f <<= 1, h -= 8388608;
    f &= -8388609, h += 947912704, s[c] = f | h;
  }
  for (let c = 1024; c < 2048; ++c)
    s[c] = 939524096 + (c - 1024 << 13);
  for (let c = 1; c < 31; ++c)
    o[c] = c << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let c = 33; c < 63; ++c)
    o[c] = 2147483648 + (c - 32 << 23);
  o[63] = 3347054592;
  for (let c = 1; c < 64; ++c)
    c !== 32 && (l[c] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: l
  };
}
function pi(n) {
  Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n = un(n, -65504, 65504), hs.floatView[0] = n;
  const e = hs.uint32View[0], t = e >> 23 & 511;
  return hs.baseTable[t] + ((e & 8388607) >> hs.shiftTable[t]);
}
function Vu(n) {
  const e = n >> 10;
  return hs.uint32View[0] = hs.mantissaTable[hs.offsetTable[e] + (n & 1023)] + hs.exponentTable[e], hs.floatView[0];
}
const ZL = {
  toHalfFloat: pi,
  fromHalfFloat: Vu
}, _n = /* @__PURE__ */ new D(), Th = /* @__PURE__ */ new me();
class Ht {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = Pc, this.updateRange = { offset: 0, count: -1 }, this.gpuType = kr, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, i) {
    e *= this.itemSize, i *= t.itemSize;
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        Th.fromBufferAttribute(this, t), Th.applyMatrix3(e), this.setXY(t, Th.x, Th.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        _n.fromBufferAttribute(this, t), _n.applyMatrix3(e), this.setXYZ(t, _n.x, _n.y, _n.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      _n.fromBufferAttribute(this, t), _n.applyMatrix4(e), this.setXYZ(t, _n.x, _n.y, _n.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      _n.fromBufferAttribute(this, t), _n.applyNormalMatrix(e), this.setXYZ(t, _n.x, _n.y, _n.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      _n.fromBufferAttribute(this, t), _n.transformDirection(e), this.setXYZ(t, _n.x, _n.y, _n.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = xt(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = xt(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = xt(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = xt(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = xt(t, this.array), i = xt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, r) {
    return e *= this.itemSize, this.normalized && (t = xt(t, this.array), i = xt(i, this.array), r = xt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this;
  }
  setXYZW(e, t, i, r, s) {
    return e *= this.itemSize, this.normalized && (t = xt(t, this.array), i = xt(i, this.array), r = xt(r, this.array), s = xt(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Pc && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
class KL extends Ht {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i);
  }
}
class JL extends Ht {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i);
  }
}
class QL extends Ht {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i);
  }
}
class $L extends Ht {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i);
  }
}
class p_ extends Ht {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class e3 extends Ht {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i);
  }
}
class m_ extends Ht {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class t3 extends Ht {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = Vu(this.array[e * this.itemSize]);
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = xt(t, this.array)), this.array[e * this.itemSize] = pi(t), this;
  }
  getY(e) {
    let t = Vu(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = xt(t, this.array)), this.array[e * this.itemSize + 1] = pi(t), this;
  }
  getZ(e) {
    let t = Vu(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = xt(t, this.array)), this.array[e * this.itemSize + 2] = pi(t), this;
  }
  getW(e) {
    let t = Vu(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = xt(t, this.array)), this.array[e * this.itemSize + 3] = pi(t), this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = xt(t, this.array), i = xt(i, this.array)), this.array[e + 0] = pi(t), this.array[e + 1] = pi(i), this;
  }
  setXYZ(e, t, i, r) {
    return e *= this.itemSize, this.normalized && (t = xt(t, this.array), i = xt(i, this.array), r = xt(r, this.array)), this.array[e + 0] = pi(t), this.array[e + 1] = pi(i), this.array[e + 2] = pi(r), this;
  }
  setXYZW(e, t, i, r, s) {
    return e *= this.itemSize, this.normalized && (t = xt(t, this.array), i = xt(i, this.array), r = xt(r, this.array), s = xt(s, this.array)), this.array[e + 0] = pi(t), this.array[e + 1] = pi(i), this.array[e + 2] = pi(r), this.array[e + 3] = pi(s), this;
  }
}
class Ye extends Ht {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
class n3 extends Ht {
  constructor(e, t, i) {
    super(new Float64Array(e), t, i);
  }
}
let i3 = 0;
const qi = /* @__PURE__ */ new dt(), Wg = /* @__PURE__ */ new It(), Wa = /* @__PURE__ */ new D(), bi = /* @__PURE__ */ new jr(), Pu = /* @__PURE__ */ new jr(), In = /* @__PURE__ */ new D();
class wt extends Ts {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: i3++ }), this.uuid = Oi(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (BA(e) ? m_ : p_)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: i
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new _t().getNormalMatrix(e);
      i.applyNormalMatrix(s), i.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return qi.makeRotationFromQuaternion(e), this.applyMatrix4(qi), this;
  }
  rotateX(e) {
    return qi.makeRotationX(e), this.applyMatrix4(qi), this;
  }
  rotateY(e) {
    return qi.makeRotationY(e), this.applyMatrix4(qi), this;
  }
  rotateZ(e) {
    return qi.makeRotationZ(e), this.applyMatrix4(qi), this;
  }
  translate(e, t, i) {
    return qi.makeTranslation(e, t, i), this.applyMatrix4(qi), this;
  }
  scale(e, t, i) {
    return qi.makeScale(e, t, i), this.applyMatrix4(qi), this;
  }
  lookAt(e) {
    return Wg.lookAt(e), Wg.updateMatrix(), this.applyMatrix4(Wg.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Wa).negate(), this.translate(Wa.x, Wa.y, Wa.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Ye(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new jr());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new D(-1 / 0, -1 / 0, -1 / 0),
        new D(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i];
          bi.setFromBufferAttribute(s), this.morphTargetsRelative ? (In.addVectors(this.boundingBox.min, bi.min), this.boundingBox.expandByPoint(In), In.addVectors(this.boundingBox.max, bi.max), this.boundingBox.expandByPoint(In)) : (this.boundingBox.expandByPoint(bi.min), this.boundingBox.expandByPoint(bi.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new wr());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new D(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (bi.setFromBufferAttribute(e), t)
        for (let s = 0, o = t.length; s < o; s++) {
          const l = t[s];
          Pu.setFromBufferAttribute(l), this.morphTargetsRelative ? (In.addVectors(bi.min, Pu.min), bi.expandByPoint(In), In.addVectors(bi.max, Pu.max), bi.expandByPoint(In)) : (bi.expandByPoint(Pu.min), bi.expandByPoint(Pu.max));
        }
      bi.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        In.fromBufferAttribute(e, s), r = Math.max(r, i.distanceToSquared(In));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const l = t[s], c = this.morphTargetsRelative;
          for (let f = 0, h = l.count; f < h; f++)
            In.fromBufferAttribute(l, f), c && (Wa.fromBufferAttribute(e, f), In.add(Wa)), r = Math.max(r, i.distanceToSquared(In));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = e.array, r = t.position.array, s = t.normal.array, o = t.uv.array, l = r.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Ht(new Float32Array(4 * l), 4));
    const c = this.getAttribute("tangent").array, f = [], h = [];
    for (let b = 0; b < l; b++)
      f[b] = new D(), h[b] = new D();
    const d = new D(), m = new D(), v = new D(), _ = new me(), w = new me(), M = new me(), g = new D(), x = new D();
    function S(b, G, $) {
      d.fromArray(r, b * 3), m.fromArray(r, G * 3), v.fromArray(r, $ * 3), _.fromArray(o, b * 2), w.fromArray(o, G * 2), M.fromArray(o, $ * 2), m.sub(d), v.sub(d), w.sub(_), M.sub(_);
      const Y = 1 / (w.x * M.y - M.x * w.y);
      isFinite(Y) && (g.copy(m).multiplyScalar(M.y).addScaledVector(v, -w.y).multiplyScalar(Y), x.copy(v).multiplyScalar(w.x).addScaledVector(m, -M.x).multiplyScalar(Y), f[b].add(g), f[G].add(g), f[$].add(g), h[b].add(x), h[G].add(x), h[$].add(x));
    }
    let T = this.groups;
    T.length === 0 && (T = [{
      start: 0,
      count: i.length
    }]);
    for (let b = 0, G = T.length; b < G; ++b) {
      const $ = T[b], Y = $.start, K = $.count;
      for (let J = Y, oe = Y + K; J < oe; J += 3)
        S(
          i[J + 0],
          i[J + 1],
          i[J + 2]
        );
    }
    const C = new D(), P = new D(), L = new D(), N = new D();
    function R(b) {
      L.fromArray(s, b * 3), N.copy(L);
      const G = f[b];
      C.copy(G), C.sub(L.multiplyScalar(L.dot(G))).normalize(), P.crossVectors(N, G);
      const Y = P.dot(h[b]) < 0 ? -1 : 1;
      c[b * 4] = C.x, c[b * 4 + 1] = C.y, c[b * 4 + 2] = C.z, c[b * 4 + 3] = Y;
    }
    for (let b = 0, G = T.length; b < G; ++b) {
      const $ = T[b], Y = $.start, K = $.count;
      for (let J = Y, oe = Y + K; J < oe; J += 3)
        R(i[J + 0]), R(i[J + 1]), R(i[J + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new Ht(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
      else
        for (let m = 0, v = i.count; m < v; m++)
          i.setXYZ(m, 0, 0, 0);
      const r = new D(), s = new D(), o = new D(), l = new D(), c = new D(), f = new D(), h = new D(), d = new D();
      if (e)
        for (let m = 0, v = e.count; m < v; m += 3) {
          const _ = e.getX(m + 0), w = e.getX(m + 1), M = e.getX(m + 2);
          r.fromBufferAttribute(t, _), s.fromBufferAttribute(t, w), o.fromBufferAttribute(t, M), h.subVectors(o, s), d.subVectors(r, s), h.cross(d), l.fromBufferAttribute(i, _), c.fromBufferAttribute(i, w), f.fromBufferAttribute(i, M), l.add(h), c.add(h), f.add(h), i.setXYZ(_, l.x, l.y, l.z), i.setXYZ(w, c.x, c.y, c.z), i.setXYZ(M, f.x, f.y, f.z);
        }
      else
        for (let m = 0, v = t.count; m < v; m += 3)
          r.fromBufferAttribute(t, m + 0), s.fromBufferAttribute(t, m + 1), o.fromBufferAttribute(t, m + 2), h.subVectors(o, s), d.subVectors(r, s), h.cross(d), i.setXYZ(m + 0, h.x, h.y, h.z), i.setXYZ(m + 1, h.x, h.y, h.z), i.setXYZ(m + 2, h.x, h.y, h.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      In.fromBufferAttribute(e, t), In.normalize(), e.setXYZ(t, In.x, In.y, In.z);
  }
  toNonIndexed() {
    function e(l, c) {
      const f = l.array, h = l.itemSize, d = l.normalized, m = new f.constructor(c.length * h);
      let v = 0, _ = 0;
      for (let w = 0, M = c.length; w < M; w++) {
        l.isInterleavedBufferAttribute ? v = c[w] * l.data.stride + l.offset : v = c[w] * h;
        for (let g = 0; g < h; g++)
          m[_++] = f[v++];
      }
      return new Ht(m, h, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new wt(), i = this.index.array, r = this.attributes;
    for (const l in r) {
      const c = r[l], f = e(c, i);
      t.setAttribute(l, f);
    }
    const s = this.morphAttributes;
    for (const l in s) {
      const c = [], f = s[l];
      for (let h = 0, d = f.length; h < d; h++) {
        const m = f[h], v = e(m, i);
        c.push(v);
      }
      t.morphAttributes[l] = c;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let l = 0, c = o.length; l < c; l++) {
      const f = o[l];
      t.addGroup(f.start, f.count, f.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const c = this.parameters;
      for (const f in c)
        c[f] !== void 0 && (e[f] = c[f]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const i = this.attributes;
    for (const c in i) {
      const f = i[c];
      e.data.attributes[c] = f.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const c in this.morphAttributes) {
      const f = this.morphAttributes[c], h = [];
      for (let d = 0, m = f.length; d < m; d++) {
        const v = f[d];
        h.push(v.toJSON(e.data));
      }
      h.length > 0 && (r[c] = h, s = !0);
    }
    s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const r = e.attributes;
    for (const f in r) {
      const h = r[f];
      this.setAttribute(f, h.clone(t));
    }
    const s = e.morphAttributes;
    for (const f in s) {
      const h = [], d = s[f];
      for (let m = 0, v = d.length; m < v; m++)
        h.push(d[m].clone(t));
      this.morphAttributes[f] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let f = 0, h = o.length; f < h; f++) {
      const d = o[f];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const c = e.boundingSphere;
    return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const jS = /* @__PURE__ */ new dt(), Lo = /* @__PURE__ */ new ma(), Ah = /* @__PURE__ */ new wr(), YS = /* @__PURE__ */ new D(), Xa = /* @__PURE__ */ new D(), ja = /* @__PURE__ */ new D(), Ya = /* @__PURE__ */ new D(), Xg = /* @__PURE__ */ new D(), Ch = /* @__PURE__ */ new D(), Rh = /* @__PURE__ */ new me(), Ph = /* @__PURE__ */ new me(), bh = /* @__PURE__ */ new me(), qS = /* @__PURE__ */ new D(), ZS = /* @__PURE__ */ new D(), KS = /* @__PURE__ */ new D(), Lh = /* @__PURE__ */ new D(), Ih = /* @__PURE__ */ new D();
class kn extends It {
  constructor(e = new wt(), t = new vo()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const l = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = s;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry, r = i.attributes.position, s = i.morphAttributes.position, o = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const l = this.morphTargetInfluences;
    if (s && l) {
      Ch.set(0, 0, 0);
      for (let c = 0, f = s.length; c < f; c++) {
        const h = l[c], d = s[c];
        h !== 0 && (Xg.fromBufferAttribute(d, e), o ? Ch.addScaledVector(Xg, h) : Ch.addScaledVector(Xg.sub(t), h));
      }
      t.add(Ch);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.material, s = this.matrixWorld;
    r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), Ah.copy(i.boundingSphere), Ah.applyMatrix4(s), Lo.copy(e.ray).recast(e.near), !(Ah.containsPoint(Lo.origin) === !1 && (Lo.intersectSphere(Ah, YS) === null || Lo.origin.distanceToSquared(YS) > (e.far - e.near) ** 2)) && (jS.copy(s).invert(), Lo.copy(e.ray).applyMatrix4(jS), !(i.boundingBox !== null && Lo.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, Lo)));
  }
  _computeIntersections(e, t, i) {
    let r;
    const s = this.geometry, o = this.material, l = s.index, c = s.attributes.position, f = s.attributes.uv, h = s.attributes.uv1, d = s.attributes.normal, m = s.groups, v = s.drawRange;
    if (l !== null)
      if (Array.isArray(o))
        for (let _ = 0, w = m.length; _ < w; _++) {
          const M = m[_], g = o[M.materialIndex], x = Math.max(M.start, v.start), S = Math.min(l.count, Math.min(M.start + M.count, v.start + v.count));
          for (let T = x, C = S; T < C; T += 3) {
            const P = l.getX(T), L = l.getX(T + 1), N = l.getX(T + 2);
            r = Nh(this, g, e, i, f, h, d, P, L, N), r && (r.faceIndex = Math.floor(T / 3), r.face.materialIndex = M.materialIndex, t.push(r));
          }
        }
      else {
        const _ = Math.max(0, v.start), w = Math.min(l.count, v.start + v.count);
        for (let M = _, g = w; M < g; M += 3) {
          const x = l.getX(M), S = l.getX(M + 1), T = l.getX(M + 2);
          r = Nh(this, o, e, i, f, h, d, x, S, T), r && (r.faceIndex = Math.floor(M / 3), t.push(r));
        }
      }
    else if (c !== void 0)
      if (Array.isArray(o))
        for (let _ = 0, w = m.length; _ < w; _++) {
          const M = m[_], g = o[M.materialIndex], x = Math.max(M.start, v.start), S = Math.min(c.count, Math.min(M.start + M.count, v.start + v.count));
          for (let T = x, C = S; T < C; T += 3) {
            const P = T, L = T + 1, N = T + 2;
            r = Nh(this, g, e, i, f, h, d, P, L, N), r && (r.faceIndex = Math.floor(T / 3), r.face.materialIndex = M.materialIndex, t.push(r));
          }
        }
      else {
        const _ = Math.max(0, v.start), w = Math.min(c.count, v.start + v.count);
        for (let M = _, g = w; M < g; M += 3) {
          const x = M, S = M + 1, T = M + 2;
          r = Nh(this, o, e, i, f, h, d, x, S, T), r && (r.faceIndex = Math.floor(M / 3), t.push(r));
        }
      }
  }
}
function r3(n, e, t, i, r, s, o, l) {
  let c;
  if (e.side === ai ? c = i.intersectTriangle(o, s, r, !0, l) : c = i.intersectTriangle(r, s, o, e.side === Ms, l), c === null)
    return null;
  Ih.copy(l), Ih.applyMatrix4(n.matrixWorld);
  const f = t.ray.origin.distanceTo(Ih);
  return f < t.near || f > t.far ? null : {
    distance: f,
    point: Ih.clone(),
    object: n
  };
}
function Nh(n, e, t, i, r, s, o, l, c, f) {
  n.getVertexPosition(l, Xa), n.getVertexPosition(c, ja), n.getVertexPosition(f, Ya);
  const h = r3(n, e, t, i, Xa, ja, Ya, Lh);
  if (h) {
    r && (Rh.fromBufferAttribute(r, l), Ph.fromBufferAttribute(r, c), bh.fromBufferAttribute(r, f), h.uv = gi.getInterpolation(Lh, Xa, ja, Ya, Rh, Ph, bh, new me())), s && (Rh.fromBufferAttribute(s, l), Ph.fromBufferAttribute(s, c), bh.fromBufferAttribute(s, f), h.uv1 = gi.getInterpolation(Lh, Xa, ja, Ya, Rh, Ph, bh, new me()), h.uv2 = h.uv1), o && (qS.fromBufferAttribute(o, l), ZS.fromBufferAttribute(o, c), KS.fromBufferAttribute(o, f), h.normal = gi.getInterpolation(Lh, Xa, ja, Ya, qS, ZS, KS, new D()), h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
    const d = {
      a: l,
      b: c,
      c: f,
      normal: new D(),
      materialIndex: 0
    };
    gi.getNormal(Xa, ja, Ya, d.normal), h.face = d;
  }
  return h;
}
class ga extends wt {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: i,
      widthSegments: r,
      heightSegments: s,
      depthSegments: o
    };
    const l = this;
    r = Math.floor(r), s = Math.floor(s), o = Math.floor(o);
    const c = [], f = [], h = [], d = [];
    let m = 0, v = 0;
    _("z", "y", "x", -1, -1, i, t, e, o, s, 0), _("z", "y", "x", 1, -1, i, t, -e, o, s, 1), _("x", "z", "y", 1, 1, e, i, t, r, o, 2), _("x", "z", "y", 1, -1, e, i, -t, r, o, 3), _("x", "y", "z", 1, -1, e, t, i, r, s, 4), _("x", "y", "z", -1, -1, e, t, -i, r, s, 5), this.setIndex(c), this.setAttribute("position", new Ye(f, 3)), this.setAttribute("normal", new Ye(h, 3)), this.setAttribute("uv", new Ye(d, 2));
    function _(w, M, g, x, S, T, C, P, L, N, R) {
      const b = T / L, G = C / N, $ = T / 2, Y = C / 2, K = P / 2, J = L + 1, oe = N + 1;
      let ne = 0, O = 0;
      const X = new D();
      for (let W = 0; W < oe; W++) {
        const V = W * G - Y;
        for (let j = 0; j < J; j++) {
          const de = j * b - $;
          X[w] = de * x, X[M] = V * S, X[g] = K, f.push(X.x, X.y, X.z), X[w] = 0, X[M] = 0, X[g] = P > 0 ? 1 : -1, h.push(X.x, X.y, X.z), d.push(j / L), d.push(1 - W / N), ne += 1;
        }
      }
      for (let W = 0; W < N; W++)
        for (let V = 0; V < L; V++) {
          const j = m + V + J * W, de = m + V + J * (W + 1), ye = m + (V + 1) + J * (W + 1), Te = m + (V + 1) + J * W;
          c.push(j, de, Te), c.push(de, ye, Te), O += 6;
        }
      l.addGroup(v, O, R), v += O, m += ne;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new ga(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Vl(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const i in n[t]) {
      const r = n[t][i];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r;
    }
  }
  return e;
}
function ri(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = Vl(n[t]);
    for (const r in i)
      e[r] = i[r];
  }
  return e;
}
function s3(n) {
  const e = [];
  for (let t = 0; t < n.length; t++)
    e.push(n[t].clone());
  return e;
}
function VA(n) {
  return n.getRenderTarget() === null ? n.outputColorSpace : Sr;
}
const GA = { clone: Vl, merge: ri };
var o3 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, a3 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Wr extends ei {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = o3, this.fragmentShader = a3, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1
      // set to use shader texture LOD
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Vl(e.uniforms), this.uniformsGroups = s3(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture ? t.uniforms[r] = {
        type: "t",
        value: o.toJSON(e).uuid
      } : o && o.isColor ? t.uniforms[r] = {
        type: "c",
        value: o.getHex()
      } : o && o.isVector2 ? t.uniforms[r] = {
        type: "v2",
        value: o.toArray()
      } : o && o.isVector3 ? t.uniforms[r] = {
        type: "v3",
        value: o.toArray()
      } : o && o.isVector4 ? t.uniforms[r] = {
        type: "v4",
        value: o.toArray()
      } : o && o.isMatrix3 ? t.uniforms[r] = {
        type: "m3",
        value: o.toArray()
      } : o && o.isMatrix4 ? t.uniforms[r] = {
        type: "m4",
        value: o.toArray()
      } : t.uniforms[r] = {
        value: o
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const i = {};
    for (const r in this.extensions)
      this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class Yc extends It {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new dt(), this.projectionMatrix = new dt(), this.projectionMatrixInverse = new dt(), this.coordinateSystem = Fr;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Qt extends Yc {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = Hl * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(ta * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return Hl * 2 * Math.atan(
      Math.tan(ta * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, i, r, s, o) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(ta * 0.5 * this.fov) / this.zoom, i = 2 * t, r = this.aspect * i, s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = o.fullWidth, f = o.fullHeight;
      s += o.offsetX * r / c, t -= o.offsetY * i / f, r *= o.width / c, i *= o.height / f;
    }
    const l = this.filmOffset;
    l !== 0 && (s += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const qa = -90, Za = 1;
class WA extends It {
  constructor(e, t, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null;
    const r = new Qt(qa, Za, e, t);
    r.layers = this.layers, this.add(r);
    const s = new Qt(qa, Za, e, t);
    s.layers = this.layers, this.add(s);
    const o = new Qt(qa, Za, e, t);
    o.layers = this.layers, this.add(o);
    const l = new Qt(qa, Za, e, t);
    l.layers = this.layers, this.add(l);
    const c = new Qt(qa, Za, e, t);
    c.layers = this.layers, this.add(c);
    const f = new Qt(qa, Za, e, t);
    f.layers = this.layers, this.add(f);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [i, r, s, o, l, c] = t;
    for (const f of t)
      this.remove(f);
    if (e === Fr)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
    else if (e === bc)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), l.up.set(0, -1, 0), l.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const f of t)
      this.add(f), f.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const i = this.renderTarget;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [r, s, o, l, c, f] = this.children, h = e.getRenderTarget(), d = e.toneMapping, m = e.xr.enabled;
    e.toneMapping = _r, e.xr.enabled = !1;
    const v = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0), e.render(t, r), e.setRenderTarget(i, 1), e.render(t, s), e.setRenderTarget(i, 2), e.render(t, o), e.setRenderTarget(i, 3), e.render(t, l), e.setRenderTarget(i, 4), e.render(t, c), i.texture.generateMipmaps = v, e.setRenderTarget(i, 5), e.render(t, f), e.setRenderTarget(h), e.toneMapping = d, e.xr.enabled = m, i.texture.needsPMREMUpdate = !0;
  }
}
class qc extends mn {
  constructor(e, t, i, r, s, o, l, c, f, h) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : lo, super(e, t, i, r, s, o, l, c, f, h), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class XA extends Mr {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const i = { width: e, height: e, depth: 1 }, r = [i, i, i, i, i, i];
    t.encoding !== void 0 && (nc("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === ro ? pt : so), this.texture = new qc(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : pn;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, r = new ga(5, 5, 5), s = new Wr({
      name: "CubemapFromEquirect",
      uniforms: Vl(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: ai,
      blending: vs
    });
    s.uniforms.tEquirect.value = t;
    const o = new kn(r, s), l = t.minFilter;
    return t.minFilter === co && (t.minFilter = pn), new WA(1, 10, this).update(e, o), t.minFilter = l, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++)
      e.setRenderTarget(this, o), e.clear(t, i, r);
    e.setRenderTarget(s);
  }
}
const jg = /* @__PURE__ */ new D(), l3 = /* @__PURE__ */ new D(), u3 = /* @__PURE__ */ new _t();
class fs {
  constructor(e = new D(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), this.constant = r, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const r = jg.subVectors(i, t).cross(l3.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(jg), r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return t < 0 && i > 0 || i < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || u3.getNormalMatrix(e), r = this.coplanarPoint(jg).applyMatrix4(e), s = this.normal.applyMatrix3(i).normalize();
    return this.constant = -r.dot(s), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Io = /* @__PURE__ */ new wr(), Dh = /* @__PURE__ */ new D();
class Cp {
  constructor(e = new fs(), t = new fs(), i = new fs(), r = new fs(), s = new fs(), o = new fs()) {
    this.planes = [e, t, i, r, s, o];
  }
  set(e, t, i, r, s, o) {
    const l = this.planes;
    return l[0].copy(e), l[1].copy(t), l[2].copy(i), l[3].copy(r), l[4].copy(s), l[5].copy(o), this;
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = Fr) {
    const i = this.planes, r = e.elements, s = r[0], o = r[1], l = r[2], c = r[3], f = r[4], h = r[5], d = r[6], m = r[7], v = r[8], _ = r[9], w = r[10], M = r[11], g = r[12], x = r[13], S = r[14], T = r[15];
    if (i[0].setComponents(c - s, m - f, M - v, T - g).normalize(), i[1].setComponents(c + s, m + f, M + v, T + g).normalize(), i[2].setComponents(c + o, m + h, M + _, T + x).normalize(), i[3].setComponents(c - o, m - h, M - _, T - x).normalize(), i[4].setComponents(c - l, m - d, M - w, T - S).normalize(), t === Fr)
      i[5].setComponents(c + l, m + d, M + w, T + S).normalize();
    else if (t === bc)
      i[5].setComponents(l, d, w, S).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), Io.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), Io.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Io);
  }
  intersectsSprite(e) {
    return Io.center.set(0, 0, 0), Io.radius = 0.7071067811865476, Io.applyMatrix4(e.matrixWorld), this.intersectsSphere(Io);
  }
  intersectsSphere(e) {
    const t = this.planes, i = e.center, r = -e.radius;
    for (let s = 0; s < 6; s++)
      if (t[s].distanceToPoint(i) < r)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (Dh.x = r.normal.x > 0 ? e.max.x : e.min.x, Dh.y = r.normal.y > 0 ? e.max.y : e.min.y, Dh.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(Dh) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++)
      if (t[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function jA() {
  let n = null, e = !1, t = null, i = null;
  function r(s, o) {
    t(s, o), i = n.requestAnimationFrame(r);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (i = n.requestAnimationFrame(r), e = !0);
    },
    stop: function() {
      n.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function(s) {
      t = s;
    },
    setContext: function(s) {
      n = s;
    }
  };
}
function c3(n, e) {
  const t = e.isWebGL2, i = /* @__PURE__ */ new WeakMap();
  function r(f, h) {
    const d = f.array, m = f.usage, v = n.createBuffer();
    n.bindBuffer(h, v), n.bufferData(h, d, m), f.onUploadCallback();
    let _;
    if (d instanceof Float32Array)
      _ = n.FLOAT;
    else if (d instanceof Uint16Array)
      if (f.isFloat16BufferAttribute)
        if (t)
          _ = n.HALF_FLOAT;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        _ = n.UNSIGNED_SHORT;
    else if (d instanceof Int16Array)
      _ = n.SHORT;
    else if (d instanceof Uint32Array)
      _ = n.UNSIGNED_INT;
    else if (d instanceof Int32Array)
      _ = n.INT;
    else if (d instanceof Int8Array)
      _ = n.BYTE;
    else if (d instanceof Uint8Array)
      _ = n.UNSIGNED_BYTE;
    else if (d instanceof Uint8ClampedArray)
      _ = n.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d);
    return {
      buffer: v,
      type: _,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: f.version
    };
  }
  function s(f, h, d) {
    const m = h.array, v = h.updateRange;
    n.bindBuffer(d, f), v.count === -1 ? n.bufferSubData(d, 0, m) : (t ? n.bufferSubData(
      d,
      v.offset * m.BYTES_PER_ELEMENT,
      m,
      v.offset,
      v.count
    ) : n.bufferSubData(
      d,
      v.offset * m.BYTES_PER_ELEMENT,
      m.subarray(v.offset, v.offset + v.count)
    ), v.count = -1), h.onUploadCallback();
  }
  function o(f) {
    return f.isInterleavedBufferAttribute && (f = f.data), i.get(f);
  }
  function l(f) {
    f.isInterleavedBufferAttribute && (f = f.data);
    const h = i.get(f);
    h && (n.deleteBuffer(h.buffer), i.delete(f));
  }
  function c(f, h) {
    if (f.isGLBufferAttribute) {
      const m = i.get(f);
      (!m || m.version < f.version) && i.set(f, {
        buffer: f.buffer,
        type: f.type,
        bytesPerElement: f.elementSize,
        version: f.version
      });
      return;
    }
    f.isInterleavedBufferAttribute && (f = f.data);
    const d = i.get(f);
    d === void 0 ? i.set(f, r(f, h)) : d.version < f.version && (s(d.buffer, f, h), d.version = f.version);
  }
  return {
    get: o,
    remove: l,
    update: c
  };
}
class Zc extends wt {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: i,
      heightSegments: r
    };
    const s = e / 2, o = t / 2, l = Math.floor(i), c = Math.floor(r), f = l + 1, h = c + 1, d = e / l, m = t / c, v = [], _ = [], w = [], M = [];
    for (let g = 0; g < h; g++) {
      const x = g * m - o;
      for (let S = 0; S < f; S++) {
        const T = S * d - s;
        _.push(T, -x, 0), w.push(0, 0, 1), M.push(S / l), M.push(1 - g / c);
      }
    }
    for (let g = 0; g < c; g++)
      for (let x = 0; x < l; x++) {
        const S = x + f * g, T = x + f * (g + 1), C = x + 1 + f * (g + 1), P = x + 1 + f * g;
        v.push(S, T, P), v.push(T, C, P);
      }
    this.setIndex(v), this.setAttribute("position", new Ye(_, 3)), this.setAttribute("normal", new Ye(w, 3)), this.setAttribute("uv", new Ye(M, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Zc(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var f3 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, h3 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, d3 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, p3 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, m3 = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, g3 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, v3 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, y3 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, _3 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, x3 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, S3 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, M3 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, w3 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, E3 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, T3 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, A3 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, C3 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, R3 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, P3 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, b3 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, L3 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, I3 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, N3 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, D3 = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, U3 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, O3 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, k3 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, F3 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, z3 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", B3 = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, H3 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, V3 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, G3 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, W3 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, X3 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, j3 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, Y3 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, q3 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Z3 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, K3 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, J3 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, Q3 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, $3 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, eI = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, tI = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, nI = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, iI = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, rI = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, sI = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, oI = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, aI = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`, lI = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, uI = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, cI = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, fI = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, hI = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, dI = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, pI = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, mI = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, gI = `#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`, vI = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, yI = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, _I = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, xI = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, SI = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, MI = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, wI = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, EI = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, TI = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, AI = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`, CI = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, RI = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, PI = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, bI = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, LI = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, II = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, NI = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, DI = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, UI = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, OI = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, kI = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, FI = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, zI = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, BI = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, HI = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, VI = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, GI = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, WI = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, XI = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, jI = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, YI = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, qI = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, ZI = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, KI = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, JI = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, QI = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, $I = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, eN = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, tN = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, nN = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, iN = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, rN = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, sN = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, oN = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, aN = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const lN = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, uN = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, cN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, fN = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, hN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, dN = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, pN = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, mN = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, gN = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, vN = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, yN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, _N = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, xN = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, SN = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, MN = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, wN = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, EN = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, TN = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, AN = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, CN = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, RN = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, PN = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, bN = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, LN = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, IN = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, NN = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, DN = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, UN = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, ON = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, kN = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, FN = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, zN = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, BN = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, HN = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, gt = {
  alphahash_fragment: f3,
  alphahash_pars_fragment: h3,
  alphamap_fragment: d3,
  alphamap_pars_fragment: p3,
  alphatest_fragment: m3,
  alphatest_pars_fragment: g3,
  aomap_fragment: v3,
  aomap_pars_fragment: y3,
  begin_vertex: _3,
  beginnormal_vertex: x3,
  bsdfs: S3,
  iridescence_fragment: M3,
  bumpmap_pars_fragment: w3,
  clipping_planes_fragment: E3,
  clipping_planes_pars_fragment: T3,
  clipping_planes_pars_vertex: A3,
  clipping_planes_vertex: C3,
  color_fragment: R3,
  color_pars_fragment: P3,
  color_pars_vertex: b3,
  color_vertex: L3,
  common: I3,
  cube_uv_reflection_fragment: N3,
  defaultnormal_vertex: D3,
  displacementmap_pars_vertex: U3,
  displacementmap_vertex: O3,
  emissivemap_fragment: k3,
  emissivemap_pars_fragment: F3,
  colorspace_fragment: z3,
  colorspace_pars_fragment: B3,
  envmap_fragment: H3,
  envmap_common_pars_fragment: V3,
  envmap_pars_fragment: G3,
  envmap_pars_vertex: W3,
  envmap_physical_pars_fragment: nI,
  envmap_vertex: X3,
  fog_vertex: j3,
  fog_pars_vertex: Y3,
  fog_fragment: q3,
  fog_pars_fragment: Z3,
  gradientmap_pars_fragment: K3,
  lightmap_fragment: J3,
  lightmap_pars_fragment: Q3,
  lights_lambert_fragment: $3,
  lights_lambert_pars_fragment: eI,
  lights_pars_begin: tI,
  lights_toon_fragment: iI,
  lights_toon_pars_fragment: rI,
  lights_phong_fragment: sI,
  lights_phong_pars_fragment: oI,
  lights_physical_fragment: aI,
  lights_physical_pars_fragment: lI,
  lights_fragment_begin: uI,
  lights_fragment_maps: cI,
  lights_fragment_end: fI,
  logdepthbuf_fragment: hI,
  logdepthbuf_pars_fragment: dI,
  logdepthbuf_pars_vertex: pI,
  logdepthbuf_vertex: mI,
  map_fragment: gI,
  map_pars_fragment: vI,
  map_particle_fragment: yI,
  map_particle_pars_fragment: _I,
  metalnessmap_fragment: xI,
  metalnessmap_pars_fragment: SI,
  morphcolor_vertex: MI,
  morphnormal_vertex: wI,
  morphtarget_pars_vertex: EI,
  morphtarget_vertex: TI,
  normal_fragment_begin: AI,
  normal_fragment_maps: CI,
  normal_pars_fragment: RI,
  normal_pars_vertex: PI,
  normal_vertex: bI,
  normalmap_pars_fragment: LI,
  clearcoat_normal_fragment_begin: II,
  clearcoat_normal_fragment_maps: NI,
  clearcoat_pars_fragment: DI,
  iridescence_pars_fragment: UI,
  opaque_fragment: OI,
  packing: kI,
  premultiplied_alpha_fragment: FI,
  project_vertex: zI,
  dithering_fragment: BI,
  dithering_pars_fragment: HI,
  roughnessmap_fragment: VI,
  roughnessmap_pars_fragment: GI,
  shadowmap_pars_fragment: WI,
  shadowmap_pars_vertex: XI,
  shadowmap_vertex: jI,
  shadowmask_pars_fragment: YI,
  skinbase_vertex: qI,
  skinning_pars_vertex: ZI,
  skinning_vertex: KI,
  skinnormal_vertex: JI,
  specularmap_fragment: QI,
  specularmap_pars_fragment: $I,
  tonemapping_fragment: eN,
  tonemapping_pars_fragment: tN,
  transmission_fragment: nN,
  transmission_pars_fragment: iN,
  uv_pars_fragment: rN,
  uv_pars_vertex: sN,
  uv_vertex: oN,
  worldpos_vertex: aN,
  background_vert: lN,
  background_frag: uN,
  backgroundCube_vert: cN,
  backgroundCube_frag: fN,
  cube_vert: hN,
  cube_frag: dN,
  depth_vert: pN,
  depth_frag: mN,
  distanceRGBA_vert: gN,
  distanceRGBA_frag: vN,
  equirect_vert: yN,
  equirect_frag: _N,
  linedashed_vert: xN,
  linedashed_frag: SN,
  meshbasic_vert: MN,
  meshbasic_frag: wN,
  meshlambert_vert: EN,
  meshlambert_frag: TN,
  meshmatcap_vert: AN,
  meshmatcap_frag: CN,
  meshnormal_vert: RN,
  meshnormal_frag: PN,
  meshphong_vert: bN,
  meshphong_frag: LN,
  meshphysical_vert: IN,
  meshphysical_frag: NN,
  meshtoon_vert: DN,
  meshtoon_frag: UN,
  points_vert: ON,
  points_frag: kN,
  shadow_vert: FN,
  shadow_frag: zN,
  sprite_vert: BN,
  sprite_frag: HN
}, Le = {
  common: {
    diffuse: { value: /* @__PURE__ */ new ze(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new _t() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new _t() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new _t() }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new _t() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new _t() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new _t() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new _t() },
    normalScale: { value: /* @__PURE__ */ new me(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new _t() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new _t() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new _t() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new _t() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new ze(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new ze(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new _t() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new _t() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new ze(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new me(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new _t() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new _t() },
    alphaTest: { value: 0 }
  }
}, mr = {
  basic: {
    uniforms: /* @__PURE__ */ ri([
      Le.common,
      Le.specularmap,
      Le.envmap,
      Le.aomap,
      Le.lightmap,
      Le.fog
    ]),
    vertexShader: gt.meshbasic_vert,
    fragmentShader: gt.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ ri([
      Le.common,
      Le.specularmap,
      Le.envmap,
      Le.aomap,
      Le.lightmap,
      Le.emissivemap,
      Le.bumpmap,
      Le.normalmap,
      Le.displacementmap,
      Le.fog,
      Le.lights,
      {
        emissive: { value: /* @__PURE__ */ new ze(0) }
      }
    ]),
    vertexShader: gt.meshlambert_vert,
    fragmentShader: gt.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ ri([
      Le.common,
      Le.specularmap,
      Le.envmap,
      Le.aomap,
      Le.lightmap,
      Le.emissivemap,
      Le.bumpmap,
      Le.normalmap,
      Le.displacementmap,
      Le.fog,
      Le.lights,
      {
        emissive: { value: /* @__PURE__ */ new ze(0) },
        specular: { value: /* @__PURE__ */ new ze(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: gt.meshphong_vert,
    fragmentShader: gt.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ ri([
      Le.common,
      Le.envmap,
      Le.aomap,
      Le.lightmap,
      Le.emissivemap,
      Le.bumpmap,
      Le.normalmap,
      Le.displacementmap,
      Le.roughnessmap,
      Le.metalnessmap,
      Le.fog,
      Le.lights,
      {
        emissive: { value: /* @__PURE__ */ new ze(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: gt.meshphysical_vert,
    fragmentShader: gt.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ ri([
      Le.common,
      Le.aomap,
      Le.lightmap,
      Le.emissivemap,
      Le.bumpmap,
      Le.normalmap,
      Le.displacementmap,
      Le.gradientmap,
      Le.fog,
      Le.lights,
      {
        emissive: { value: /* @__PURE__ */ new ze(0) }
      }
    ]),
    vertexShader: gt.meshtoon_vert,
    fragmentShader: gt.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ ri([
      Le.common,
      Le.bumpmap,
      Le.normalmap,
      Le.displacementmap,
      Le.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: gt.meshmatcap_vert,
    fragmentShader: gt.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ ri([
      Le.points,
      Le.fog
    ]),
    vertexShader: gt.points_vert,
    fragmentShader: gt.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ ri([
      Le.common,
      Le.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: gt.linedashed_vert,
    fragmentShader: gt.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ ri([
      Le.common,
      Le.displacementmap
    ]),
    vertexShader: gt.depth_vert,
    fragmentShader: gt.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ ri([
      Le.common,
      Le.bumpmap,
      Le.normalmap,
      Le.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: gt.meshnormal_vert,
    fragmentShader: gt.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ ri([
      Le.sprite,
      Le.fog
    ]),
    vertexShader: gt.sprite_vert,
    fragmentShader: gt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new _t() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: gt.background_vert,
    fragmentShader: gt.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: gt.backgroundCube_vert,
    fragmentShader: gt.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: gt.cube_vert,
    fragmentShader: gt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: gt.equirect_vert,
    fragmentShader: gt.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ ri([
      Le.common,
      Le.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new D() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: gt.distanceRGBA_vert,
    fragmentShader: gt.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ ri([
      Le.lights,
      Le.fog,
      {
        color: { value: /* @__PURE__ */ new ze(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: gt.shadow_vert,
    fragmentShader: gt.shadow_frag
  }
};
mr.physical = {
  uniforms: /* @__PURE__ */ ri([
    mr.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new _t() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new _t() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new me(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new _t() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new _t() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new _t() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new ze(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new _t() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new _t() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new _t() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new me() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new _t() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new ze(0) },
      specularColor: { value: /* @__PURE__ */ new ze(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new _t() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new _t() },
      anisotropyVector: { value: /* @__PURE__ */ new me() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new _t() }
    }
  ]),
  vertexShader: gt.meshphysical_vert,
  fragmentShader: gt.meshphysical_frag
};
const Uh = { r: 0, b: 0, g: 0 };
function VN(n, e, t, i, r, s, o) {
  const l = new ze(0);
  let c = s === !0 ? 0 : 1, f, h, d = null, m = 0, v = null;
  function _(M, g) {
    let x = !1, S = g.isScene === !0 ? g.background : null;
    switch (S && S.isTexture && (S = (g.backgroundBlurriness > 0 ? t : e).get(S)), S === null ? w(l, c) : S && S.isColor && (w(S, 1), x = !0), n.xr.getEnvironmentBlendMode()) {
      case "opaque":
        x = !0;
        break;
      case "additive":
        i.buffers.color.setClear(0, 0, 0, 1, o), x = !0;
        break;
      case "alpha-blend":
        i.buffers.color.setClear(0, 0, 0, 0, o), x = !0;
        break;
    }
    (n.autoClear || x) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil), S && (S.isCubeTexture || S.mapping === ql) ? (h === void 0 && (h = new kn(
      new ga(1, 1, 1),
      new Wr({
        name: "BackgroundCubeMaterial",
        uniforms: Vl(mr.backgroundCube.uniforms),
        vertexShader: mr.backgroundCube.vertexShader,
        fragmentShader: mr.backgroundCube.fragmentShader,
        side: ai,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(P, L, N) {
      this.matrixWorld.copyPosition(N.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), r.update(h)), h.material.uniforms.envMap.value = S, h.material.uniforms.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = g.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, h.material.toneMapped = S.colorSpace !== pt, (d !== S || m !== S.version || v !== n.toneMapping) && (h.material.needsUpdate = !0, d = S, m = S.version, v = n.toneMapping), h.layers.enableAll(), M.unshift(h, h.geometry, h.material, 0, 0, null)) : S && S.isTexture && (f === void 0 && (f = new kn(
      new Zc(2, 2),
      new Wr({
        name: "BackgroundMaterial",
        uniforms: Vl(mr.background.uniforms),
        vertexShader: mr.background.vertexShader,
        fragmentShader: mr.background.fragmentShader,
        side: Ms,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), f.geometry.deleteAttribute("normal"), Object.defineProperty(f.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), r.update(f)), f.material.uniforms.t2D.value = S, f.material.uniforms.backgroundIntensity.value = g.backgroundIntensity, f.material.toneMapped = S.colorSpace !== pt, S.matrixAutoUpdate === !0 && S.updateMatrix(), f.material.uniforms.uvTransform.value.copy(S.matrix), (d !== S || m !== S.version || v !== n.toneMapping) && (f.material.needsUpdate = !0, d = S, m = S.version, v = n.toneMapping), f.layers.enableAll(), M.unshift(f, f.geometry, f.material, 0, 0, null));
  }
  function w(M, g) {
    M.getRGB(Uh, VA(n)), i.buffers.color.setClear(Uh.r, Uh.g, Uh.b, g, o);
  }
  return {
    getClearColor: function() {
      return l;
    },
    setClearColor: function(M, g = 1) {
      l.set(M), c = g, w(l, c);
    },
    getClearAlpha: function() {
      return c;
    },
    setClearAlpha: function(M) {
      c = M, w(l, c);
    },
    render: _
  };
}
function GN(n, e, t, i) {
  const r = n.getParameter(n.MAX_VERTEX_ATTRIBS), s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = i.isWebGL2 || s !== null, l = {}, c = M(null);
  let f = c, h = !1;
  function d(K, J, oe, ne, O) {
    let X = !1;
    if (o) {
      const W = w(ne, oe, J);
      f !== W && (f = W, v(f.object)), X = g(K, ne, oe, O), X && x(K, ne, oe, O);
    } else {
      const W = J.wireframe === !0;
      (f.geometry !== ne.id || f.program !== oe.id || f.wireframe !== W) && (f.geometry = ne.id, f.program = oe.id, f.wireframe = W, X = !0);
    }
    O !== null && t.update(O, n.ELEMENT_ARRAY_BUFFER), (X || h) && (h = !1, N(K, J, oe, ne), O !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(O).buffer));
  }
  function m() {
    return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
  }
  function v(K) {
    return i.isWebGL2 ? n.bindVertexArray(K) : s.bindVertexArrayOES(K);
  }
  function _(K) {
    return i.isWebGL2 ? n.deleteVertexArray(K) : s.deleteVertexArrayOES(K);
  }
  function w(K, J, oe) {
    const ne = oe.wireframe === !0;
    let O = l[K.id];
    O === void 0 && (O = {}, l[K.id] = O);
    let X = O[J.id];
    X === void 0 && (X = {}, O[J.id] = X);
    let W = X[ne];
    return W === void 0 && (W = M(m()), X[ne] = W), W;
  }
  function M(K) {
    const J = [], oe = [], ne = [];
    for (let O = 0; O < r; O++)
      J[O] = 0, oe[O] = 0, ne[O] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: J,
      enabledAttributes: oe,
      attributeDivisors: ne,
      object: K,
      attributes: {},
      index: null
    };
  }
  function g(K, J, oe, ne) {
    const O = f.attributes, X = J.attributes;
    let W = 0;
    const V = oe.getAttributes();
    for (const j in V)
      if (V[j].location >= 0) {
        const ye = O[j];
        let Te = X[j];
        if (Te === void 0 && (j === "instanceMatrix" && K.instanceMatrix && (Te = K.instanceMatrix), j === "instanceColor" && K.instanceColor && (Te = K.instanceColor)), ye === void 0 || ye.attribute !== Te || Te && ye.data !== Te.data)
          return !0;
        W++;
      }
    return f.attributesNum !== W || f.index !== ne;
  }
  function x(K, J, oe, ne) {
    const O = {}, X = J.attributes;
    let W = 0;
    const V = oe.getAttributes();
    for (const j in V)
      if (V[j].location >= 0) {
        let ye = X[j];
        ye === void 0 && (j === "instanceMatrix" && K.instanceMatrix && (ye = K.instanceMatrix), j === "instanceColor" && K.instanceColor && (ye = K.instanceColor));
        const Te = {};
        Te.attribute = ye, ye && ye.data && (Te.data = ye.data), O[j] = Te, W++;
      }
    f.attributes = O, f.attributesNum = W, f.index = ne;
  }
  function S() {
    const K = f.newAttributes;
    for (let J = 0, oe = K.length; J < oe; J++)
      K[J] = 0;
  }
  function T(K) {
    C(K, 0);
  }
  function C(K, J) {
    const oe = f.newAttributes, ne = f.enabledAttributes, O = f.attributeDivisors;
    oe[K] = 1, ne[K] === 0 && (n.enableVertexAttribArray(K), ne[K] = 1), O[K] !== J && ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](K, J), O[K] = J);
  }
  function P() {
    const K = f.newAttributes, J = f.enabledAttributes;
    for (let oe = 0, ne = J.length; oe < ne; oe++)
      J[oe] !== K[oe] && (n.disableVertexAttribArray(oe), J[oe] = 0);
  }
  function L(K, J, oe, ne, O, X, W) {
    W === !0 ? n.vertexAttribIPointer(K, J, oe, O, X) : n.vertexAttribPointer(K, J, oe, ne, O, X);
  }
  function N(K, J, oe, ne) {
    if (i.isWebGL2 === !1 && (K.isInstancedMesh || ne.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    S();
    const O = ne.attributes, X = oe.getAttributes(), W = J.defaultAttributeValues;
    for (const V in X) {
      const j = X[V];
      if (j.location >= 0) {
        let de = O[V];
        if (de === void 0 && (V === "instanceMatrix" && K.instanceMatrix && (de = K.instanceMatrix), V === "instanceColor" && K.instanceColor && (de = K.instanceColor)), de !== void 0) {
          const ye = de.normalized, Te = de.itemSize, Ie = t.get(de);
          if (Ie === void 0)
            continue;
          const Be = Ie.buffer, je = Ie.type, vt = Ie.bytesPerElement, lt = i.isWebGL2 === !0 && (je === n.INT || je === n.UNSIGNED_INT || de.gpuType === n_);
          if (de.isInterleavedBufferAttribute) {
            const Re = de.data, z = Re.stride, ge = de.offset;
            if (Re.isInstancedInterleavedBuffer) {
              for (let fe = 0; fe < j.locationSize; fe++)
                C(j.location + fe, Re.meshPerAttribute);
              K.isInstancedMesh !== !0 && ne._maxInstanceCount === void 0 && (ne._maxInstanceCount = Re.meshPerAttribute * Re.count);
            } else
              for (let fe = 0; fe < j.locationSize; fe++)
                T(j.location + fe);
            n.bindBuffer(n.ARRAY_BUFFER, Be);
            for (let fe = 0; fe < j.locationSize; fe++)
              L(
                j.location + fe,
                Te / j.locationSize,
                je,
                ye,
                z * vt,
                (ge + Te / j.locationSize * fe) * vt,
                lt
              );
          } else {
            if (de.isInstancedBufferAttribute) {
              for (let Re = 0; Re < j.locationSize; Re++)
                C(j.location + Re, de.meshPerAttribute);
              K.isInstancedMesh !== !0 && ne._maxInstanceCount === void 0 && (ne._maxInstanceCount = de.meshPerAttribute * de.count);
            } else
              for (let Re = 0; Re < j.locationSize; Re++)
                T(j.location + Re);
            n.bindBuffer(n.ARRAY_BUFFER, Be);
            for (let Re = 0; Re < j.locationSize; Re++)
              L(
                j.location + Re,
                Te / j.locationSize,
                je,
                ye,
                Te * vt,
                Te / j.locationSize * Re * vt,
                lt
              );
          }
        } else if (W !== void 0) {
          const ye = W[V];
          if (ye !== void 0)
            switch (ye.length) {
              case 2:
                n.vertexAttrib2fv(j.location, ye);
                break;
              case 3:
                n.vertexAttrib3fv(j.location, ye);
                break;
              case 4:
                n.vertexAttrib4fv(j.location, ye);
                break;
              default:
                n.vertexAttrib1fv(j.location, ye);
            }
        }
      }
    }
    P();
  }
  function R() {
    $();
    for (const K in l) {
      const J = l[K];
      for (const oe in J) {
        const ne = J[oe];
        for (const O in ne)
          _(ne[O].object), delete ne[O];
        delete J[oe];
      }
      delete l[K];
    }
  }
  function b(K) {
    if (l[K.id] === void 0)
      return;
    const J = l[K.id];
    for (const oe in J) {
      const ne = J[oe];
      for (const O in ne)
        _(ne[O].object), delete ne[O];
      delete J[oe];
    }
    delete l[K.id];
  }
  function G(K) {
    for (const J in l) {
      const oe = l[J];
      if (oe[K.id] === void 0)
        continue;
      const ne = oe[K.id];
      for (const O in ne)
        _(ne[O].object), delete ne[O];
      delete oe[K.id];
    }
  }
  function $() {
    Y(), h = !0, f !== c && (f = c, v(f.object));
  }
  function Y() {
    c.geometry = null, c.program = null, c.wireframe = !1;
  }
  return {
    setup: d,
    reset: $,
    resetDefaultState: Y,
    dispose: R,
    releaseStatesOfGeometry: b,
    releaseStatesOfProgram: G,
    initAttributes: S,
    enableAttribute: T,
    disableUnusedAttributes: P
  };
}
function WN(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(f) {
    s = f;
  }
  function l(f, h) {
    n.drawArrays(s, f, h), t.update(h, s, 1);
  }
  function c(f, h, d) {
    if (d === 0)
      return;
    let m, v;
    if (r)
      m = n, v = "drawArraysInstanced";
    else if (m = e.get("ANGLE_instanced_arrays"), v = "drawArraysInstancedANGLE", m === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    m[v](s, f, h, d), t.update(h, s, d);
  }
  this.setMode = o, this.render = l, this.renderInstances = c;
}
function XN(n, e, t) {
  let i;
  function r() {
    if (i !== void 0)
      return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const L = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(L.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  function s(L) {
    if (L === "highp") {
      if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
        return "highp";
      L = "mediump";
    }
    return L === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  const o = typeof WebGL2RenderingContext < "u" && n.constructor.name === "WebGL2RenderingContext";
  let l = t.precision !== void 0 ? t.precision : "highp";
  const c = s(l);
  c !== l && (console.warn("THREE.WebGLRenderer:", l, "not supported, using", c, "instead."), l = c);
  const f = o || e.has("WEBGL_draw_buffers"), h = t.logarithmicDepthBuffer === !0, d = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), m = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS), v = n.getParameter(n.MAX_TEXTURE_SIZE), _ = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE), w = n.getParameter(n.MAX_VERTEX_ATTRIBS), M = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS), g = n.getParameter(n.MAX_VARYING_VECTORS), x = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS), S = m > 0, T = o || e.has("OES_texture_float"), C = S && T, P = o ? n.getParameter(n.MAX_SAMPLES) : 0;
  return {
    isWebGL2: o,
    drawBuffers: f,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: l,
    logarithmicDepthBuffer: h,
    maxTextures: d,
    maxVertexTextures: m,
    maxTextureSize: v,
    maxCubemapSize: _,
    maxAttributes: w,
    maxVertexUniforms: M,
    maxVaryings: g,
    maxFragmentUniforms: x,
    vertexTextures: S,
    floatFragmentTextures: T,
    floatVertexTextures: C,
    maxSamples: P
  };
}
function jN(n) {
  const e = this;
  let t = null, i = 0, r = !1, s = !1;
  const o = new fs(), l = new _t(), c = { value: null, needsUpdate: !1 };
  this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, m) {
    const v = d.length !== 0 || m || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    i !== 0 || r;
    return r = m, i = d.length, v;
  }, this.beginShadows = function() {
    s = !0, h(null);
  }, this.endShadows = function() {
    s = !1;
  }, this.setGlobalState = function(d, m) {
    t = h(d, m, 0);
  }, this.setState = function(d, m, v) {
    const _ = d.clippingPlanes, w = d.clipIntersection, M = d.clipShadows, g = n.get(d);
    if (!r || _ === null || _.length === 0 || s && !M)
      s ? h(null) : f();
    else {
      const x = s ? 0 : i, S = x * 4;
      let T = g.clippingState || null;
      c.value = T, T = h(_, m, S, v);
      for (let C = 0; C !== S; ++C)
        T[C] = t[C];
      g.clippingState = T, this.numIntersection = w ? this.numPlanes : 0, this.numPlanes += x;
    }
  };
  function f() {
    c.value !== t && (c.value = t, c.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function h(d, m, v, _) {
    const w = d !== null ? d.length : 0;
    let M = null;
    if (w !== 0) {
      if (M = c.value, _ !== !0 || M === null) {
        const g = v + w * 4, x = m.matrixWorldInverse;
        l.getNormalMatrix(x), (M === null || M.length < g) && (M = new Float32Array(g));
        for (let S = 0, T = v; S !== w; ++S, T += 4)
          o.copy(d[S]).applyMatrix4(x, l), o.normal.toArray(M, T), M[T + 3] = o.constant;
      }
      c.value = M, c.needsUpdate = !0;
    }
    return e.numPlanes = w, e.numIntersection = 0, M;
  }
}
function YN(n) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(o, l) {
    return l === Mc ? o.mapping = lo : l === wc && (o.mapping = uo), o;
  }
  function i(o) {
    if (o && o.isTexture && o.isRenderTargetTexture === !1) {
      const l = o.mapping;
      if (l === Mc || l === wc)
        if (e.has(o)) {
          const c = e.get(o).texture;
          return t(c, o.mapping);
        } else {
          const c = o.image;
          if (c && c.height > 0) {
            const f = new XA(c.height / 2);
            return f.fromEquirectangularTexture(n, o), e.set(o, f), o.addEventListener("dispose", r), t(f.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function r(o) {
    const l = o.target;
    l.removeEventListener("dispose", r);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function s() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: s
  };
}
class Vr extends Yc {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, i, r, s, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let s = i - e, o = i + e, l = r + t, c = r - t;
    if (this.view !== null && this.view.enabled) {
      const f = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += f * this.view.offsetX, o = s + f * this.view.width, l -= h * this.view.offsetY, c = l - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, o, l, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const Sl = 4, JS = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Wo = 20, Yg = /* @__PURE__ */ new Vr(), QS = /* @__PURE__ */ new ze();
let qg = null;
const Vo = (1 + Math.sqrt(5)) / 2, Ka = 1 / Vo, $S = [
  /* @__PURE__ */ new D(1, 1, 1),
  /* @__PURE__ */ new D(-1, 1, 1),
  /* @__PURE__ */ new D(1, 1, -1),
  /* @__PURE__ */ new D(-1, 1, -1),
  /* @__PURE__ */ new D(0, Vo, Ka),
  /* @__PURE__ */ new D(0, Vo, -Ka),
  /* @__PURE__ */ new D(Ka, 0, Vo),
  /* @__PURE__ */ new D(-Ka, 0, Vo),
  /* @__PURE__ */ new D(Vo, Ka, 0),
  /* @__PURE__ */ new D(-Vo, Ka, 0)
];
class Wv {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, i = 0.1, r = 100) {
    qg = this._renderer.getRenderTarget(), this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(e, i, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = nM(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = tM(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(qg), e.scissorTest = !1, Oh(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === lo || e.mapping === uo ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), qg = this._renderer.getRenderTarget();
    const i = t || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = {
      magFilter: pn,
      minFilter: pn,
      generateMipmaps: !1,
      type: Bl,
      format: vi,
      colorSpace: Sr,
      depthBuffer: !1
    }, r = eM(e, t, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = eM(e, t, i);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = qN(s)), this._blurMaterial = ZN(s, e, t);
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new kn(this._lodPlanes[0], e);
    this._renderer.compile(t, Yg);
  }
  _sceneToCubeUV(e, t, i, r) {
    const l = new Qt(90, 1, t, i), c = [1, -1, 1, 1, 1, 1], f = [1, 1, 1, -1, -1, -1], h = this._renderer, d = h.autoClear, m = h.toneMapping;
    h.getClearColor(QS), h.toneMapping = _r, h.autoClear = !1;
    const v = new vo({
      name: "PMREM.Background",
      side: ai,
      depthWrite: !1,
      depthTest: !1
    }), _ = new kn(new ga(), v);
    let w = !1;
    const M = e.background;
    M ? M.isColor && (v.color.copy(M), e.background = null, w = !0) : (v.color.copy(QS), w = !0);
    for (let g = 0; g < 6; g++) {
      const x = g % 3;
      x === 0 ? (l.up.set(0, c[g], 0), l.lookAt(f[g], 0, 0)) : x === 1 ? (l.up.set(0, 0, c[g]), l.lookAt(0, f[g], 0)) : (l.up.set(0, c[g], 0), l.lookAt(0, 0, f[g]));
      const S = this._cubeSize;
      Oh(r, x * S, g > 2 ? S : 0, S, S), h.setRenderTarget(r), w && h.render(_, l), h.render(e, l);
    }
    _.geometry.dispose(), _.material.dispose(), h.toneMapping = m, h.autoClear = d, e.background = M;
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer, r = e.mapping === lo || e.mapping === uo;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = nM()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = tM());
    const s = r ? this._cubemapMaterial : this._equirectMaterial, o = new kn(this._lodPlanes[0], s), l = s.uniforms;
    l.envMap.value = e;
    const c = this._cubeSize;
    Oh(t, 0, 0, 3 * c, 2 * c), i.setRenderTarget(t), i.render(o, Yg);
  }
  _applyPMREM(e) {
    const t = this._renderer, i = t.autoClear;
    t.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = $S[(r - 1) % $S.length];
      this._blur(e, r - 1, r, s, o);
    }
    t.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      t,
      i,
      r,
      "latitudinal",
      s
    ), this._halfBlur(
      o,
      e,
      i,
      i,
      r,
      "longitudinal",
      s
    );
  }
  _halfBlur(e, t, i, r, s, o, l) {
    const c = this._renderer, f = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const h = 3, d = new kn(this._lodPlanes[r], f), m = f.uniforms, v = this._sizeLods[i] - 1, _ = isFinite(s) ? Math.PI / (2 * v) : 2 * Math.PI / (2 * Wo - 1), w = s / _, M = isFinite(s) ? 1 + Math.floor(h * w) : Wo;
    M > Wo && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${M} samples when the maximum is set to ${Wo}`);
    const g = [];
    let x = 0;
    for (let L = 0; L < Wo; ++L) {
      const N = L / w, R = Math.exp(-N * N / 2);
      g.push(R), L === 0 ? x += R : L < M && (x += 2 * R);
    }
    for (let L = 0; L < g.length; L++)
      g[L] = g[L] / x;
    m.envMap.value = e.texture, m.samples.value = M, m.weights.value = g, m.latitudinal.value = o === "latitudinal", l && (m.poleAxis.value = l);
    const { _lodMax: S } = this;
    m.dTheta.value = _, m.mipInt.value = S - i;
    const T = this._sizeLods[r], C = 3 * T * (r > S - Sl ? r - S + Sl : 0), P = 4 * (this._cubeSize - T);
    Oh(t, C, P, 3 * T, 2 * T), c.setRenderTarget(t), c.render(d, Yg);
  }
}
function qN(n) {
  const e = [], t = [], i = [];
  let r = n;
  const s = n - Sl + 1 + JS.length;
  for (let o = 0; o < s; o++) {
    const l = Math.pow(2, r);
    t.push(l);
    let c = 1 / l;
    o > n - Sl ? c = JS[o - n + Sl - 1] : o === 0 && (c = 0), i.push(c);
    const f = 1 / (l - 2), h = -f, d = 1 + f, m = [h, h, d, h, d, d, h, h, d, d, h, d], v = 6, _ = 6, w = 3, M = 2, g = 1, x = new Float32Array(w * _ * v), S = new Float32Array(M * _ * v), T = new Float32Array(g * _ * v);
    for (let P = 0; P < v; P++) {
      const L = P % 3 * 2 / 3 - 1, N = P > 2 ? 0 : -1, R = [
        L,
        N,
        0,
        L + 2 / 3,
        N,
        0,
        L + 2 / 3,
        N + 1,
        0,
        L,
        N,
        0,
        L + 2 / 3,
        N + 1,
        0,
        L,
        N + 1,
        0
      ];
      x.set(R, w * _ * P), S.set(m, M * _ * P);
      const b = [P, P, P, P, P, P];
      T.set(b, g * _ * P);
    }
    const C = new wt();
    C.setAttribute("position", new Ht(x, w)), C.setAttribute("uv", new Ht(S, M)), C.setAttribute("faceIndex", new Ht(T, g)), e.push(C), r > Sl && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function eM(n, e, t) {
  const i = new Mr(n, e, t);
  return i.texture.mapping = ql, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i;
}
function Oh(n, e, t, i, r) {
  n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
}
function ZN(n, e, t) {
  const i = new Float32Array(Wo), r = new D(0, 1, 0);
  return new Wr({
    name: "SphericalGaussianBlur",
    defines: {
      n: Wo,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r }
    },
    vertexShader: g_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: vs,
    depthTest: !1,
    depthWrite: !1
  });
}
function tM() {
  return new Wr({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: g_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: vs,
    depthTest: !1,
    depthWrite: !1
  });
}
function nM() {
  return new Wr({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: g_(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: vs,
    depthTest: !1,
    depthWrite: !1
  });
}
function g_() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function KN(n) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function i(l) {
    if (l && l.isTexture) {
      const c = l.mapping, f = c === Mc || c === wc, h = c === lo || c === uo;
      if (f || h)
        if (l.isRenderTargetTexture && l.needsPMREMUpdate === !0) {
          l.needsPMREMUpdate = !1;
          let d = e.get(l);
          return t === null && (t = new Wv(n)), d = f ? t.fromEquirectangular(l, d) : t.fromCubemap(l, d), e.set(l, d), d.texture;
        } else {
          if (e.has(l))
            return e.get(l).texture;
          {
            const d = l.image;
            if (f && d && d.height > 0 || h && d && r(d)) {
              t === null && (t = new Wv(n));
              const m = f ? t.fromEquirectangular(l) : t.fromCubemap(l);
              return e.set(l, m), l.addEventListener("dispose", s), m.texture;
            } else
              return null;
          }
        }
    }
    return l;
  }
  function r(l) {
    let c = 0;
    const f = 6;
    for (let h = 0; h < f; h++)
      l[h] !== void 0 && c++;
    return c === f;
  }
  function s(l) {
    const c = l.target;
    c.removeEventListener("dispose", s);
    const f = e.get(c);
    f !== void 0 && (e.delete(c), f.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: i,
    dispose: o
  };
}
function JN(n) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0)
      return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n.getExtension(i);
    }
    return e[i] = r, r;
  }
  return {
    has: function(i) {
      return t(i) !== null;
    },
    init: function(i) {
      i.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(i) {
      const r = t(i);
      return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), r;
    }
  };
}
function QN(n, e, t, i) {
  const r = {}, s = /* @__PURE__ */ new WeakMap();
  function o(d) {
    const m = d.target;
    m.index !== null && e.remove(m.index);
    for (const _ in m.attributes)
      e.remove(m.attributes[_]);
    for (const _ in m.morphAttributes) {
      const w = m.morphAttributes[_];
      for (let M = 0, g = w.length; M < g; M++)
        e.remove(w[M]);
    }
    m.removeEventListener("dispose", o), delete r[m.id];
    const v = s.get(m);
    v && (e.remove(v), s.delete(m)), i.releaseStatesOfGeometry(m), m.isInstancedBufferGeometry === !0 && delete m._maxInstanceCount, t.memory.geometries--;
  }
  function l(d, m) {
    return r[m.id] === !0 || (m.addEventListener("dispose", o), r[m.id] = !0, t.memory.geometries++), m;
  }
  function c(d) {
    const m = d.attributes;
    for (const _ in m)
      e.update(m[_], n.ARRAY_BUFFER);
    const v = d.morphAttributes;
    for (const _ in v) {
      const w = v[_];
      for (let M = 0, g = w.length; M < g; M++)
        e.update(w[M], n.ARRAY_BUFFER);
    }
  }
  function f(d) {
    const m = [], v = d.index, _ = d.attributes.position;
    let w = 0;
    if (v !== null) {
      const x = v.array;
      w = v.version;
      for (let S = 0, T = x.length; S < T; S += 3) {
        const C = x[S + 0], P = x[S + 1], L = x[S + 2];
        m.push(C, P, P, L, L, C);
      }
    } else {
      const x = _.array;
      w = _.version;
      for (let S = 0, T = x.length / 3 - 1; S < T; S += 3) {
        const C = S + 0, P = S + 1, L = S + 2;
        m.push(C, P, P, L, L, C);
      }
    }
    const M = new (BA(m) ? m_ : p_)(m, 1);
    M.version = w;
    const g = s.get(d);
    g && e.remove(g), s.set(d, M);
  }
  function h(d) {
    const m = s.get(d);
    if (m) {
      const v = d.index;
      v !== null && m.version < v.version && f(d);
    } else
      f(d);
    return s.get(d);
  }
  return {
    get: l,
    update: c,
    getWireframeAttribute: h
  };
}
function $N(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(m) {
    s = m;
  }
  let l, c;
  function f(m) {
    l = m.type, c = m.bytesPerElement;
  }
  function h(m, v) {
    n.drawElements(s, v, l, m * c), t.update(v, s, 1);
  }
  function d(m, v, _) {
    if (_ === 0)
      return;
    let w, M;
    if (r)
      w = n, M = "drawElementsInstanced";
    else if (w = e.get("ANGLE_instanced_arrays"), M = "drawElementsInstancedANGLE", w === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    w[M](s, v, l, m * c, _), t.update(v, s, _);
  }
  this.setMode = o, this.setIndex = f, this.render = h, this.renderInstances = d;
}
function eD(n) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function i(s, o, l) {
    switch (t.calls++, o) {
      case n.TRIANGLES:
        t.triangles += l * (s / 3);
        break;
      case n.LINES:
        t.lines += l * (s / 2);
        break;
      case n.LINE_STRIP:
        t.lines += l * (s - 1);
        break;
      case n.LINE_LOOP:
        t.lines += l * s;
        break;
      case n.POINTS:
        t.points += l * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i
  };
}
function tD(n, e) {
  return n[0] - e[0];
}
function nD(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function iD(n, e, t) {
  const i = {}, r = new Float32Array(8), s = /* @__PURE__ */ new WeakMap(), o = new kt(), l = [];
  for (let f = 0; f < 8; f++)
    l[f] = [f, 0];
  function c(f, h, d) {
    const m = f.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const _ = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color, w = _ !== void 0 ? _.length : 0;
      let M = s.get(h);
      if (M === void 0 || M.count !== w) {
        let J = function() {
          Y.dispose(), s.delete(h), h.removeEventListener("dispose", J);
        };
        var v = J;
        M !== void 0 && M.texture.dispose();
        const S = h.morphAttributes.position !== void 0, T = h.morphAttributes.normal !== void 0, C = h.morphAttributes.color !== void 0, P = h.morphAttributes.position || [], L = h.morphAttributes.normal || [], N = h.morphAttributes.color || [];
        let R = 0;
        S === !0 && (R = 1), T === !0 && (R = 2), C === !0 && (R = 3);
        let b = h.attributes.position.count * R, G = 1;
        b > e.maxTextureSize && (G = Math.ceil(b / e.maxTextureSize), b = e.maxTextureSize);
        const $ = new Float32Array(b * G * 4 * w), Y = new Ap($, b, G, w);
        Y.type = kr, Y.needsUpdate = !0;
        const K = R * 4;
        for (let oe = 0; oe < w; oe++) {
          const ne = P[oe], O = L[oe], X = N[oe], W = b * G * 4 * oe;
          for (let V = 0; V < ne.count; V++) {
            const j = V * K;
            S === !0 && (o.fromBufferAttribute(ne, V), $[W + j + 0] = o.x, $[W + j + 1] = o.y, $[W + j + 2] = o.z, $[W + j + 3] = 0), T === !0 && (o.fromBufferAttribute(O, V), $[W + j + 4] = o.x, $[W + j + 5] = o.y, $[W + j + 6] = o.z, $[W + j + 7] = 0), C === !0 && (o.fromBufferAttribute(X, V), $[W + j + 8] = o.x, $[W + j + 9] = o.y, $[W + j + 10] = o.z, $[W + j + 11] = X.itemSize === 4 ? o.w : 1);
          }
        }
        M = {
          count: w,
          texture: Y,
          size: new me(b, G)
        }, s.set(h, M), h.addEventListener("dispose", J);
      }
      let g = 0;
      for (let S = 0; S < m.length; S++)
        g += m[S];
      const x = h.morphTargetsRelative ? 1 : 1 - g;
      d.getUniforms().setValue(n, "morphTargetBaseInfluence", x), d.getUniforms().setValue(n, "morphTargetInfluences", m), d.getUniforms().setValue(n, "morphTargetsTexture", M.texture, t), d.getUniforms().setValue(n, "morphTargetsTextureSize", M.size);
    } else {
      const _ = m === void 0 ? 0 : m.length;
      let w = i[h.id];
      if (w === void 0 || w.length !== _) {
        w = [];
        for (let T = 0; T < _; T++)
          w[T] = [T, 0];
        i[h.id] = w;
      }
      for (let T = 0; T < _; T++) {
        const C = w[T];
        C[0] = T, C[1] = m[T];
      }
      w.sort(nD);
      for (let T = 0; T < 8; T++)
        T < _ && w[T][1] ? (l[T][0] = w[T][0], l[T][1] = w[T][1]) : (l[T][0] = Number.MAX_SAFE_INTEGER, l[T][1] = 0);
      l.sort(tD);
      const M = h.morphAttributes.position, g = h.morphAttributes.normal;
      let x = 0;
      for (let T = 0; T < 8; T++) {
        const C = l[T], P = C[0], L = C[1];
        P !== Number.MAX_SAFE_INTEGER && L ? (M && h.getAttribute("morphTarget" + T) !== M[P] && h.setAttribute("morphTarget" + T, M[P]), g && h.getAttribute("morphNormal" + T) !== g[P] && h.setAttribute("morphNormal" + T, g[P]), r[T] = L, x += L) : (M && h.hasAttribute("morphTarget" + T) === !0 && h.deleteAttribute("morphTarget" + T), g && h.hasAttribute("morphNormal" + T) === !0 && h.deleteAttribute("morphNormal" + T), r[T] = 0);
      }
      const S = h.morphTargetsRelative ? 1 : 1 - x;
      d.getUniforms().setValue(n, "morphTargetBaseInfluence", S), d.getUniforms().setValue(n, "morphTargetInfluences", r);
    }
  }
  return {
    update: c
  };
}
function rD(n, e, t, i) {
  let r = /* @__PURE__ */ new WeakMap();
  function s(c) {
    const f = i.render.frame, h = c.geometry, d = e.get(c, h);
    if (r.get(d) !== f && (e.update(d), r.set(d, f)), c.isInstancedMesh && (c.hasEventListener("dispose", l) === !1 && c.addEventListener("dispose", l), r.get(c) !== f && (t.update(c.instanceMatrix, n.ARRAY_BUFFER), c.instanceColor !== null && t.update(c.instanceColor, n.ARRAY_BUFFER), r.set(c, f))), c.isSkinnedMesh) {
      const m = c.skeleton;
      r.get(m) !== f && (m.update(), r.set(m, f));
    }
    return d;
  }
  function o() {
    r = /* @__PURE__ */ new WeakMap();
  }
  function l(c) {
    const f = c.target;
    f.removeEventListener("dispose", l), t.remove(f.instanceMatrix), f.instanceColor !== null && t.remove(f.instanceColor);
  }
  return {
    update: s,
    dispose: o
  };
}
const YA = /* @__PURE__ */ new mn(), qA = /* @__PURE__ */ new Ap(), ZA = /* @__PURE__ */ new d_(), KA = /* @__PURE__ */ new qc(), iM = [], rM = [], sM = new Float32Array(16), oM = new Float32Array(9), aM = new Float32Array(4);
function Zl(n, e, t) {
  const i = n[0];
  if (i <= 0 || i > 0)
    return n;
  const r = e * t;
  let s = iM[r];
  if (s === void 0 && (s = new Float32Array(r), iM[r] = s), e !== 0) {
    i.toArray(s, 0);
    for (let o = 1, l = 0; o !== e; ++o)
      l += t, n[o].toArray(s, l);
  }
  return s;
}
function Cn(n, e) {
  if (n.length !== e.length)
    return !1;
  for (let t = 0, i = n.length; t < i; t++)
    if (n[t] !== e[t])
      return !1;
  return !0;
}
function Rn(n, e) {
  for (let t = 0, i = e.length; t < i; t++)
    n[t] = e[t];
}
function Rp(n, e) {
  let t = rM[e];
  t === void 0 && (t = new Int32Array(e), rM[e] = t);
  for (let i = 0; i !== e; ++i)
    t[i] = n.allocateTextureUnit();
  return t;
}
function sD(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e);
}
function oD(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Cn(t, e))
      return;
    n.uniform2fv(this.addr, e), Rn(t, e);
  }
}
function aD(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (Cn(t, e))
      return;
    n.uniform3fv(this.addr, e), Rn(t, e);
  }
}
function lD(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Cn(t, e))
      return;
    n.uniform4fv(this.addr, e), Rn(t, e);
  }
}
function uD(n, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (Cn(t, e))
      return;
    n.uniformMatrix2fv(this.addr, !1, e), Rn(t, e);
  } else {
    if (Cn(t, i))
      return;
    aM.set(i), n.uniformMatrix2fv(this.addr, !1, aM), Rn(t, i);
  }
}
function cD(n, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (Cn(t, e))
      return;
    n.uniformMatrix3fv(this.addr, !1, e), Rn(t, e);
  } else {
    if (Cn(t, i))
      return;
    oM.set(i), n.uniformMatrix3fv(this.addr, !1, oM), Rn(t, i);
  }
}
function fD(n, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (Cn(t, e))
      return;
    n.uniformMatrix4fv(this.addr, !1, e), Rn(t, e);
  } else {
    if (Cn(t, i))
      return;
    sM.set(i), n.uniformMatrix4fv(this.addr, !1, sM), Rn(t, i);
  }
}
function hD(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e);
}
function dD(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Cn(t, e))
      return;
    n.uniform2iv(this.addr, e), Rn(t, e);
  }
}
function pD(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Cn(t, e))
      return;
    n.uniform3iv(this.addr, e), Rn(t, e);
  }
}
function mD(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Cn(t, e))
      return;
    n.uniform4iv(this.addr, e), Rn(t, e);
  }
}
function gD(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e);
}
function vD(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Cn(t, e))
      return;
    n.uniform2uiv(this.addr, e), Rn(t, e);
  }
}
function yD(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Cn(t, e))
      return;
    n.uniform3uiv(this.addr, e), Rn(t, e);
  }
}
function _D(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Cn(t, e))
      return;
    n.uniform4uiv(this.addr, e), Rn(t, e);
  }
}
function xD(n, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2D(e || YA, r);
}
function SD(n, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture3D(e || ZA, r);
}
function MD(n, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTextureCube(e || KA, r);
}
function wD(n, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2DArray(e || qA, r);
}
function ED(n) {
  switch (n) {
    case 5126:
      return sD;
    case 35664:
      return oD;
    case 35665:
      return aD;
    case 35666:
      return lD;
    case 35674:
      return uD;
    case 35675:
      return cD;
    case 35676:
      return fD;
    case 5124:
    case 35670:
      return hD;
    case 35667:
    case 35671:
      return dD;
    case 35668:
    case 35672:
      return pD;
    case 35669:
    case 35673:
      return mD;
    case 5125:
      return gD;
    case 36294:
      return vD;
    case 36295:
      return yD;
    case 36296:
      return _D;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return xD;
    case 35679:
    case 36299:
    case 36307:
      return SD;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return MD;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return wD;
  }
}
function TD(n, e) {
  n.uniform1fv(this.addr, e);
}
function AD(n, e) {
  const t = Zl(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function CD(n, e) {
  const t = Zl(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function RD(n, e) {
  const t = Zl(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function PD(n, e) {
  const t = Zl(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function bD(n, e) {
  const t = Zl(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function LD(n, e) {
  const t = Zl(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function ID(n, e) {
  n.uniform1iv(this.addr, e);
}
function ND(n, e) {
  n.uniform2iv(this.addr, e);
}
function DD(n, e) {
  n.uniform3iv(this.addr, e);
}
function UD(n, e) {
  n.uniform4iv(this.addr, e);
}
function OD(n, e) {
  n.uniform1uiv(this.addr, e);
}
function kD(n, e) {
  n.uniform2uiv(this.addr, e);
}
function FD(n, e) {
  n.uniform3uiv(this.addr, e);
}
function zD(n, e) {
  n.uniform4uiv(this.addr, e);
}
function BD(n, e, t) {
  const i = this.cache, r = e.length, s = Rp(t, r);
  Cn(i, s) || (n.uniform1iv(this.addr, s), Rn(i, s));
  for (let o = 0; o !== r; ++o)
    t.setTexture2D(e[o] || YA, s[o]);
}
function HD(n, e, t) {
  const i = this.cache, r = e.length, s = Rp(t, r);
  Cn(i, s) || (n.uniform1iv(this.addr, s), Rn(i, s));
  for (let o = 0; o !== r; ++o)
    t.setTexture3D(e[o] || ZA, s[o]);
}
function VD(n, e, t) {
  const i = this.cache, r = e.length, s = Rp(t, r);
  Cn(i, s) || (n.uniform1iv(this.addr, s), Rn(i, s));
  for (let o = 0; o !== r; ++o)
    t.setTextureCube(e[o] || KA, s[o]);
}
function GD(n, e, t) {
  const i = this.cache, r = e.length, s = Rp(t, r);
  Cn(i, s) || (n.uniform1iv(this.addr, s), Rn(i, s));
  for (let o = 0; o !== r; ++o)
    t.setTexture2DArray(e[o] || qA, s[o]);
}
function WD(n) {
  switch (n) {
    case 5126:
      return TD;
    case 35664:
      return AD;
    case 35665:
      return CD;
    case 35666:
      return RD;
    case 35674:
      return PD;
    case 35675:
      return bD;
    case 35676:
      return LD;
    case 5124:
    case 35670:
      return ID;
    case 35667:
    case 35671:
      return ND;
    case 35668:
    case 35672:
      return DD;
    case 35669:
    case 35673:
      return UD;
    case 5125:
      return OD;
    case 36294:
      return kD;
    case 36295:
      return FD;
    case 36296:
      return zD;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return BD;
    case 35679:
    case 36299:
    case 36307:
      return HD;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return VD;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return GD;
  }
}
class XD {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.setValue = ED(t.type);
  }
}
class jD {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = WD(t.type);
  }
}
class YD {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const l = r[s];
      l.setValue(e, t[l.id], i);
    }
  }
}
const Zg = /(\w+)(\])?(\[|\.)?/g;
function lM(n, e) {
  n.seq.push(e), n.map[e.id] = e;
}
function qD(n, e, t) {
  const i = n.name, r = i.length;
  for (Zg.lastIndex = 0; ; ) {
    const s = Zg.exec(i), o = Zg.lastIndex;
    let l = s[1];
    const c = s[2] === "]", f = s[3];
    if (c && (l = l | 0), f === void 0 || f === "[" && o + 2 === r) {
      lM(t, f === void 0 ? new XD(l, n, e) : new jD(l, n, e));
      break;
    } else {
      let d = t.map[l];
      d === void 0 && (d = new YD(l), lM(t, d)), t = d;
    }
  }
}
class Cd {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r), o = e.getUniformLocation(t, s.name);
      qD(s, o, this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const l = t[s], c = i[l.id];
      c.needsUpdate !== !1 && l.setValue(e, c.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function uM(n, e, t) {
  const i = n.createShader(e);
  return n.shaderSource(i, t), n.compileShader(i), i;
}
let ZD = 0;
function KD(n, e) {
  const t = n.split(`
`), i = [], r = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const l = o + 1;
    i.push(`${l === e ? ">" : " "} ${l}: ${t[o]}`);
  }
  return i.join(`
`);
}
function JD(n) {
  switch (n) {
    case Sr:
      return ["Linear", "( value )"];
    case pt:
      return ["sRGB", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", n), ["Linear", "( value )"];
  }
}
function cM(n, e, t) {
  const i = n.getShaderParameter(e, n.COMPILE_STATUS), r = n.getShaderInfoLog(e).trim();
  if (i && r === "")
    return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const o = parseInt(s[1]);
    return t.toUpperCase() + `

` + r + `

` + KD(n.getShaderSource(e), o);
  } else
    return r;
}
function QD(n, e) {
  const t = JD(e);
  return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function $D(n, e) {
  let t;
  switch (e) {
    case cA:
      t = "Linear";
      break;
    case fA:
      t = "Reinhard";
      break;
    case hA:
      t = "OptimizedCineon";
      break;
    case e_:
      t = "ACESFilmic";
      break;
    case dA:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function eU(n) {
  return [
    n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.normalMapTangentSpace || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(Gu).join(`
`);
}
function tU(n) {
  const e = [];
  for (const t in n) {
    const i = n[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function nU(n, e) {
  const t = {}, i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r), o = s.name;
    let l = 1;
    s.type === n.FLOAT_MAT2 && (l = 2), s.type === n.FLOAT_MAT3 && (l = 3), s.type === n.FLOAT_MAT4 && (l = 4), t[o] = {
      type: s.type,
      location: n.getAttribLocation(e, o),
      locationSize: l
    };
  }
  return t;
}
function Gu(n) {
  return n !== "";
}
function fM(n, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function hM(n, e) {
  return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const iU = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Xv(n) {
  return n.replace(iU, sU);
}
const rU = /* @__PURE__ */ new Map([
  ["encodings_fragment", "colorspace_fragment"],
  // @deprecated, r154
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  // @deprecated, r154
  ["output_fragment", "opaque_fragment"]
  // @deprecated, r154
]);
function sU(n, e) {
  let t = gt[e];
  if (t === void 0) {
    const i = rU.get(e);
    if (i !== void 0)
      t = gt[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return Xv(t);
}
const oU = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function dM(n) {
  return n.replace(oU, aU);
}
function aU(n, e, t, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function pM(n) {
  let e = "precision " + n.precision + ` float;
precision ` + n.precision + " int;";
  return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function lU(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return n.shadowMapType === Mp ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === $u ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === hr && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function uU(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case lo:
      case uo:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case ql:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function cU(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case uo:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function fU(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case Xc:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case lA:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case uA:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function hU(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null)
    return null;
  const t = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: i, maxMip: t };
}
function dU(n, e, t, i) {
  const r = n.getContext(), s = t.defines;
  let o = t.vertexShader, l = t.fragmentShader;
  const c = lU(t), f = uU(t), h = cU(t), d = fU(t), m = hU(t), v = t.isWebGL2 ? "" : eU(t), _ = tU(s), w = r.createProgram();
  let M, g, x = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (M = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    _
  ].filter(Gu).join(`
`), M.length > 0 && (M += `
`), g = [
    v,
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    _
  ].filter(Gu).join(`
`), g.length > 0 && (g += `
`)) : (M = [
    pM(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    _,
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + h : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + c : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Gu).join(`
`), g = [
    v,
    pM(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    _,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + f : "",
    t.envMap ? "#define " + h : "",
    t.envMap ? "#define " + d : "",
    m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "",
    m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "",
    m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + c : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== _r ? "#define TONE_MAPPING" : "",
    t.toneMapping !== _r ? gt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== _r ? $D("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    gt.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    QD("linearToOutputTexel", t.outputColorSpace),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(Gu).join(`
`)), o = Xv(o), o = fM(o, t), o = hM(o, t), l = Xv(l), l = fM(l, t), l = hM(l, t), o = dM(o), l = dM(l), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (x = `#version 300 es
`, M = [
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + M, g = [
    "#define varying in",
    t.glslVersion === Vv ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === Vv ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + g);
  const S = x + M + o, T = x + g + l, C = uM(r, r.VERTEX_SHADER, S), P = uM(r, r.FRAGMENT_SHADER, T);
  if (r.attachShader(w, C), r.attachShader(w, P), t.index0AttributeName !== void 0 ? r.bindAttribLocation(w, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(w, 0, "position"), r.linkProgram(w), n.debug.checkShaderErrors) {
    const R = r.getProgramInfoLog(w).trim(), b = r.getShaderInfoLog(C).trim(), G = r.getShaderInfoLog(P).trim();
    let $ = !0, Y = !0;
    if (r.getProgramParameter(w, r.LINK_STATUS) === !1)
      if ($ = !1, typeof n.debug.onShaderError == "function")
        n.debug.onShaderError(r, w, C, P);
      else {
        const K = cM(r, C, "vertex"), J = cM(r, P, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(w, r.VALIDATE_STATUS) + `

Program Info Log: ` + R + `
` + K + `
` + J
        );
      }
    else
      R !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", R) : (b === "" || G === "") && (Y = !1);
    Y && (this.diagnostics = {
      runnable: $,
      programLog: R,
      vertexShader: {
        log: b,
        prefix: M
      },
      fragmentShader: {
        log: G,
        prefix: g
      }
    });
  }
  r.deleteShader(C), r.deleteShader(P);
  let L;
  this.getUniforms = function() {
    return L === void 0 && (L = new Cd(r, w)), L;
  };
  let N;
  return this.getAttributes = function() {
    return N === void 0 && (N = nU(r, w)), N;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), r.deleteProgram(w), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = ZD++, this.cacheKey = e, this.usedTimes = 1, this.program = w, this.vertexShader = C, this.fragmentShader = P, this;
}
let pU = 0;
class mU {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, i = e.fragmentShader, r = this._getShaderStage(t), s = this._getShaderStage(i), o = this._getShaderCacheForMaterial(e);
    return o.has(r) === !1 && (o.add(r), r.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && (i = new gU(e), t.set(e, i)), i;
  }
}
class gU {
  constructor(e) {
    this.id = pU++, this.code = e, this.usedTimes = 0;
  }
}
function vU(n, e, t, i, r, s, o) {
  const l = new na(), c = new mU(), f = [], h = r.isWebGL2, d = r.logarithmicDepthBuffer, m = r.vertexTextures;
  let v = r.precision;
  const _ = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function w(R) {
    return R === 0 ? "uv" : `uv${R}`;
  }
  function M(R, b, G, $, Y) {
    const K = $.fog, J = Y.geometry, oe = R.isMeshStandardMaterial ? $.environment : null, ne = (R.isMeshStandardMaterial ? t : e).get(R.envMap || oe), O = ne && ne.mapping === ql ? ne.image.height : null, X = _[R.type];
    R.precision !== null && (v = r.getMaxPrecision(R.precision), v !== R.precision && console.warn("THREE.WebGLProgram.getParameters:", R.precision, "not supported, using", v, "instead."));
    const W = J.morphAttributes.position || J.morphAttributes.normal || J.morphAttributes.color, V = W !== void 0 ? W.length : 0;
    let j = 0;
    J.morphAttributes.position !== void 0 && (j = 1), J.morphAttributes.normal !== void 0 && (j = 2), J.morphAttributes.color !== void 0 && (j = 3);
    let de, ye, Te, Ie;
    if (X) {
      const Sn = mr[X];
      de = Sn.vertexShader, ye = Sn.fragmentShader;
    } else
      de = R.vertexShader, ye = R.fragmentShader, c.update(R), Te = c.getVertexShaderID(R), Ie = c.getFragmentShaderID(R);
    const Be = n.getRenderTarget(), je = Y.isInstancedMesh === !0, vt = !!R.map, lt = !!R.matcap, Re = !!ne, z = !!R.aoMap, ge = !!R.lightMap, fe = !!R.bumpMap, Se = !!R.normalMap, ve = !!R.displacementMap, He = !!R.emissiveMap, Oe = !!R.metalnessMap, Fe = !!R.roughnessMap, Je = R.anisotropy > 0, mt = R.clearcoat > 0, Ut = R.iridescence > 0, F = R.sheen > 0, I = R.transmission > 0, ae = Je && !!R.anisotropyMap, we = mt && !!R.clearcoatMap, _e = mt && !!R.clearcoatNormalMap, Pe = mt && !!R.clearcoatRoughnessMap, qe = Ut && !!R.iridescenceMap, be = Ut && !!R.iridescenceThicknessMap, ue = F && !!R.sheenColorMap, Qe = F && !!R.sheenRoughnessMap, $e = !!R.specularMap, et = !!R.specularColorMap, Ve = !!R.specularIntensityMap, B = I && !!R.transmissionMap, pe = I && !!R.thicknessMap, Ne = !!R.gradientMap, H = !!R.alphaMap, Me = R.alphaTest > 0, ie = !!R.alphaHash, Ae = !!R.extensions, De = !!J.attributes.uv1, Et = !!J.attributes.uv2, At = !!J.attributes.uv3;
    return {
      isWebGL2: h,
      shaderID: X,
      shaderType: R.type,
      shaderName: R.name,
      vertexShader: de,
      fragmentShader: ye,
      defines: R.defines,
      customVertexShaderID: Te,
      customFragmentShaderID: Ie,
      isRawShaderMaterial: R.isRawShaderMaterial === !0,
      glslVersion: R.glslVersion,
      precision: v,
      instancing: je,
      instancingColor: je && Y.instanceColor !== null,
      supportsVertexTextures: m,
      outputColorSpace: Be === null ? n.outputColorSpace : Be.isXRRenderTarget === !0 ? Be.texture.colorSpace : Sr,
      map: vt,
      matcap: lt,
      envMap: Re,
      envMapMode: Re && ne.mapping,
      envMapCubeUVHeight: O,
      aoMap: z,
      lightMap: ge,
      bumpMap: fe,
      normalMap: Se,
      displacementMap: m && ve,
      emissiveMap: He,
      normalMapObjectSpace: Se && R.normalMapType === RA,
      normalMapTangentSpace: Se && R.normalMapType === go,
      metalnessMap: Oe,
      roughnessMap: Fe,
      anisotropy: Je,
      anisotropyMap: ae,
      clearcoat: mt,
      clearcoatMap: we,
      clearcoatNormalMap: _e,
      clearcoatRoughnessMap: Pe,
      iridescence: Ut,
      iridescenceMap: qe,
      iridescenceThicknessMap: be,
      sheen: F,
      sheenColorMap: ue,
      sheenRoughnessMap: Qe,
      specularMap: $e,
      specularColorMap: et,
      specularIntensityMap: Ve,
      transmission: I,
      transmissionMap: B,
      thicknessMap: pe,
      gradientMap: Ne,
      opaque: R.transparent === !1 && R.blending === ea,
      alphaMap: H,
      alphaTest: Me,
      alphaHash: ie,
      combine: R.combine,
      //
      mapUv: vt && w(R.map.channel),
      aoMapUv: z && w(R.aoMap.channel),
      lightMapUv: ge && w(R.lightMap.channel),
      bumpMapUv: fe && w(R.bumpMap.channel),
      normalMapUv: Se && w(R.normalMap.channel),
      displacementMapUv: ve && w(R.displacementMap.channel),
      emissiveMapUv: He && w(R.emissiveMap.channel),
      metalnessMapUv: Oe && w(R.metalnessMap.channel),
      roughnessMapUv: Fe && w(R.roughnessMap.channel),
      anisotropyMapUv: ae && w(R.anisotropyMap.channel),
      clearcoatMapUv: we && w(R.clearcoatMap.channel),
      clearcoatNormalMapUv: _e && w(R.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Pe && w(R.clearcoatRoughnessMap.channel),
      iridescenceMapUv: qe && w(R.iridescenceMap.channel),
      iridescenceThicknessMapUv: be && w(R.iridescenceThicknessMap.channel),
      sheenColorMapUv: ue && w(R.sheenColorMap.channel),
      sheenRoughnessMapUv: Qe && w(R.sheenRoughnessMap.channel),
      specularMapUv: $e && w(R.specularMap.channel),
      specularColorMapUv: et && w(R.specularColorMap.channel),
      specularIntensityMapUv: Ve && w(R.specularIntensityMap.channel),
      transmissionMapUv: B && w(R.transmissionMap.channel),
      thicknessMapUv: pe && w(R.thicknessMap.channel),
      alphaMapUv: H && w(R.alphaMap.channel),
      //
      vertexTangents: !!J.attributes.tangent && (Se || Je),
      vertexColors: R.vertexColors,
      vertexAlphas: R.vertexColors === !0 && !!J.attributes.color && J.attributes.color.itemSize === 4,
      vertexUv1s: De,
      vertexUv2s: Et,
      vertexUv3s: At,
      pointsUvs: Y.isPoints === !0 && !!J.attributes.uv && (vt || H),
      fog: !!K,
      useFog: R.fog === !0,
      fogExp2: K && K.isFogExp2,
      flatShading: R.flatShading === !0,
      sizeAttenuation: R.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      skinning: Y.isSkinnedMesh === !0,
      morphTargets: J.morphAttributes.position !== void 0,
      morphNormals: J.morphAttributes.normal !== void 0,
      morphColors: J.morphAttributes.color !== void 0,
      morphTargetsCount: V,
      morphTextureStride: j,
      numDirLights: b.directional.length,
      numPointLights: b.point.length,
      numSpotLights: b.spot.length,
      numSpotLightMaps: b.spotLightMap.length,
      numRectAreaLights: b.rectArea.length,
      numHemiLights: b.hemi.length,
      numDirLightShadows: b.directionalShadowMap.length,
      numPointLightShadows: b.pointShadowMap.length,
      numSpotLightShadows: b.spotShadowMap.length,
      numSpotLightShadowsWithMaps: b.numSpotLightShadowsWithMaps,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: R.dithering,
      shadowMapEnabled: n.shadowMap.enabled && G.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: R.toneMapped ? n.toneMapping : _r,
      useLegacyLights: n.useLegacyLights,
      premultipliedAlpha: R.premultipliedAlpha,
      doubleSided: R.side === gr,
      flipSided: R.side === ai,
      useDepthPacking: R.depthPacking >= 0,
      depthPacking: R.depthPacking || 0,
      index0AttributeName: R.index0AttributeName,
      extensionDerivatives: Ae && R.extensions.derivatives === !0,
      extensionFragDepth: Ae && R.extensions.fragDepth === !0,
      extensionDrawBuffers: Ae && R.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: Ae && R.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
      customProgramCacheKey: R.customProgramCacheKey()
    };
  }
  function g(R) {
    const b = [];
    if (R.shaderID ? b.push(R.shaderID) : (b.push(R.customVertexShaderID), b.push(R.customFragmentShaderID)), R.defines !== void 0)
      for (const G in R.defines)
        b.push(G), b.push(R.defines[G]);
    return R.isRawShaderMaterial === !1 && (x(b, R), S(b, R), b.push(n.outputColorSpace)), b.push(R.customProgramCacheKey), b.join();
  }
  function x(R, b) {
    R.push(b.precision), R.push(b.outputColorSpace), R.push(b.envMapMode), R.push(b.envMapCubeUVHeight), R.push(b.mapUv), R.push(b.alphaMapUv), R.push(b.lightMapUv), R.push(b.aoMapUv), R.push(b.bumpMapUv), R.push(b.normalMapUv), R.push(b.displacementMapUv), R.push(b.emissiveMapUv), R.push(b.metalnessMapUv), R.push(b.roughnessMapUv), R.push(b.anisotropyMapUv), R.push(b.clearcoatMapUv), R.push(b.clearcoatNormalMapUv), R.push(b.clearcoatRoughnessMapUv), R.push(b.iridescenceMapUv), R.push(b.iridescenceThicknessMapUv), R.push(b.sheenColorMapUv), R.push(b.sheenRoughnessMapUv), R.push(b.specularMapUv), R.push(b.specularColorMapUv), R.push(b.specularIntensityMapUv), R.push(b.transmissionMapUv), R.push(b.thicknessMapUv), R.push(b.combine), R.push(b.fogExp2), R.push(b.sizeAttenuation), R.push(b.morphTargetsCount), R.push(b.morphAttributeCount), R.push(b.numDirLights), R.push(b.numPointLights), R.push(b.numSpotLights), R.push(b.numSpotLightMaps), R.push(b.numHemiLights), R.push(b.numRectAreaLights), R.push(b.numDirLightShadows), R.push(b.numPointLightShadows), R.push(b.numSpotLightShadows), R.push(b.numSpotLightShadowsWithMaps), R.push(b.shadowMapType), R.push(b.toneMapping), R.push(b.numClippingPlanes), R.push(b.numClipIntersection), R.push(b.depthPacking);
  }
  function S(R, b) {
    l.disableAll(), b.isWebGL2 && l.enable(0), b.supportsVertexTextures && l.enable(1), b.instancing && l.enable(2), b.instancingColor && l.enable(3), b.matcap && l.enable(4), b.envMap && l.enable(5), b.normalMapObjectSpace && l.enable(6), b.normalMapTangentSpace && l.enable(7), b.clearcoat && l.enable(8), b.iridescence && l.enable(9), b.alphaTest && l.enable(10), b.vertexColors && l.enable(11), b.vertexAlphas && l.enable(12), b.vertexUv1s && l.enable(13), b.vertexUv2s && l.enable(14), b.vertexUv3s && l.enable(15), b.vertexTangents && l.enable(16), b.anisotropy && l.enable(17), R.push(l.mask), l.disableAll(), b.fog && l.enable(0), b.useFog && l.enable(1), b.flatShading && l.enable(2), b.logarithmicDepthBuffer && l.enable(3), b.skinning && l.enable(4), b.morphTargets && l.enable(5), b.morphNormals && l.enable(6), b.morphColors && l.enable(7), b.premultipliedAlpha && l.enable(8), b.shadowMapEnabled && l.enable(9), b.useLegacyLights && l.enable(10), b.doubleSided && l.enable(11), b.flipSided && l.enable(12), b.useDepthPacking && l.enable(13), b.dithering && l.enable(14), b.transmission && l.enable(15), b.sheen && l.enable(16), b.opaque && l.enable(17), b.pointsUvs && l.enable(18), R.push(l.mask);
  }
  function T(R) {
    const b = _[R.type];
    let G;
    if (b) {
      const $ = mr[b];
      G = GA.clone($.uniforms);
    } else
      G = R.uniforms;
    return G;
  }
  function C(R, b) {
    let G;
    for (let $ = 0, Y = f.length; $ < Y; $++) {
      const K = f[$];
      if (K.cacheKey === b) {
        G = K, ++G.usedTimes;
        break;
      }
    }
    return G === void 0 && (G = new dU(n, b, R, s), f.push(G)), G;
  }
  function P(R) {
    if (--R.usedTimes === 0) {
      const b = f.indexOf(R);
      f[b] = f[f.length - 1], f.pop(), R.destroy();
    }
  }
  function L(R) {
    c.remove(R);
  }
  function N() {
    c.dispose();
  }
  return {
    getParameters: M,
    getProgramCacheKey: g,
    getUniforms: T,
    acquireProgram: C,
    releaseProgram: P,
    releaseShaderCache: L,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: f,
    dispose: N
  };
}
function yU() {
  let n = /* @__PURE__ */ new WeakMap();
  function e(s) {
    let o = n.get(s);
    return o === void 0 && (o = {}, n.set(s, o)), o;
  }
  function t(s) {
    n.delete(s);
  }
  function i(s, o, l) {
    n.get(s)[o] = l;
  }
  function r() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: i,
    dispose: r
  };
}
function _U(n, e) {
  return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id;
}
function mM(n, e) {
  return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id;
}
function gM() {
  const n = [];
  let e = 0;
  const t = [], i = [], r = [];
  function s() {
    e = 0, t.length = 0, i.length = 0, r.length = 0;
  }
  function o(d, m, v, _, w, M) {
    let g = n[e];
    return g === void 0 ? (g = {
      id: d.id,
      object: d,
      geometry: m,
      material: v,
      groupOrder: _,
      renderOrder: d.renderOrder,
      z: w,
      group: M
    }, n[e] = g) : (g.id = d.id, g.object = d, g.geometry = m, g.material = v, g.groupOrder = _, g.renderOrder = d.renderOrder, g.z = w, g.group = M), e++, g;
  }
  function l(d, m, v, _, w, M) {
    const g = o(d, m, v, _, w, M);
    v.transmission > 0 ? i.push(g) : v.transparent === !0 ? r.push(g) : t.push(g);
  }
  function c(d, m, v, _, w, M) {
    const g = o(d, m, v, _, w, M);
    v.transmission > 0 ? i.unshift(g) : v.transparent === !0 ? r.unshift(g) : t.unshift(g);
  }
  function f(d, m) {
    t.length > 1 && t.sort(d || _U), i.length > 1 && i.sort(m || mM), r.length > 1 && r.sort(m || mM);
  }
  function h() {
    for (let d = e, m = n.length; d < m; d++) {
      const v = n[d];
      if (v.id === null)
        break;
      v.id = null, v.object = null, v.geometry = null, v.material = null, v.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: l,
    unshift: c,
    finish: h,
    sort: f
  };
}
function xU() {
  let n = /* @__PURE__ */ new WeakMap();
  function e(i, r) {
    const s = n.get(i);
    let o;
    return s === void 0 ? (o = new gM(), n.set(i, [o])) : r >= s.length ? (o = new gM(), s.push(o)) : o = s[r], o;
  }
  function t() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function SU() {
  const n = {};
  return {
    get: function(e) {
      if (n[e.id] !== void 0)
        return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new D(),
            color: new ze()
          };
          break;
        case "SpotLight":
          t = {
            position: new D(),
            direction: new D(),
            color: new ze(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new D(),
            color: new ze(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new D(),
            skyColor: new ze(),
            groundColor: new ze()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new ze(),
            position: new D(),
            halfWidth: new D(),
            halfHeight: new D()
          };
          break;
      }
      return n[e.id] = t, t;
    }
  };
}
function MU() {
  const n = {};
  return {
    get: function(e) {
      if (n[e.id] !== void 0)
        return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new me()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new me()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new me(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return n[e.id] = t, t;
    }
  };
}
let wU = 0;
function EU(n, e) {
  return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0);
}
function TU(n, e) {
  const t = new SU(), i = MU(), r = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0
  };
  for (let h = 0; h < 9; h++)
    r.probe.push(new D());
  const s = new D(), o = new dt(), l = new dt();
  function c(h, d) {
    let m = 0, v = 0, _ = 0;
    for (let G = 0; G < 9; G++)
      r.probe[G].set(0, 0, 0);
    let w = 0, M = 0, g = 0, x = 0, S = 0, T = 0, C = 0, P = 0, L = 0, N = 0;
    h.sort(EU);
    const R = d === !0 ? Math.PI : 1;
    for (let G = 0, $ = h.length; G < $; G++) {
      const Y = h[G], K = Y.color, J = Y.intensity, oe = Y.distance, ne = Y.shadow && Y.shadow.map ? Y.shadow.map.texture : null;
      if (Y.isAmbientLight)
        m += K.r * J * R, v += K.g * J * R, _ += K.b * J * R;
      else if (Y.isLightProbe)
        for (let O = 0; O < 9; O++)
          r.probe[O].addScaledVector(Y.sh.coefficients[O], J);
      else if (Y.isDirectionalLight) {
        const O = t.get(Y);
        if (O.color.copy(Y.color).multiplyScalar(Y.intensity * R), Y.castShadow) {
          const X = Y.shadow, W = i.get(Y);
          W.shadowBias = X.bias, W.shadowNormalBias = X.normalBias, W.shadowRadius = X.radius, W.shadowMapSize = X.mapSize, r.directionalShadow[w] = W, r.directionalShadowMap[w] = ne, r.directionalShadowMatrix[w] = Y.shadow.matrix, T++;
        }
        r.directional[w] = O, w++;
      } else if (Y.isSpotLight) {
        const O = t.get(Y);
        O.position.setFromMatrixPosition(Y.matrixWorld), O.color.copy(K).multiplyScalar(J * R), O.distance = oe, O.coneCos = Math.cos(Y.angle), O.penumbraCos = Math.cos(Y.angle * (1 - Y.penumbra)), O.decay = Y.decay, r.spot[g] = O;
        const X = Y.shadow;
        if (Y.map && (r.spotLightMap[L] = Y.map, L++, X.updateMatrices(Y), Y.castShadow && N++), r.spotLightMatrix[g] = X.matrix, Y.castShadow) {
          const W = i.get(Y);
          W.shadowBias = X.bias, W.shadowNormalBias = X.normalBias, W.shadowRadius = X.radius, W.shadowMapSize = X.mapSize, r.spotShadow[g] = W, r.spotShadowMap[g] = ne, P++;
        }
        g++;
      } else if (Y.isRectAreaLight) {
        const O = t.get(Y);
        O.color.copy(K).multiplyScalar(J), O.halfWidth.set(Y.width * 0.5, 0, 0), O.halfHeight.set(0, Y.height * 0.5, 0), r.rectArea[x] = O, x++;
      } else if (Y.isPointLight) {
        const O = t.get(Y);
        if (O.color.copy(Y.color).multiplyScalar(Y.intensity * R), O.distance = Y.distance, O.decay = Y.decay, Y.castShadow) {
          const X = Y.shadow, W = i.get(Y);
          W.shadowBias = X.bias, W.shadowNormalBias = X.normalBias, W.shadowRadius = X.radius, W.shadowMapSize = X.mapSize, W.shadowCameraNear = X.camera.near, W.shadowCameraFar = X.camera.far, r.pointShadow[M] = W, r.pointShadowMap[M] = ne, r.pointShadowMatrix[M] = Y.shadow.matrix, C++;
        }
        r.point[M] = O, M++;
      } else if (Y.isHemisphereLight) {
        const O = t.get(Y);
        O.skyColor.copy(Y.color).multiplyScalar(J * R), O.groundColor.copy(Y.groundColor).multiplyScalar(J * R), r.hemi[S] = O, S++;
      }
    }
    x > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Le.LTC_FLOAT_1, r.rectAreaLTC2 = Le.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Le.LTC_HALF_1, r.rectAreaLTC2 = Le.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = m, r.ambient[1] = v, r.ambient[2] = _;
    const b = r.hash;
    (b.directionalLength !== w || b.pointLength !== M || b.spotLength !== g || b.rectAreaLength !== x || b.hemiLength !== S || b.numDirectionalShadows !== T || b.numPointShadows !== C || b.numSpotShadows !== P || b.numSpotMaps !== L) && (r.directional.length = w, r.spot.length = g, r.rectArea.length = x, r.point.length = M, r.hemi.length = S, r.directionalShadow.length = T, r.directionalShadowMap.length = T, r.pointShadow.length = C, r.pointShadowMap.length = C, r.spotShadow.length = P, r.spotShadowMap.length = P, r.directionalShadowMatrix.length = T, r.pointShadowMatrix.length = C, r.spotLightMatrix.length = P + L - N, r.spotLightMap.length = L, r.numSpotLightShadowsWithMaps = N, b.directionalLength = w, b.pointLength = M, b.spotLength = g, b.rectAreaLength = x, b.hemiLength = S, b.numDirectionalShadows = T, b.numPointShadows = C, b.numSpotShadows = P, b.numSpotMaps = L, r.version = wU++);
  }
  function f(h, d) {
    let m = 0, v = 0, _ = 0, w = 0, M = 0;
    const g = d.matrixWorldInverse;
    for (let x = 0, S = h.length; x < S; x++) {
      const T = h[x];
      if (T.isDirectionalLight) {
        const C = r.directional[m];
        C.direction.setFromMatrixPosition(T.matrixWorld), s.setFromMatrixPosition(T.target.matrixWorld), C.direction.sub(s), C.direction.transformDirection(g), m++;
      } else if (T.isSpotLight) {
        const C = r.spot[_];
        C.position.setFromMatrixPosition(T.matrixWorld), C.position.applyMatrix4(g), C.direction.setFromMatrixPosition(T.matrixWorld), s.setFromMatrixPosition(T.target.matrixWorld), C.direction.sub(s), C.direction.transformDirection(g), _++;
      } else if (T.isRectAreaLight) {
        const C = r.rectArea[w];
        C.position.setFromMatrixPosition(T.matrixWorld), C.position.applyMatrix4(g), l.identity(), o.copy(T.matrixWorld), o.premultiply(g), l.extractRotation(o), C.halfWidth.set(T.width * 0.5, 0, 0), C.halfHeight.set(0, T.height * 0.5, 0), C.halfWidth.applyMatrix4(l), C.halfHeight.applyMatrix4(l), w++;
      } else if (T.isPointLight) {
        const C = r.point[v];
        C.position.setFromMatrixPosition(T.matrixWorld), C.position.applyMatrix4(g), v++;
      } else if (T.isHemisphereLight) {
        const C = r.hemi[M];
        C.direction.setFromMatrixPosition(T.matrixWorld), C.direction.transformDirection(g), M++;
      }
    }
  }
  return {
    setup: c,
    setupView: f,
    state: r
  };
}
function vM(n, e) {
  const t = new TU(n, e), i = [], r = [];
  function s() {
    i.length = 0, r.length = 0;
  }
  function o(d) {
    i.push(d);
  }
  function l(d) {
    r.push(d);
  }
  function c(d) {
    t.setup(i, d);
  }
  function f(d) {
    t.setupView(i, d);
  }
  return {
    init: s,
    state: {
      lightsArray: i,
      shadowsArray: r,
      lights: t
    },
    setupLights: c,
    setupLightsView: f,
    pushLight: o,
    pushShadow: l
  };
}
function AU(n, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function i(s, o = 0) {
    const l = t.get(s);
    let c;
    return l === void 0 ? (c = new vM(n, e), t.set(s, [c])) : o >= l.length ? (c = new vM(n, e), l.push(c)) : c = l[o], c;
  }
  function r() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: r
  };
}
class v_ extends ei {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = AA, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class y_ extends ei {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const CU = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, RU = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function PU(n, e, t) {
  let i = new Cp();
  const r = new me(), s = new me(), o = new kt(), l = new v_({ depthPacking: CA }), c = new y_(), f = {}, h = t.maxTextureSize, d = { [Ms]: ai, [ai]: Ms, [gr]: gr }, m = new Wr({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new me() },
      radius: { value: 4 }
    },
    vertexShader: CU,
    fragmentShader: RU
  }), v = m.clone();
  v.defines.HORIZONTAL_PASS = 1;
  const _ = new wt();
  _.setAttribute(
    "position",
    new Ht(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const w = new kn(_, m), M = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Mp;
  let g = this.type;
  this.render = function(C, P, L) {
    if (M.enabled === !1 || M.autoUpdate === !1 && M.needsUpdate === !1 || C.length === 0)
      return;
    const N = n.getRenderTarget(), R = n.getActiveCubeFace(), b = n.getActiveMipmapLevel(), G = n.state;
    G.setBlending(vs), G.buffers.color.setClear(1, 1, 1, 1), G.buffers.depth.setTest(!0), G.setScissorTest(!1);
    const $ = g !== hr && this.type === hr, Y = g === hr && this.type !== hr;
    for (let K = 0, J = C.length; K < J; K++) {
      const oe = C[K], ne = oe.shadow;
      if (ne === void 0) {
        console.warn("THREE.WebGLShadowMap:", oe, "has no shadow.");
        continue;
      }
      if (ne.autoUpdate === !1 && ne.needsUpdate === !1)
        continue;
      r.copy(ne.mapSize);
      const O = ne.getFrameExtents();
      if (r.multiply(O), s.copy(ne.mapSize), (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / O.x), r.x = s.x * O.x, ne.mapSize.x = s.x), r.y > h && (s.y = Math.floor(h / O.y), r.y = s.y * O.y, ne.mapSize.y = s.y)), ne.map === null || $ === !0 || Y === !0) {
        const W = this.type !== hr ? { minFilter: hn, magFilter: hn } : {};
        ne.map !== null && ne.map.dispose(), ne.map = new Mr(r.x, r.y, W), ne.map.texture.name = oe.name + ".shadowMap", ne.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(ne.map), n.clear();
      const X = ne.getViewportCount();
      for (let W = 0; W < X; W++) {
        const V = ne.getViewport(W);
        o.set(
          s.x * V.x,
          s.y * V.y,
          s.x * V.z,
          s.y * V.w
        ), G.viewport(o), ne.updateMatrices(oe, W), i = ne.getFrustum(), T(P, L, ne.camera, oe, this.type);
      }
      ne.isPointLightShadow !== !0 && this.type === hr && x(ne, L), ne.needsUpdate = !1;
    }
    g = this.type, M.needsUpdate = !1, n.setRenderTarget(N, R, b);
  };
  function x(C, P) {
    const L = e.update(w);
    m.defines.VSM_SAMPLES !== C.blurSamples && (m.defines.VSM_SAMPLES = C.blurSamples, v.defines.VSM_SAMPLES = C.blurSamples, m.needsUpdate = !0, v.needsUpdate = !0), C.mapPass === null && (C.mapPass = new Mr(r.x, r.y)), m.uniforms.shadow_pass.value = C.map.texture, m.uniforms.resolution.value = C.mapSize, m.uniforms.radius.value = C.radius, n.setRenderTarget(C.mapPass), n.clear(), n.renderBufferDirect(P, null, L, m, w, null), v.uniforms.shadow_pass.value = C.mapPass.texture, v.uniforms.resolution.value = C.mapSize, v.uniforms.radius.value = C.radius, n.setRenderTarget(C.map), n.clear(), n.renderBufferDirect(P, null, L, v, w, null);
  }
  function S(C, P, L, N) {
    let R = null;
    const b = L.isPointLight === !0 ? C.customDistanceMaterial : C.customDepthMaterial;
    if (b !== void 0)
      R = b;
    else if (R = L.isPointLight === !0 ? c : l, n.localClippingEnabled && P.clipShadows === !0 && Array.isArray(P.clippingPlanes) && P.clippingPlanes.length !== 0 || P.displacementMap && P.displacementScale !== 0 || P.alphaMap && P.alphaTest > 0 || P.map && P.alphaTest > 0) {
      const G = R.uuid, $ = P.uuid;
      let Y = f[G];
      Y === void 0 && (Y = {}, f[G] = Y);
      let K = Y[$];
      K === void 0 && (K = R.clone(), Y[$] = K), R = K;
    }
    if (R.visible = P.visible, R.wireframe = P.wireframe, N === hr ? R.side = P.shadowSide !== null ? P.shadowSide : P.side : R.side = P.shadowSide !== null ? P.shadowSide : d[P.side], R.alphaMap = P.alphaMap, R.alphaTest = P.alphaTest, R.map = P.map, R.clipShadows = P.clipShadows, R.clippingPlanes = P.clippingPlanes, R.clipIntersection = P.clipIntersection, R.displacementMap = P.displacementMap, R.displacementScale = P.displacementScale, R.displacementBias = P.displacementBias, R.wireframeLinewidth = P.wireframeLinewidth, R.linewidth = P.linewidth, L.isPointLight === !0 && R.isMeshDistanceMaterial === !0) {
      const G = n.properties.get(R);
      G.light = L;
    }
    return R;
  }
  function T(C, P, L, N, R) {
    if (C.visible === !1)
      return;
    if (C.layers.test(P.layers) && (C.isMesh || C.isLine || C.isPoints) && (C.castShadow || C.receiveShadow && R === hr) && (!C.frustumCulled || i.intersectsObject(C))) {
      C.modelViewMatrix.multiplyMatrices(L.matrixWorldInverse, C.matrixWorld);
      const $ = e.update(C), Y = C.material;
      if (Array.isArray(Y)) {
        const K = $.groups;
        for (let J = 0, oe = K.length; J < oe; J++) {
          const ne = K[J], O = Y[ne.materialIndex];
          if (O && O.visible) {
            const X = S(C, O, N, R);
            n.renderBufferDirect(L, null, $, X, C, ne);
          }
        }
      } else if (Y.visible) {
        const K = S(C, Y, N, R);
        n.renderBufferDirect(L, null, $, K, C, null);
      }
    }
    const G = C.children;
    for (let $ = 0, Y = G.length; $ < Y; $++)
      T(G[$], P, L, N, R);
  }
}
function bU(n, e, t) {
  const i = t.isWebGL2;
  function r() {
    let H = !1;
    const Me = new kt();
    let ie = null;
    const Ae = new kt(0, 0, 0, 0);
    return {
      setMask: function(De) {
        ie !== De && !H && (n.colorMask(De, De, De, De), ie = De);
      },
      setLocked: function(De) {
        H = De;
      },
      setClear: function(De, Et, At, Dt, Sn) {
        Sn === !0 && (De *= Dt, Et *= Dt, At *= Dt), Me.set(De, Et, At, Dt), Ae.equals(Me) === !1 && (n.clearColor(De, Et, At, Dt), Ae.copy(Me));
      },
      reset: function() {
        H = !1, ie = null, Ae.set(-1, 0, 0, 0);
      }
    };
  }
  function s() {
    let H = !1, Me = null, ie = null, Ae = null;
    return {
      setTest: function(De) {
        De ? Be(n.DEPTH_TEST) : je(n.DEPTH_TEST);
      },
      setMask: function(De) {
        Me !== De && !H && (n.depthMask(De), Me = De);
      },
      setFunc: function(De) {
        if (ie !== De) {
          switch (De) {
            case tA:
              n.depthFunc(n.NEVER);
              break;
            case nA:
              n.depthFunc(n.ALWAYS);
              break;
            case iA:
              n.depthFunc(n.LESS);
              break;
            case $d:
              n.depthFunc(n.LEQUAL);
              break;
            case rA:
              n.depthFunc(n.EQUAL);
              break;
            case sA:
              n.depthFunc(n.GEQUAL);
              break;
            case oA:
              n.depthFunc(n.GREATER);
              break;
            case aA:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          ie = De;
        }
      },
      setLocked: function(De) {
        H = De;
      },
      setClear: function(De) {
        Ae !== De && (n.clearDepth(De), Ae = De);
      },
      reset: function() {
        H = !1, Me = null, ie = null, Ae = null;
      }
    };
  }
  function o() {
    let H = !1, Me = null, ie = null, Ae = null, De = null, Et = null, At = null, Dt = null, Sn = null;
    return {
      setTest: function(Nt) {
        H || (Nt ? Be(n.STENCIL_TEST) : je(n.STENCIL_TEST));
      },
      setMask: function(Nt) {
        Me !== Nt && !H && (n.stencilMask(Nt), Me = Nt);
      },
      setFunc: function(Nt, Mn, nn) {
        (ie !== Nt || Ae !== Mn || De !== nn) && (n.stencilFunc(Nt, Mn, nn), ie = Nt, Ae = Mn, De = nn);
      },
      setOp: function(Nt, Mn, nn) {
        (Et !== Nt || At !== Mn || Dt !== nn) && (n.stencilOp(Nt, Mn, nn), Et = Nt, At = Mn, Dt = nn);
      },
      setLocked: function(Nt) {
        H = Nt;
      },
      setClear: function(Nt) {
        Sn !== Nt && (n.clearStencil(Nt), Sn = Nt);
      },
      reset: function() {
        H = !1, Me = null, ie = null, Ae = null, De = null, Et = null, At = null, Dt = null, Sn = null;
      }
    };
  }
  const l = new r(), c = new s(), f = new o(), h = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap();
  let m = {}, v = {}, _ = /* @__PURE__ */ new WeakMap(), w = [], M = null, g = !1, x = null, S = null, T = null, C = null, P = null, L = null, N = null, R = !1, b = null, G = null, $ = null, Y = null, K = null;
  const J = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let oe = !1, ne = 0;
  const O = n.getParameter(n.VERSION);
  O.indexOf("WebGL") !== -1 ? (ne = parseFloat(/^WebGL (\d)/.exec(O)[1]), oe = ne >= 1) : O.indexOf("OpenGL ES") !== -1 && (ne = parseFloat(/^OpenGL ES (\d)/.exec(O)[1]), oe = ne >= 2);
  let X = null, W = {};
  const V = n.getParameter(n.SCISSOR_BOX), j = n.getParameter(n.VIEWPORT), de = new kt().fromArray(V), ye = new kt().fromArray(j);
  function Te(H, Me, ie, Ae) {
    const De = new Uint8Array(4), Et = n.createTexture();
    n.bindTexture(H, Et), n.texParameteri(H, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(H, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let At = 0; At < ie; At++)
      i && (H === n.TEXTURE_3D || H === n.TEXTURE_2D_ARRAY) ? n.texImage3D(Me, 0, n.RGBA, 1, 1, Ae, 0, n.RGBA, n.UNSIGNED_BYTE, De) : n.texImage2D(Me + At, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, De);
    return Et;
  }
  const Ie = {};
  Ie[n.TEXTURE_2D] = Te(n.TEXTURE_2D, n.TEXTURE_2D, 1), Ie[n.TEXTURE_CUBE_MAP] = Te(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i && (Ie[n.TEXTURE_2D_ARRAY] = Te(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), Ie[n.TEXTURE_3D] = Te(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)), l.setClear(0, 0, 0, 1), c.setClear(1), f.setClear(0), Be(n.DEPTH_TEST), c.setFunc($d), ve(!1), He(dv), Be(n.CULL_FACE), fe(vs);
  function Be(H) {
    m[H] !== !0 && (n.enable(H), m[H] = !0);
  }
  function je(H) {
    m[H] !== !1 && (n.disable(H), m[H] = !1);
  }
  function vt(H, Me) {
    return v[H] !== Me ? (n.bindFramebuffer(H, Me), v[H] = Me, i && (H === n.DRAW_FRAMEBUFFER && (v[n.FRAMEBUFFER] = Me), H === n.FRAMEBUFFER && (v[n.DRAW_FRAMEBUFFER] = Me)), !0) : !1;
  }
  function lt(H, Me) {
    let ie = w, Ae = !1;
    if (H)
      if (ie = _.get(Me), ie === void 0 && (ie = [], _.set(Me, ie)), H.isWebGLMultipleRenderTargets) {
        const De = H.texture;
        if (ie.length !== De.length || ie[0] !== n.COLOR_ATTACHMENT0) {
          for (let Et = 0, At = De.length; Et < At; Et++)
            ie[Et] = n.COLOR_ATTACHMENT0 + Et;
          ie.length = De.length, Ae = !0;
        }
      } else
        ie[0] !== n.COLOR_ATTACHMENT0 && (ie[0] = n.COLOR_ATTACHMENT0, Ae = !0);
    else
      ie[0] !== n.BACK && (ie[0] = n.BACK, Ae = !0);
    Ae && (t.isWebGL2 ? n.drawBuffers(ie) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(ie));
  }
  function Re(H) {
    return M !== H ? (n.useProgram(H), M = H, !0) : !1;
  }
  const z = {
    [Go]: n.FUNC_ADD,
    [WT]: n.FUNC_SUBTRACT,
    [XT]: n.FUNC_REVERSE_SUBTRACT
  };
  if (i)
    z[vv] = n.MIN, z[yv] = n.MAX;
  else {
    const H = e.get("EXT_blend_minmax");
    H !== null && (z[vv] = H.MIN_EXT, z[yv] = H.MAX_EXT);
  }
  const ge = {
    [jT]: n.ZERO,
    [YT]: n.ONE,
    [qT]: n.SRC_COLOR,
    [Qy]: n.SRC_ALPHA,
    [eA]: n.SRC_ALPHA_SATURATE,
    [QT]: n.DST_COLOR,
    [KT]: n.DST_ALPHA,
    [ZT]: n.ONE_MINUS_SRC_COLOR,
    [$y]: n.ONE_MINUS_SRC_ALPHA,
    [$T]: n.ONE_MINUS_DST_COLOR,
    [JT]: n.ONE_MINUS_DST_ALPHA
  };
  function fe(H, Me, ie, Ae, De, Et, At, Dt) {
    if (H === vs) {
      g === !0 && (je(n.BLEND), g = !1);
      return;
    }
    if (g === !1 && (Be(n.BLEND), g = !0), H !== GT) {
      if (H !== x || Dt !== R) {
        if ((S !== Go || P !== Go) && (n.blendEquation(n.FUNC_ADD), S = Go, P = Go), Dt)
          switch (H) {
            case ea:
              n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case pv:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case mv:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case gv:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", H);
              break;
          }
        else
          switch (H) {
            case ea:
              n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
              break;
            case pv:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case mv:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case gv:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", H);
              break;
          }
        T = null, C = null, L = null, N = null, x = H, R = Dt;
      }
      return;
    }
    De = De || Me, Et = Et || ie, At = At || Ae, (Me !== S || De !== P) && (n.blendEquationSeparate(z[Me], z[De]), S = Me, P = De), (ie !== T || Ae !== C || Et !== L || At !== N) && (n.blendFuncSeparate(ge[ie], ge[Ae], ge[Et], ge[At]), T = ie, C = Ae, L = Et, N = At), x = H, R = !1;
  }
  function Se(H, Me) {
    H.side === gr ? je(n.CULL_FACE) : Be(n.CULL_FACE);
    let ie = H.side === ai;
    Me && (ie = !ie), ve(ie), H.blending === ea && H.transparent === !1 ? fe(vs) : fe(H.blending, H.blendEquation, H.blendSrc, H.blendDst, H.blendEquationAlpha, H.blendSrcAlpha, H.blendDstAlpha, H.premultipliedAlpha), c.setFunc(H.depthFunc), c.setTest(H.depthTest), c.setMask(H.depthWrite), l.setMask(H.colorWrite);
    const Ae = H.stencilWrite;
    f.setTest(Ae), Ae && (f.setMask(H.stencilWriteMask), f.setFunc(H.stencilFunc, H.stencilRef, H.stencilFuncMask), f.setOp(H.stencilFail, H.stencilZFail, H.stencilZPass)), Fe(H.polygonOffset, H.polygonOffsetFactor, H.polygonOffsetUnits), H.alphaToCoverage === !0 ? Be(n.SAMPLE_ALPHA_TO_COVERAGE) : je(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function ve(H) {
    b !== H && (H ? n.frontFace(n.CW) : n.frontFace(n.CCW), b = H);
  }
  function He(H) {
    H !== BT ? (Be(n.CULL_FACE), H !== G && (H === dv ? n.cullFace(n.BACK) : H === HT ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : je(n.CULL_FACE), G = H;
  }
  function Oe(H) {
    H !== $ && (oe && n.lineWidth(H), $ = H);
  }
  function Fe(H, Me, ie) {
    H ? (Be(n.POLYGON_OFFSET_FILL), (Y !== Me || K !== ie) && (n.polygonOffset(Me, ie), Y = Me, K = ie)) : je(n.POLYGON_OFFSET_FILL);
  }
  function Je(H) {
    H ? Be(n.SCISSOR_TEST) : je(n.SCISSOR_TEST);
  }
  function mt(H) {
    H === void 0 && (H = n.TEXTURE0 + J - 1), X !== H && (n.activeTexture(H), X = H);
  }
  function Ut(H, Me, ie) {
    ie === void 0 && (X === null ? ie = n.TEXTURE0 + J - 1 : ie = X);
    let Ae = W[ie];
    Ae === void 0 && (Ae = { type: void 0, texture: void 0 }, W[ie] = Ae), (Ae.type !== H || Ae.texture !== Me) && (X !== ie && (n.activeTexture(ie), X = ie), n.bindTexture(H, Me || Ie[H]), Ae.type = H, Ae.texture = Me);
  }
  function F() {
    const H = W[X];
    H !== void 0 && H.type !== void 0 && (n.bindTexture(H.type, null), H.type = void 0, H.texture = void 0);
  }
  function I() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (H) {
      console.error("THREE.WebGLState:", H);
    }
  }
  function ae() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (H) {
      console.error("THREE.WebGLState:", H);
    }
  }
  function we() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (H) {
      console.error("THREE.WebGLState:", H);
    }
  }
  function _e() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (H) {
      console.error("THREE.WebGLState:", H);
    }
  }
  function Pe() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (H) {
      console.error("THREE.WebGLState:", H);
    }
  }
  function qe() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (H) {
      console.error("THREE.WebGLState:", H);
    }
  }
  function be() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (H) {
      console.error("THREE.WebGLState:", H);
    }
  }
  function ue() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (H) {
      console.error("THREE.WebGLState:", H);
    }
  }
  function Qe() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (H) {
      console.error("THREE.WebGLState:", H);
    }
  }
  function $e() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (H) {
      console.error("THREE.WebGLState:", H);
    }
  }
  function et(H) {
    de.equals(H) === !1 && (n.scissor(H.x, H.y, H.z, H.w), de.copy(H));
  }
  function Ve(H) {
    ye.equals(H) === !1 && (n.viewport(H.x, H.y, H.z, H.w), ye.copy(H));
  }
  function B(H, Me) {
    let ie = d.get(Me);
    ie === void 0 && (ie = /* @__PURE__ */ new WeakMap(), d.set(Me, ie));
    let Ae = ie.get(H);
    Ae === void 0 && (Ae = n.getUniformBlockIndex(Me, H.name), ie.set(H, Ae));
  }
  function pe(H, Me) {
    const Ae = d.get(Me).get(H);
    h.get(Me) !== Ae && (n.uniformBlockBinding(Me, Ae, H.__bindingPointIndex), h.set(Me, Ae));
  }
  function Ne() {
    n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(n.LESS), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), i === !0 && (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null)), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), m = {}, X = null, W = {}, v = {}, _ = /* @__PURE__ */ new WeakMap(), w = [], M = null, g = !1, x = null, S = null, T = null, C = null, P = null, L = null, N = null, R = !1, b = null, G = null, $ = null, Y = null, K = null, de.set(0, 0, n.canvas.width, n.canvas.height), ye.set(0, 0, n.canvas.width, n.canvas.height), l.reset(), c.reset(), f.reset();
  }
  return {
    buffers: {
      color: l,
      depth: c,
      stencil: f
    },
    enable: Be,
    disable: je,
    bindFramebuffer: vt,
    drawBuffers: lt,
    useProgram: Re,
    setBlending: fe,
    setMaterial: Se,
    setFlipSided: ve,
    setCullFace: He,
    setLineWidth: Oe,
    setPolygonOffset: Fe,
    setScissorTest: Je,
    activeTexture: mt,
    bindTexture: Ut,
    unbindTexture: F,
    compressedTexImage2D: I,
    compressedTexImage3D: ae,
    texImage2D: Qe,
    texImage3D: $e,
    updateUBOMapping: B,
    uniformBlockBinding: pe,
    texStorage2D: be,
    texStorage3D: ue,
    texSubImage2D: we,
    texSubImage3D: _e,
    compressedTexSubImage2D: Pe,
    compressedTexSubImage3D: qe,
    scissor: et,
    viewport: Ve,
    reset: Ne
  };
}
function LU(n, e, t, i, r, s, o) {
  const l = r.isWebGL2, c = r.maxTextures, f = r.maxCubemapSize, h = r.maxTextureSize, d = r.maxSamples, m = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, v = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), _ = /* @__PURE__ */ new WeakMap();
  let w;
  const M = /* @__PURE__ */ new WeakMap();
  let g = !1;
  try {
    g = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function x(F, I) {
    return g ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(F, I)
    ) : Lc("canvas");
  }
  function S(F, I, ae, we) {
    let _e = 1;
    if ((F.width > we || F.height > we) && (_e = we / Math.max(F.width, F.height)), _e < 1 || I === !0)
      if (typeof HTMLImageElement < "u" && F instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && F instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && F instanceof ImageBitmap) {
        const Pe = I ? np : Math.floor, qe = Pe(_e * F.width), be = Pe(_e * F.height);
        w === void 0 && (w = x(qe, be));
        const ue = ae ? x(qe, be) : w;
        return ue.width = qe, ue.height = be, ue.getContext("2d").drawImage(F, 0, 0, qe, be), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + F.width + "x" + F.height + ") to (" + qe + "x" + be + ")."), ue;
      } else
        return "data" in F && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + F.width + "x" + F.height + ")."), F;
    return F;
  }
  function T(F) {
    return Gv(F.width) && Gv(F.height);
  }
  function C(F) {
    return l ? !1 : F.wrapS !== Jn || F.wrapT !== Jn || F.minFilter !== hn && F.minFilter !== pn;
  }
  function P(F, I) {
    return F.generateMipmaps && I && F.minFilter !== hn && F.minFilter !== pn;
  }
  function L(F) {
    n.generateMipmap(F);
  }
  function N(F, I, ae, we, _e = !1) {
    if (l === !1)
      return I;
    if (F !== null) {
      if (n[F] !== void 0)
        return n[F];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + F + "'");
    }
    let Pe = I;
    return I === n.RED && (ae === n.FLOAT && (Pe = n.R32F), ae === n.HALF_FLOAT && (Pe = n.R16F), ae === n.UNSIGNED_BYTE && (Pe = n.R8)), I === n.RG && (ae === n.FLOAT && (Pe = n.RG32F), ae === n.HALF_FLOAT && (Pe = n.RG16F), ae === n.UNSIGNED_BYTE && (Pe = n.RG8)), I === n.RGBA && (ae === n.FLOAT && (Pe = n.RGBA32F), ae === n.HALF_FLOAT && (Pe = n.RGBA16F), ae === n.UNSIGNED_BYTE && (Pe = we === pt && _e === !1 ? n.SRGB8_ALPHA8 : n.RGBA8), ae === n.UNSIGNED_SHORT_4_4_4_4 && (Pe = n.RGBA4), ae === n.UNSIGNED_SHORT_5_5_5_1 && (Pe = n.RGB5_A1)), (Pe === n.R16F || Pe === n.R32F || Pe === n.RG16F || Pe === n.RG32F || Pe === n.RGBA16F || Pe === n.RGBA32F) && e.get("EXT_color_buffer_float"), Pe;
  }
  function R(F, I, ae) {
    return P(F, ae) === !0 || F.isFramebufferTexture && F.minFilter !== hn && F.minFilter !== pn ? Math.log2(Math.max(I.width, I.height)) + 1 : F.mipmaps !== void 0 && F.mipmaps.length > 0 ? F.mipmaps.length : F.isCompressedTexture && Array.isArray(F.image) ? I.mipmaps.length : 1;
  }
  function b(F) {
    return F === hn || F === ep || F === ec ? n.NEAREST : n.LINEAR;
  }
  function G(F) {
    const I = F.target;
    I.removeEventListener("dispose", G), Y(I), I.isVideoTexture && _.delete(I);
  }
  function $(F) {
    const I = F.target;
    I.removeEventListener("dispose", $), J(I);
  }
  function Y(F) {
    const I = i.get(F);
    if (I.__webglInit === void 0)
      return;
    const ae = F.source, we = M.get(ae);
    if (we) {
      const _e = we[I.__cacheKey];
      _e.usedTimes--, _e.usedTimes === 0 && K(F), Object.keys(we).length === 0 && M.delete(ae);
    }
    i.remove(F);
  }
  function K(F) {
    const I = i.get(F);
    n.deleteTexture(I.__webglTexture);
    const ae = F.source, we = M.get(ae);
    delete we[I.__cacheKey], o.memory.textures--;
  }
  function J(F) {
    const I = F.texture, ae = i.get(F), we = i.get(I);
    if (we.__webglTexture !== void 0 && (n.deleteTexture(we.__webglTexture), o.memory.textures--), F.depthTexture && F.depthTexture.dispose(), F.isWebGLCubeRenderTarget)
      for (let _e = 0; _e < 6; _e++)
        n.deleteFramebuffer(ae.__webglFramebuffer[_e]), ae.__webglDepthbuffer && n.deleteRenderbuffer(ae.__webglDepthbuffer[_e]);
    else {
      if (n.deleteFramebuffer(ae.__webglFramebuffer), ae.__webglDepthbuffer && n.deleteRenderbuffer(ae.__webglDepthbuffer), ae.__webglMultisampledFramebuffer && n.deleteFramebuffer(ae.__webglMultisampledFramebuffer), ae.__webglColorRenderbuffer)
        for (let _e = 0; _e < ae.__webglColorRenderbuffer.length; _e++)
          ae.__webglColorRenderbuffer[_e] && n.deleteRenderbuffer(ae.__webglColorRenderbuffer[_e]);
      ae.__webglDepthRenderbuffer && n.deleteRenderbuffer(ae.__webglDepthRenderbuffer);
    }
    if (F.isWebGLMultipleRenderTargets)
      for (let _e = 0, Pe = I.length; _e < Pe; _e++) {
        const qe = i.get(I[_e]);
        qe.__webglTexture && (n.deleteTexture(qe.__webglTexture), o.memory.textures--), i.remove(I[_e]);
      }
    i.remove(I), i.remove(F);
  }
  let oe = 0;
  function ne() {
    oe = 0;
  }
  function O() {
    const F = oe;
    return F >= c && console.warn("THREE.WebGLTextures: Trying to use " + F + " texture units while this GPU supports only " + c), oe += 1, F;
  }
  function X(F) {
    const I = [];
    return I.push(F.wrapS), I.push(F.wrapT), I.push(F.wrapR || 0), I.push(F.magFilter), I.push(F.minFilter), I.push(F.anisotropy), I.push(F.internalFormat), I.push(F.format), I.push(F.type), I.push(F.generateMipmaps), I.push(F.premultiplyAlpha), I.push(F.flipY), I.push(F.unpackAlignment), I.push(F.colorSpace), I.join();
  }
  function W(F, I) {
    const ae = i.get(F);
    if (F.isVideoTexture && mt(F), F.isRenderTargetTexture === !1 && F.version > 0 && ae.__version !== F.version) {
      const we = F.image;
      if (we === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (we.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        vt(ae, F, I);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, ae.__webglTexture, n.TEXTURE0 + I);
  }
  function V(F, I) {
    const ae = i.get(F);
    if (F.version > 0 && ae.__version !== F.version) {
      vt(ae, F, I);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, ae.__webglTexture, n.TEXTURE0 + I);
  }
  function j(F, I) {
    const ae = i.get(F);
    if (F.version > 0 && ae.__version !== F.version) {
      vt(ae, F, I);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, ae.__webglTexture, n.TEXTURE0 + I);
  }
  function de(F, I) {
    const ae = i.get(F);
    if (F.version > 0 && ae.__version !== F.version) {
      lt(ae, F, I);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, ae.__webglTexture, n.TEXTURE0 + I);
  }
  const ye = {
    [Ec]: n.REPEAT,
    [Jn]: n.CLAMP_TO_EDGE,
    [Tc]: n.MIRRORED_REPEAT
  }, Te = {
    [hn]: n.NEAREST,
    [ep]: n.NEAREST_MIPMAP_NEAREST,
    [ec]: n.NEAREST_MIPMAP_LINEAR,
    [pn]: n.LINEAR,
    [t_]: n.LINEAR_MIPMAP_NEAREST,
    [co]: n.LINEAR_MIPMAP_LINEAR
  }, Ie = {
    [bA]: n.NEVER,
    [kA]: n.ALWAYS,
    [LA]: n.LESS,
    [NA]: n.LEQUAL,
    [IA]: n.EQUAL,
    [OA]: n.GEQUAL,
    [DA]: n.GREATER,
    [UA]: n.NOTEQUAL
  };
  function Be(F, I, ae) {
    if (ae ? (n.texParameteri(F, n.TEXTURE_WRAP_S, ye[I.wrapS]), n.texParameteri(F, n.TEXTURE_WRAP_T, ye[I.wrapT]), (F === n.TEXTURE_3D || F === n.TEXTURE_2D_ARRAY) && n.texParameteri(F, n.TEXTURE_WRAP_R, ye[I.wrapR]), n.texParameteri(F, n.TEXTURE_MAG_FILTER, Te[I.magFilter]), n.texParameteri(F, n.TEXTURE_MIN_FILTER, Te[I.minFilter])) : (n.texParameteri(F, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(F, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), (F === n.TEXTURE_3D || F === n.TEXTURE_2D_ARRAY) && n.texParameteri(F, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE), (I.wrapS !== Jn || I.wrapT !== Jn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n.texParameteri(F, n.TEXTURE_MAG_FILTER, b(I.magFilter)), n.texParameteri(F, n.TEXTURE_MIN_FILTER, b(I.minFilter)), I.minFilter !== hn && I.minFilter !== pn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), I.compareFunction && (n.texParameteri(F, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(F, n.TEXTURE_COMPARE_FUNC, Ie[I.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      const we = e.get("EXT_texture_filter_anisotropic");
      if (I.magFilter === hn || I.minFilter !== ec && I.minFilter !== co || I.type === kr && e.has("OES_texture_float_linear") === !1 || l === !1 && I.type === Bl && e.has("OES_texture_half_float_linear") === !1)
        return;
      (I.anisotropy > 1 || i.get(I).__currentAnisotropy) && (n.texParameterf(F, we.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(I.anisotropy, r.getMaxAnisotropy())), i.get(I).__currentAnisotropy = I.anisotropy);
    }
  }
  function je(F, I) {
    let ae = !1;
    F.__webglInit === void 0 && (F.__webglInit = !0, I.addEventListener("dispose", G));
    const we = I.source;
    let _e = M.get(we);
    _e === void 0 && (_e = {}, M.set(we, _e));
    const Pe = X(I);
    if (Pe !== F.__cacheKey) {
      _e[Pe] === void 0 && (_e[Pe] = {
        texture: n.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, ae = !0), _e[Pe].usedTimes++;
      const qe = _e[F.__cacheKey];
      qe !== void 0 && (_e[F.__cacheKey].usedTimes--, qe.usedTimes === 0 && K(I)), F.__cacheKey = Pe, F.__webglTexture = _e[Pe].texture;
    }
    return ae;
  }
  function vt(F, I, ae) {
    let we = n.TEXTURE_2D;
    (I.isDataArrayTexture || I.isCompressedArrayTexture) && (we = n.TEXTURE_2D_ARRAY), I.isData3DTexture && (we = n.TEXTURE_3D);
    const _e = je(F, I), Pe = I.source;
    t.bindTexture(we, F.__webglTexture, n.TEXTURE0 + ae);
    const qe = i.get(Pe);
    if (Pe.version !== qe.__version || _e === !0) {
      t.activeTexture(n.TEXTURE0 + ae), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, I.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, I.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
      const be = C(I) && T(I.image) === !1;
      let ue = S(I.image, be, !1, h);
      ue = Ut(I, ue);
      const Qe = T(ue) || l, $e = s.convert(I.format, I.colorSpace);
      let et = s.convert(I.type), Ve = N(I.internalFormat, $e, et, I.colorSpace);
      Be(we, I, Qe);
      let B;
      const pe = I.mipmaps, Ne = l && I.isVideoTexture !== !0, H = qe.__version === void 0 || _e === !0, Me = R(I, ue, Qe);
      if (I.isDepthTexture)
        Ve = n.DEPTH_COMPONENT, l ? I.type === kr ? Ve = n.DEPTH_COMPONENT32F : I.type === ms ? Ve = n.DEPTH_COMPONENT24 : I.type === no ? Ve = n.DEPTH24_STENCIL8 : Ve = n.DEPTH_COMPONENT16 : I.type === kr && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), I.format === io && Ve === n.DEPTH_COMPONENT && I.type !== Ep && I.type !== ms && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), I.type = ms, et = s.convert(I.type)), I.format === ua && Ve === n.DEPTH_COMPONENT && (Ve = n.DEPTH_STENCIL, I.type !== no && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), I.type = no, et = s.convert(I.type))), H && (Ne ? t.texStorage2D(n.TEXTURE_2D, 1, Ve, ue.width, ue.height) : t.texImage2D(n.TEXTURE_2D, 0, Ve, ue.width, ue.height, 0, $e, et, null));
      else if (I.isDataTexture)
        if (pe.length > 0 && Qe) {
          Ne && H && t.texStorage2D(n.TEXTURE_2D, Me, Ve, pe[0].width, pe[0].height);
          for (let ie = 0, Ae = pe.length; ie < Ae; ie++)
            B = pe[ie], Ne ? t.texSubImage2D(n.TEXTURE_2D, ie, 0, 0, B.width, B.height, $e, et, B.data) : t.texImage2D(n.TEXTURE_2D, ie, Ve, B.width, B.height, 0, $e, et, B.data);
          I.generateMipmaps = !1;
        } else
          Ne ? (H && t.texStorage2D(n.TEXTURE_2D, Me, Ve, ue.width, ue.height), t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, ue.width, ue.height, $e, et, ue.data)) : t.texImage2D(n.TEXTURE_2D, 0, Ve, ue.width, ue.height, 0, $e, et, ue.data);
      else if (I.isCompressedTexture)
        if (I.isCompressedArrayTexture) {
          Ne && H && t.texStorage3D(n.TEXTURE_2D_ARRAY, Me, Ve, pe[0].width, pe[0].height, ue.depth);
          for (let ie = 0, Ae = pe.length; ie < Ae; ie++)
            B = pe[ie], I.format !== vi ? $e !== null ? Ne ? t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, ie, 0, 0, 0, B.width, B.height, ue.depth, $e, B.data, 0, 0) : t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, ie, Ve, B.width, B.height, ue.depth, 0, B.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ne ? t.texSubImage3D(n.TEXTURE_2D_ARRAY, ie, 0, 0, 0, B.width, B.height, ue.depth, $e, et, B.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, ie, Ve, B.width, B.height, ue.depth, 0, $e, et, B.data);
        } else {
          Ne && H && t.texStorage2D(n.TEXTURE_2D, Me, Ve, pe[0].width, pe[0].height);
          for (let ie = 0, Ae = pe.length; ie < Ae; ie++)
            B = pe[ie], I.format !== vi ? $e !== null ? Ne ? t.compressedTexSubImage2D(n.TEXTURE_2D, ie, 0, 0, B.width, B.height, $e, B.data) : t.compressedTexImage2D(n.TEXTURE_2D, ie, Ve, B.width, B.height, 0, B.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ne ? t.texSubImage2D(n.TEXTURE_2D, ie, 0, 0, B.width, B.height, $e, et, B.data) : t.texImage2D(n.TEXTURE_2D, ie, Ve, B.width, B.height, 0, $e, et, B.data);
        }
      else if (I.isDataArrayTexture)
        Ne ? (H && t.texStorage3D(n.TEXTURE_2D_ARRAY, Me, Ve, ue.width, ue.height, ue.depth), t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ue.width, ue.height, ue.depth, $e, et, ue.data)) : t.texImage3D(n.TEXTURE_2D_ARRAY, 0, Ve, ue.width, ue.height, ue.depth, 0, $e, et, ue.data);
      else if (I.isData3DTexture)
        Ne ? (H && t.texStorage3D(n.TEXTURE_3D, Me, Ve, ue.width, ue.height, ue.depth), t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, ue.width, ue.height, ue.depth, $e, et, ue.data)) : t.texImage3D(n.TEXTURE_3D, 0, Ve, ue.width, ue.height, ue.depth, 0, $e, et, ue.data);
      else if (I.isFramebufferTexture) {
        if (H)
          if (Ne)
            t.texStorage2D(n.TEXTURE_2D, Me, Ve, ue.width, ue.height);
          else {
            let ie = ue.width, Ae = ue.height;
            for (let De = 0; De < Me; De++)
              t.texImage2D(n.TEXTURE_2D, De, Ve, ie, Ae, 0, $e, et, null), ie >>= 1, Ae >>= 1;
          }
      } else if (pe.length > 0 && Qe) {
        Ne && H && t.texStorage2D(n.TEXTURE_2D, Me, Ve, pe[0].width, pe[0].height);
        for (let ie = 0, Ae = pe.length; ie < Ae; ie++)
          B = pe[ie], Ne ? t.texSubImage2D(n.TEXTURE_2D, ie, 0, 0, $e, et, B) : t.texImage2D(n.TEXTURE_2D, ie, Ve, $e, et, B);
        I.generateMipmaps = !1;
      } else
        Ne ? (H && t.texStorage2D(n.TEXTURE_2D, Me, Ve, ue.width, ue.height), t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, $e, et, ue)) : t.texImage2D(n.TEXTURE_2D, 0, Ve, $e, et, ue);
      P(I, Qe) && L(we), qe.__version = Pe.version, I.onUpdate && I.onUpdate(I);
    }
    F.__version = I.version;
  }
  function lt(F, I, ae) {
    if (I.image.length !== 6)
      return;
    const we = je(F, I), _e = I.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, F.__webglTexture, n.TEXTURE0 + ae);
    const Pe = i.get(_e);
    if (_e.version !== Pe.__version || we === !0) {
      t.activeTexture(n.TEXTURE0 + ae), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, I.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, I.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE);
      const qe = I.isCompressedTexture || I.image[0].isCompressedTexture, be = I.image[0] && I.image[0].isDataTexture, ue = [];
      for (let ie = 0; ie < 6; ie++)
        !qe && !be ? ue[ie] = S(I.image[ie], !1, !0, f) : ue[ie] = be ? I.image[ie].image : I.image[ie], ue[ie] = Ut(I, ue[ie]);
      const Qe = ue[0], $e = T(Qe) || l, et = s.convert(I.format, I.colorSpace), Ve = s.convert(I.type), B = N(I.internalFormat, et, Ve, I.colorSpace), pe = l && I.isVideoTexture !== !0, Ne = Pe.__version === void 0 || we === !0;
      let H = R(I, Qe, $e);
      Be(n.TEXTURE_CUBE_MAP, I, $e);
      let Me;
      if (qe) {
        pe && Ne && t.texStorage2D(n.TEXTURE_CUBE_MAP, H, B, Qe.width, Qe.height);
        for (let ie = 0; ie < 6; ie++) {
          Me = ue[ie].mipmaps;
          for (let Ae = 0; Ae < Me.length; Ae++) {
            const De = Me[Ae];
            I.format !== vi ? et !== null ? pe ? t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ie, Ae, 0, 0, De.width, De.height, et, De.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ie, Ae, B, De.width, De.height, 0, De.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : pe ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ie, Ae, 0, 0, De.width, De.height, et, Ve, De.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ie, Ae, B, De.width, De.height, 0, et, Ve, De.data);
          }
        }
      } else {
        Me = I.mipmaps, pe && Ne && (Me.length > 0 && H++, t.texStorage2D(n.TEXTURE_CUBE_MAP, H, B, ue[0].width, ue[0].height));
        for (let ie = 0; ie < 6; ie++)
          if (be) {
            pe ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ie, 0, 0, 0, ue[ie].width, ue[ie].height, et, Ve, ue[ie].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ie, 0, B, ue[ie].width, ue[ie].height, 0, et, Ve, ue[ie].data);
            for (let Ae = 0; Ae < Me.length; Ae++) {
              const Et = Me[Ae].image[ie].image;
              pe ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ie, Ae + 1, 0, 0, Et.width, Et.height, et, Ve, Et.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ie, Ae + 1, B, Et.width, Et.height, 0, et, Ve, Et.data);
            }
          } else {
            pe ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ie, 0, 0, 0, et, Ve, ue[ie]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ie, 0, B, et, Ve, ue[ie]);
            for (let Ae = 0; Ae < Me.length; Ae++) {
              const De = Me[Ae];
              pe ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ie, Ae + 1, 0, 0, et, Ve, De.image[ie]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ie, Ae + 1, B, et, Ve, De.image[ie]);
            }
          }
      }
      P(I, $e) && L(n.TEXTURE_CUBE_MAP), Pe.__version = _e.version, I.onUpdate && I.onUpdate(I);
    }
    F.__version = I.version;
  }
  function Re(F, I, ae, we, _e) {
    const Pe = s.convert(ae.format, ae.colorSpace), qe = s.convert(ae.type), be = N(ae.internalFormat, Pe, qe, ae.colorSpace);
    i.get(I).__hasExternalTextures || (_e === n.TEXTURE_3D || _e === n.TEXTURE_2D_ARRAY ? t.texImage3D(_e, 0, be, I.width, I.height, I.depth, 0, Pe, qe, null) : t.texImage2D(_e, 0, be, I.width, I.height, 0, Pe, qe, null)), t.bindFramebuffer(n.FRAMEBUFFER, F), Je(I) ? m.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, we, _e, i.get(ae).__webglTexture, 0, Fe(I)) : (_e === n.TEXTURE_2D || _e >= n.TEXTURE_CUBE_MAP_POSITIVE_X && _e <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, we, _e, i.get(ae).__webglTexture, 0), t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function z(F, I, ae) {
    if (n.bindRenderbuffer(n.RENDERBUFFER, F), I.depthBuffer && !I.stencilBuffer) {
      let we = n.DEPTH_COMPONENT16;
      if (ae || Je(I)) {
        const _e = I.depthTexture;
        _e && _e.isDepthTexture && (_e.type === kr ? we = n.DEPTH_COMPONENT32F : _e.type === ms && (we = n.DEPTH_COMPONENT24));
        const Pe = Fe(I);
        Je(I) ? m.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Pe, we, I.width, I.height) : n.renderbufferStorageMultisample(n.RENDERBUFFER, Pe, we, I.width, I.height);
      } else
        n.renderbufferStorage(n.RENDERBUFFER, we, I.width, I.height);
      n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, F);
    } else if (I.depthBuffer && I.stencilBuffer) {
      const we = Fe(I);
      ae && Je(I) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, we, n.DEPTH24_STENCIL8, I.width, I.height) : Je(I) ? m.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, we, n.DEPTH24_STENCIL8, I.width, I.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, I.width, I.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, F);
    } else {
      const we = I.isWebGLMultipleRenderTargets === !0 ? I.texture : [I.texture];
      for (let _e = 0; _e < we.length; _e++) {
        const Pe = we[_e], qe = s.convert(Pe.format, Pe.colorSpace), be = s.convert(Pe.type), ue = N(Pe.internalFormat, qe, be, Pe.colorSpace), Qe = Fe(I);
        ae && Je(I) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Qe, ue, I.width, I.height) : Je(I) ? m.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Qe, ue, I.width, I.height) : n.renderbufferStorage(n.RENDERBUFFER, ue, I.width, I.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function ge(F, I) {
    if (I && I.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(n.FRAMEBUFFER, F), !(I.depthTexture && I.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!i.get(I.depthTexture).__webglTexture || I.depthTexture.image.width !== I.width || I.depthTexture.image.height !== I.height) && (I.depthTexture.image.width = I.width, I.depthTexture.image.height = I.height, I.depthTexture.needsUpdate = !0), W(I.depthTexture, 0);
    const we = i.get(I.depthTexture).__webglTexture, _e = Fe(I);
    if (I.depthTexture.format === io)
      Je(I) ? m.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, we, 0, _e) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, we, 0);
    else if (I.depthTexture.format === ua)
      Je(I) ? m.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, we, 0, _e) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, we, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function fe(F) {
    const I = i.get(F), ae = F.isWebGLCubeRenderTarget === !0;
    if (F.depthTexture && !I.__autoAllocateDepthBuffer) {
      if (ae)
        throw new Error("target.depthTexture not supported in Cube render targets");
      ge(I.__webglFramebuffer, F);
    } else if (ae) {
      I.__webglDepthbuffer = [];
      for (let we = 0; we < 6; we++)
        t.bindFramebuffer(n.FRAMEBUFFER, I.__webglFramebuffer[we]), I.__webglDepthbuffer[we] = n.createRenderbuffer(), z(I.__webglDepthbuffer[we], F, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, I.__webglFramebuffer), I.__webglDepthbuffer = n.createRenderbuffer(), z(I.__webglDepthbuffer, F, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Se(F, I, ae) {
    const we = i.get(F);
    I !== void 0 && Re(we.__webglFramebuffer, F, F.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D), ae !== void 0 && fe(F);
  }
  function ve(F) {
    const I = F.texture, ae = i.get(F), we = i.get(I);
    F.addEventListener("dispose", $), F.isWebGLMultipleRenderTargets !== !0 && (we.__webglTexture === void 0 && (we.__webglTexture = n.createTexture()), we.__version = I.version, o.memory.textures++);
    const _e = F.isWebGLCubeRenderTarget === !0, Pe = F.isWebGLMultipleRenderTargets === !0, qe = T(F) || l;
    if (_e) {
      ae.__webglFramebuffer = [];
      for (let be = 0; be < 6; be++)
        ae.__webglFramebuffer[be] = n.createFramebuffer();
    } else {
      if (ae.__webglFramebuffer = n.createFramebuffer(), Pe)
        if (r.drawBuffers) {
          const be = F.texture;
          for (let ue = 0, Qe = be.length; ue < Qe; ue++) {
            const $e = i.get(be[ue]);
            $e.__webglTexture === void 0 && ($e.__webglTexture = n.createTexture(), o.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (l && F.samples > 0 && Je(F) === !1) {
        const be = Pe ? I : [I];
        ae.__webglMultisampledFramebuffer = n.createFramebuffer(), ae.__webglColorRenderbuffer = [], t.bindFramebuffer(n.FRAMEBUFFER, ae.__webglMultisampledFramebuffer);
        for (let ue = 0; ue < be.length; ue++) {
          const Qe = be[ue];
          ae.__webglColorRenderbuffer[ue] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, ae.__webglColorRenderbuffer[ue]);
          const $e = s.convert(Qe.format, Qe.colorSpace), et = s.convert(Qe.type), Ve = N(Qe.internalFormat, $e, et, Qe.colorSpace, F.isXRRenderTarget === !0), B = Fe(F);
          n.renderbufferStorageMultisample(n.RENDERBUFFER, B, Ve, F.width, F.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ue, n.RENDERBUFFER, ae.__webglColorRenderbuffer[ue]);
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null), F.depthBuffer && (ae.__webglDepthRenderbuffer = n.createRenderbuffer(), z(ae.__webglDepthRenderbuffer, F, !0)), t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (_e) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, we.__webglTexture), Be(n.TEXTURE_CUBE_MAP, I, qe);
      for (let be = 0; be < 6; be++)
        Re(ae.__webglFramebuffer[be], F, I, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + be);
      P(I, qe) && L(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Pe) {
      const be = F.texture;
      for (let ue = 0, Qe = be.length; ue < Qe; ue++) {
        const $e = be[ue], et = i.get($e);
        t.bindTexture(n.TEXTURE_2D, et.__webglTexture), Be(n.TEXTURE_2D, $e, qe), Re(ae.__webglFramebuffer, F, $e, n.COLOR_ATTACHMENT0 + ue, n.TEXTURE_2D), P($e, qe) && L(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let be = n.TEXTURE_2D;
      (F.isWebGL3DRenderTarget || F.isWebGLArrayRenderTarget) && (l ? be = F.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(be, we.__webglTexture), Be(be, I, qe), Re(ae.__webglFramebuffer, F, I, n.COLOR_ATTACHMENT0, be), P(I, qe) && L(be), t.unbindTexture();
    }
    F.depthBuffer && fe(F);
  }
  function He(F) {
    const I = T(F) || l, ae = F.isWebGLMultipleRenderTargets === !0 ? F.texture : [F.texture];
    for (let we = 0, _e = ae.length; we < _e; we++) {
      const Pe = ae[we];
      if (P(Pe, I)) {
        const qe = F.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D, be = i.get(Pe).__webglTexture;
        t.bindTexture(qe, be), L(qe), t.unbindTexture();
      }
    }
  }
  function Oe(F) {
    if (l && F.samples > 0 && Je(F) === !1) {
      const I = F.isWebGLMultipleRenderTargets ? F.texture : [F.texture], ae = F.width, we = F.height;
      let _e = n.COLOR_BUFFER_BIT;
      const Pe = [], qe = F.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, be = i.get(F), ue = F.isWebGLMultipleRenderTargets === !0;
      if (ue)
        for (let Qe = 0; Qe < I.length; Qe++)
          t.bindFramebuffer(n.FRAMEBUFFER, be.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Qe, n.RENDERBUFFER, null), t.bindFramebuffer(n.FRAMEBUFFER, be.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Qe, n.TEXTURE_2D, null, 0);
      t.bindFramebuffer(n.READ_FRAMEBUFFER, be.__webglMultisampledFramebuffer), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, be.__webglFramebuffer);
      for (let Qe = 0; Qe < I.length; Qe++) {
        Pe.push(n.COLOR_ATTACHMENT0 + Qe), F.depthBuffer && Pe.push(qe);
        const $e = be.__ignoreDepthValues !== void 0 ? be.__ignoreDepthValues : !1;
        if ($e === !1 && (F.depthBuffer && (_e |= n.DEPTH_BUFFER_BIT), F.stencilBuffer && (_e |= n.STENCIL_BUFFER_BIT)), ue && n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, be.__webglColorRenderbuffer[Qe]), $e === !0 && (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [qe]), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [qe])), ue) {
          const et = i.get(I[Qe]).__webglTexture;
          n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, et, 0);
        }
        n.blitFramebuffer(0, 0, ae, we, 0, 0, ae, we, _e, n.NEAREST), v && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, Pe);
      }
      if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), ue)
        for (let Qe = 0; Qe < I.length; Qe++) {
          t.bindFramebuffer(n.FRAMEBUFFER, be.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Qe, n.RENDERBUFFER, be.__webglColorRenderbuffer[Qe]);
          const $e = i.get(I[Qe]).__webglTexture;
          t.bindFramebuffer(n.FRAMEBUFFER, be.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Qe, n.TEXTURE_2D, $e, 0);
        }
      t.bindFramebuffer(n.DRAW_FRAMEBUFFER, be.__webglMultisampledFramebuffer);
    }
  }
  function Fe(F) {
    return Math.min(d, F.samples);
  }
  function Je(F) {
    const I = i.get(F);
    return l && F.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && I.__useRenderToTexture !== !1;
  }
  function mt(F) {
    const I = o.render.frame;
    _.get(F) !== I && (_.set(F, I), F.update());
  }
  function Ut(F, I) {
    const ae = F.colorSpace, we = F.format, _e = F.type;
    return F.isCompressedTexture === !0 || F.format === tp || ae !== Sr && ae !== so && (ae === pt ? l === !1 ? e.has("EXT_sRGB") === !0 && we === vi ? (F.format = tp, F.minFilter = pn, F.generateMipmaps = !1) : I = h_.sRGBToLinear(I) : (we !== vi || _e !== Hr) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", ae)), I;
  }
  this.allocateTextureUnit = O, this.resetTextureUnits = ne, this.setTexture2D = W, this.setTexture2DArray = V, this.setTexture3D = j, this.setTextureCube = de, this.rebindTextures = Se, this.setupRenderTarget = ve, this.updateRenderTargetMipmap = He, this.updateMultisampleRenderTarget = Oe, this.setupDepthRenderbuffer = fe, this.setupFrameBufferTexture = Re, this.useMultisampledRTT = Je;
}
function JA(n, e, t) {
  const i = t.isWebGL2;
  function r(s, o = so) {
    let l;
    if (s === Hr)
      return n.UNSIGNED_BYTE;
    if (s === i_)
      return n.UNSIGNED_SHORT_4_4_4_4;
    if (s === r_)
      return n.UNSIGNED_SHORT_5_5_5_1;
    if (s === pA)
      return n.BYTE;
    if (s === mA)
      return n.SHORT;
    if (s === Ep)
      return n.UNSIGNED_SHORT;
    if (s === n_)
      return n.INT;
    if (s === ms)
      return n.UNSIGNED_INT;
    if (s === kr)
      return n.FLOAT;
    if (s === Bl)
      return i ? n.HALF_FLOAT : (l = e.get("OES_texture_half_float"), l !== null ? l.HALF_FLOAT_OES : null);
    if (s === gA)
      return n.ALPHA;
    if (s === vi)
      return n.RGBA;
    if (s === vA)
      return n.LUMINANCE;
    if (s === yA)
      return n.LUMINANCE_ALPHA;
    if (s === io)
      return n.DEPTH_COMPONENT;
    if (s === ua)
      return n.DEPTH_STENCIL;
    if (s === tp)
      return l = e.get("EXT_sRGB"), l !== null ? l.SRGB_ALPHA_EXT : null;
    if (s === _A)
      return n.RED;
    if (s === s_)
      return n.RED_INTEGER;
    if (s === xA)
      return n.RG;
    if (s === o_)
      return n.RG_INTEGER;
    if (s === a_)
      return n.RGBA_INTEGER;
    if (s === xd || s === Sd || s === Md || s === wd)
      if (o === pt)
        if (l = e.get("WEBGL_compressed_texture_s3tc_srgb"), l !== null) {
          if (s === xd)
            return l.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === Sd)
            return l.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === Md)
            return l.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === wd)
            return l.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (l = e.get("WEBGL_compressed_texture_s3tc"), l !== null) {
        if (s === xd)
          return l.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === Sd)
          return l.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === Md)
          return l.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === wd)
          return l.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (s === _v || s === xv || s === Sv || s === Mv)
      if (l = e.get("WEBGL_compressed_texture_pvrtc"), l !== null) {
        if (s === _v)
          return l.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === xv)
          return l.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === Sv)
          return l.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === Mv)
          return l.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (s === SA)
      return l = e.get("WEBGL_compressed_texture_etc1"), l !== null ? l.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (s === wv || s === Ev)
      if (l = e.get("WEBGL_compressed_texture_etc"), l !== null) {
        if (s === wv)
          return o === pt ? l.COMPRESSED_SRGB8_ETC2 : l.COMPRESSED_RGB8_ETC2;
        if (s === Ev)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : l.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (s === Tv || s === Av || s === Cv || s === Rv || s === Pv || s === bv || s === Lv || s === Iv || s === Nv || s === Dv || s === Uv || s === Ov || s === kv || s === Fv)
      if (l = e.get("WEBGL_compressed_texture_astc"), l !== null) {
        if (s === Tv)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : l.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === Av)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : l.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === Cv)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : l.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === Rv)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : l.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === Pv)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : l.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === bv)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : l.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === Lv)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : l.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === Iv)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : l.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === Nv)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : l.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === Dv)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : l.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === Uv)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : l.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === Ov)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : l.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === kv)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : l.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === Fv)
          return o === pt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : l.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (s === Ed)
      if (l = e.get("EXT_texture_compression_bptc"), l !== null) {
        if (s === Ed)
          return o === pt ? l.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : l.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    if (s === MA || s === zv || s === Bv || s === Hv)
      if (l = e.get("EXT_texture_compression_rgtc"), l !== null) {
        if (s === Ed)
          return l.COMPRESSED_RED_RGTC1_EXT;
        if (s === zv)
          return l.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === Bv)
          return l.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === Hv)
          return l.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return s === no ? i ? n.UNSIGNED_INT_24_8 : (l = e.get("WEBGL_depth_texture"), l !== null ? l.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null;
  }
  return { convert: r };
}
class QA extends Qt {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Ml extends It {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const IU = { type: "move" };
class Kg {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Ml(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Ml(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new D(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new D()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Ml(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new D(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new D()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const i of e.hand.values())
          this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, i) {
    let r = null, s = null, o = null;
    const l = this._targetRay, c = this._grip, f = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (f && e.hand) {
        o = !0;
        for (const w of e.hand.values()) {
          const M = t.getJointPose(w, i), g = this._getHandJoint(f, w);
          M !== null && (g.matrix.fromArray(M.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.matrixWorldNeedsUpdate = !0, g.jointRadius = M.radius), g.visible = M !== null;
        }
        const h = f.joints["index-finger-tip"], d = f.joints["thumb-tip"], m = h.position.distanceTo(d.position), v = 0.02, _ = 5e-3;
        f.inputState.pinching && m > v + _ ? (f.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !f.inputState.pinching && m <= v - _ && (f.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        c !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i), s !== null && (c.matrix.fromArray(s.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(s.linearVelocity)) : c.hasLinearVelocity = !1, s.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(s.angularVelocity)) : c.hasAngularVelocity = !1));
      l !== null && (r = t.getPose(e.targetRaySpace, i), r === null && s !== null && (r = s), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1, this.dispatchEvent(IU)));
    }
    return l !== null && (l.visible = r !== null), c !== null && (c.visible = s !== null), f !== null && (f.visible = o !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new Ml();
      i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i);
    }
    return e.joints[t.jointName];
  }
}
class $A extends mn {
  constructor(e, t, i, r, s, o, l, c, f, h) {
    if (h = h !== void 0 ? h : io, h !== io && h !== ua)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && h === io && (i = ms), i === void 0 && h === ua && (i = no), super(null, r, s, o, l, c, h, i, f), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = l !== void 0 ? l : hn, this.minFilter = c !== void 0 ? c : hn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
class NU extends Ts {
  constructor(e, t) {
    super();
    const i = this;
    let r = null, s = 1, o = null, l = "local-floor", c = 1, f = null, h = null, d = null, m = null, v = null, _ = null;
    const w = t.getContextAttributes();
    let M = null, g = null;
    const x = [], S = [], T = new Qt();
    T.layers.enable(1), T.viewport = new kt();
    const C = new Qt();
    C.layers.enable(2), C.viewport = new kt();
    const P = [T, C], L = new QA();
    L.layers.enable(1), L.layers.enable(2);
    let N = null, R = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(V) {
      let j = x[V];
      return j === void 0 && (j = new Kg(), x[V] = j), j.getTargetRaySpace();
    }, this.getControllerGrip = function(V) {
      let j = x[V];
      return j === void 0 && (j = new Kg(), x[V] = j), j.getGripSpace();
    }, this.getHand = function(V) {
      let j = x[V];
      return j === void 0 && (j = new Kg(), x[V] = j), j.getHandSpace();
    };
    function b(V) {
      const j = S.indexOf(V.inputSource);
      if (j === -1)
        return;
      const de = x[j];
      de !== void 0 && (de.update(V.inputSource, V.frame, f || o), de.dispatchEvent({ type: V.type, data: V.inputSource }));
    }
    function G() {
      r.removeEventListener("select", b), r.removeEventListener("selectstart", b), r.removeEventListener("selectend", b), r.removeEventListener("squeeze", b), r.removeEventListener("squeezestart", b), r.removeEventListener("squeezeend", b), r.removeEventListener("end", G), r.removeEventListener("inputsourceschange", $);
      for (let V = 0; V < x.length; V++) {
        const j = S[V];
        j !== null && (S[V] = null, x[V].disconnect(j));
      }
      N = null, R = null, e.setRenderTarget(M), v = null, m = null, d = null, r = null, g = null, W.stop(), i.isPresenting = !1, i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(V) {
      s = V, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(V) {
      l = V, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return f || o;
    }, this.setReferenceSpace = function(V) {
      f = V;
    }, this.getBaseLayer = function() {
      return m !== null ? m : v;
    }, this.getBinding = function() {
      return d;
    }, this.getFrame = function() {
      return _;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(V) {
      if (r = V, r !== null) {
        if (M = e.getRenderTarget(), r.addEventListener("select", b), r.addEventListener("selectstart", b), r.addEventListener("selectend", b), r.addEventListener("squeeze", b), r.addEventListener("squeezestart", b), r.addEventListener("squeezeend", b), r.addEventListener("end", G), r.addEventListener("inputsourceschange", $), w.xrCompatible !== !0 && await t.makeXRCompatible(), r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const j = {
            antialias: r.renderState.layers === void 0 ? w.antialias : !0,
            alpha: !0,
            depth: w.depth,
            stencil: w.stencil,
            framebufferScaleFactor: s
          };
          v = new XRWebGLLayer(r, t, j), r.updateRenderState({ baseLayer: v }), g = new Mr(
            v.framebufferWidth,
            v.framebufferHeight,
            {
              format: vi,
              type: Hr,
              colorSpace: e.outputColorSpace,
              stencilBuffer: w.stencil
            }
          );
        } else {
          let j = null, de = null, ye = null;
          w.depth && (ye = w.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, j = w.stencil ? ua : io, de = w.stencil ? no : ms);
          const Te = {
            colorFormat: t.RGBA8,
            depthFormat: ye,
            scaleFactor: s
          };
          d = new XRWebGLBinding(r, t), m = d.createProjectionLayer(Te), r.updateRenderState({ layers: [m] }), g = new Mr(
            m.textureWidth,
            m.textureHeight,
            {
              format: vi,
              type: Hr,
              depthTexture: new $A(m.textureWidth, m.textureHeight, de, void 0, void 0, void 0, void 0, void 0, void 0, j),
              stencilBuffer: w.stencil,
              colorSpace: e.outputColorSpace,
              samples: w.antialias ? 4 : 0
            }
          );
          const Ie = e.properties.get(g);
          Ie.__ignoreDepthValues = m.ignoreDepthValues;
        }
        g.isXRRenderTarget = !0, this.setFoveation(c), f = null, o = await r.requestReferenceSpace(l), W.setContext(r), W.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (r !== null)
        return r.environmentBlendMode;
    };
    function $(V) {
      for (let j = 0; j < V.removed.length; j++) {
        const de = V.removed[j], ye = S.indexOf(de);
        ye >= 0 && (S[ye] = null, x[ye].disconnect(de));
      }
      for (let j = 0; j < V.added.length; j++) {
        const de = V.added[j];
        let ye = S.indexOf(de);
        if (ye === -1) {
          for (let Ie = 0; Ie < x.length; Ie++)
            if (Ie >= S.length) {
              S.push(de), ye = Ie;
              break;
            } else if (S[Ie] === null) {
              S[Ie] = de, ye = Ie;
              break;
            }
          if (ye === -1)
            break;
        }
        const Te = x[ye];
        Te && Te.connect(de);
      }
    }
    const Y = new D(), K = new D();
    function J(V, j, de) {
      Y.setFromMatrixPosition(j.matrixWorld), K.setFromMatrixPosition(de.matrixWorld);
      const ye = Y.distanceTo(K), Te = j.projectionMatrix.elements, Ie = de.projectionMatrix.elements, Be = Te[14] / (Te[10] - 1), je = Te[14] / (Te[10] + 1), vt = (Te[9] + 1) / Te[5], lt = (Te[9] - 1) / Te[5], Re = (Te[8] - 1) / Te[0], z = (Ie[8] + 1) / Ie[0], ge = Be * Re, fe = Be * z, Se = ye / (-Re + z), ve = Se * -Re;
      j.matrixWorld.decompose(V.position, V.quaternion, V.scale), V.translateX(ve), V.translateZ(Se), V.matrixWorld.compose(V.position, V.quaternion, V.scale), V.matrixWorldInverse.copy(V.matrixWorld).invert();
      const He = Be + Se, Oe = je + Se, Fe = ge - ve, Je = fe + (ye - ve), mt = vt * je / Oe * He, Ut = lt * je / Oe * He;
      V.projectionMatrix.makePerspective(Fe, Je, mt, Ut, He, Oe), V.projectionMatrixInverse.copy(V.projectionMatrix).invert();
    }
    function oe(V, j) {
      j === null ? V.matrixWorld.copy(V.matrix) : V.matrixWorld.multiplyMatrices(j.matrixWorld, V.matrix), V.matrixWorldInverse.copy(V.matrixWorld).invert();
    }
    this.updateCamera = function(V) {
      if (r === null)
        return;
      L.near = C.near = T.near = V.near, L.far = C.far = T.far = V.far, (N !== L.near || R !== L.far) && (r.updateRenderState({
        depthNear: L.near,
        depthFar: L.far
      }), N = L.near, R = L.far);
      const j = V.parent, de = L.cameras;
      oe(L, j);
      for (let ye = 0; ye < de.length; ye++)
        oe(de[ye], j);
      de.length === 2 ? J(L, T, C) : L.projectionMatrix.copy(T.projectionMatrix), ne(V, L, j);
    };
    function ne(V, j, de) {
      de === null ? V.matrix.copy(j.matrixWorld) : (V.matrix.copy(de.matrixWorld), V.matrix.invert(), V.matrix.multiply(j.matrixWorld)), V.matrix.decompose(V.position, V.quaternion, V.scale), V.updateMatrixWorld(!0);
      const ye = V.children;
      for (let Te = 0, Ie = ye.length; Te < Ie; Te++)
        ye[Te].updateMatrixWorld(!0);
      V.projectionMatrix.copy(j.projectionMatrix), V.projectionMatrixInverse.copy(j.projectionMatrixInverse), V.isPerspectiveCamera && (V.fov = Hl * 2 * Math.atan(1 / V.projectionMatrix.elements[5]), V.zoom = 1);
    }
    this.getCamera = function() {
      return L;
    }, this.getFoveation = function() {
      if (!(m === null && v === null))
        return c;
    }, this.setFoveation = function(V) {
      c = V, m !== null && (m.fixedFoveation = V), v !== null && v.fixedFoveation !== void 0 && (v.fixedFoveation = V);
    };
    let O = null;
    function X(V, j) {
      if (h = j.getViewerPose(f || o), _ = j, h !== null) {
        const de = h.views;
        v !== null && (e.setRenderTargetFramebuffer(g, v.framebuffer), e.setRenderTarget(g));
        let ye = !1;
        de.length !== L.cameras.length && (L.cameras.length = 0, ye = !0);
        for (let Te = 0; Te < de.length; Te++) {
          const Ie = de[Te];
          let Be = null;
          if (v !== null)
            Be = v.getViewport(Ie);
          else {
            const vt = d.getViewSubImage(m, Ie);
            Be = vt.viewport, Te === 0 && (e.setRenderTargetTextures(
              g,
              vt.colorTexture,
              m.ignoreDepthValues ? void 0 : vt.depthStencilTexture
            ), e.setRenderTarget(g));
          }
          let je = P[Te];
          je === void 0 && (je = new Qt(), je.layers.enable(Te), je.viewport = new kt(), P[Te] = je), je.matrix.fromArray(Ie.transform.matrix), je.matrix.decompose(je.position, je.quaternion, je.scale), je.projectionMatrix.fromArray(Ie.projectionMatrix), je.projectionMatrixInverse.copy(je.projectionMatrix).invert(), je.viewport.set(Be.x, Be.y, Be.width, Be.height), Te === 0 && (L.matrix.copy(je.matrix), L.matrix.decompose(L.position, L.quaternion, L.scale)), ye === !0 && L.cameras.push(je);
        }
      }
      for (let de = 0; de < x.length; de++) {
        const ye = S[de], Te = x[de];
        ye !== null && Te !== void 0 && Te.update(ye, j, f || o);
      }
      O && O(V, j), j.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: j }), _ = null;
    }
    const W = new jA();
    W.setAnimationLoop(X), this.setAnimationLoop = function(V) {
      O = V;
    }, this.dispose = function() {
    };
  }
}
function DU(n, e) {
  function t(M, g) {
    M.matrixAutoUpdate === !0 && M.updateMatrix(), g.value.copy(M.matrix);
  }
  function i(M, g) {
    g.color.getRGB(M.fogColor.value, VA(n)), g.isFog ? (M.fogNear.value = g.near, M.fogFar.value = g.far) : g.isFogExp2 && (M.fogDensity.value = g.density);
  }
  function r(M, g, x, S, T) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial ? s(M, g) : g.isMeshToonMaterial ? (s(M, g), d(M, g)) : g.isMeshPhongMaterial ? (s(M, g), h(M, g)) : g.isMeshStandardMaterial ? (s(M, g), m(M, g), g.isMeshPhysicalMaterial && v(M, g, T)) : g.isMeshMatcapMaterial ? (s(M, g), _(M, g)) : g.isMeshDepthMaterial ? s(M, g) : g.isMeshDistanceMaterial ? (s(M, g), w(M, g)) : g.isMeshNormalMaterial ? s(M, g) : g.isLineBasicMaterial ? (o(M, g), g.isLineDashedMaterial && l(M, g)) : g.isPointsMaterial ? c(M, g, x, S) : g.isSpriteMaterial ? f(M, g) : g.isShadowMaterial ? (M.color.value.copy(g.color), M.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function s(M, g) {
    M.opacity.value = g.opacity, g.color && M.diffuse.value.copy(g.color), g.emissive && M.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (M.map.value = g.map, t(g.map, M.mapTransform)), g.alphaMap && (M.alphaMap.value = g.alphaMap, t(g.alphaMap, M.alphaMapTransform)), g.bumpMap && (M.bumpMap.value = g.bumpMap, t(g.bumpMap, M.bumpMapTransform), M.bumpScale.value = g.bumpScale, g.side === ai && (M.bumpScale.value *= -1)), g.normalMap && (M.normalMap.value = g.normalMap, t(g.normalMap, M.normalMapTransform), M.normalScale.value.copy(g.normalScale), g.side === ai && M.normalScale.value.negate()), g.displacementMap && (M.displacementMap.value = g.displacementMap, t(g.displacementMap, M.displacementMapTransform), M.displacementScale.value = g.displacementScale, M.displacementBias.value = g.displacementBias), g.emissiveMap && (M.emissiveMap.value = g.emissiveMap, t(g.emissiveMap, M.emissiveMapTransform)), g.specularMap && (M.specularMap.value = g.specularMap, t(g.specularMap, M.specularMapTransform)), g.alphaTest > 0 && (M.alphaTest.value = g.alphaTest);
    const x = e.get(g).envMap;
    if (x && (M.envMap.value = x, M.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, M.reflectivity.value = g.reflectivity, M.ior.value = g.ior, M.refractionRatio.value = g.refractionRatio), g.lightMap) {
      M.lightMap.value = g.lightMap;
      const S = n.useLegacyLights === !0 ? Math.PI : 1;
      M.lightMapIntensity.value = g.lightMapIntensity * S, t(g.lightMap, M.lightMapTransform);
    }
    g.aoMap && (M.aoMap.value = g.aoMap, M.aoMapIntensity.value = g.aoMapIntensity, t(g.aoMap, M.aoMapTransform));
  }
  function o(M, g) {
    M.diffuse.value.copy(g.color), M.opacity.value = g.opacity, g.map && (M.map.value = g.map, t(g.map, M.mapTransform));
  }
  function l(M, g) {
    M.dashSize.value = g.dashSize, M.totalSize.value = g.dashSize + g.gapSize, M.scale.value = g.scale;
  }
  function c(M, g, x, S) {
    M.diffuse.value.copy(g.color), M.opacity.value = g.opacity, M.size.value = g.size * x, M.scale.value = S * 0.5, g.map && (M.map.value = g.map, t(g.map, M.uvTransform)), g.alphaMap && (M.alphaMap.value = g.alphaMap, t(g.alphaMap, M.alphaMapTransform)), g.alphaTest > 0 && (M.alphaTest.value = g.alphaTest);
  }
  function f(M, g) {
    M.diffuse.value.copy(g.color), M.opacity.value = g.opacity, M.rotation.value = g.rotation, g.map && (M.map.value = g.map, t(g.map, M.mapTransform)), g.alphaMap && (M.alphaMap.value = g.alphaMap, t(g.alphaMap, M.alphaMapTransform)), g.alphaTest > 0 && (M.alphaTest.value = g.alphaTest);
  }
  function h(M, g) {
    M.specular.value.copy(g.specular), M.shininess.value = Math.max(g.shininess, 1e-4);
  }
  function d(M, g) {
    g.gradientMap && (M.gradientMap.value = g.gradientMap);
  }
  function m(M, g) {
    M.metalness.value = g.metalness, g.metalnessMap && (M.metalnessMap.value = g.metalnessMap, t(g.metalnessMap, M.metalnessMapTransform)), M.roughness.value = g.roughness, g.roughnessMap && (M.roughnessMap.value = g.roughnessMap, t(g.roughnessMap, M.roughnessMapTransform)), e.get(g).envMap && (M.envMapIntensity.value = g.envMapIntensity);
  }
  function v(M, g, x) {
    M.ior.value = g.ior, g.sheen > 0 && (M.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), M.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (M.sheenColorMap.value = g.sheenColorMap, t(g.sheenColorMap, M.sheenColorMapTransform)), g.sheenRoughnessMap && (M.sheenRoughnessMap.value = g.sheenRoughnessMap, t(g.sheenRoughnessMap, M.sheenRoughnessMapTransform))), g.clearcoat > 0 && (M.clearcoat.value = g.clearcoat, M.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (M.clearcoatMap.value = g.clearcoatMap, t(g.clearcoatMap, M.clearcoatMapTransform)), g.clearcoatRoughnessMap && (M.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap, t(g.clearcoatRoughnessMap, M.clearcoatRoughnessMapTransform)), g.clearcoatNormalMap && (M.clearcoatNormalMap.value = g.clearcoatNormalMap, t(g.clearcoatNormalMap, M.clearcoatNormalMapTransform), M.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), g.side === ai && M.clearcoatNormalScale.value.negate())), g.iridescence > 0 && (M.iridescence.value = g.iridescence, M.iridescenceIOR.value = g.iridescenceIOR, M.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0], M.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1], g.iridescenceMap && (M.iridescenceMap.value = g.iridescenceMap, t(g.iridescenceMap, M.iridescenceMapTransform)), g.iridescenceThicknessMap && (M.iridescenceThicknessMap.value = g.iridescenceThicknessMap, t(g.iridescenceThicknessMap, M.iridescenceThicknessMapTransform))), g.transmission > 0 && (M.transmission.value = g.transmission, M.transmissionSamplerMap.value = x.texture, M.transmissionSamplerSize.value.set(x.width, x.height), g.transmissionMap && (M.transmissionMap.value = g.transmissionMap, t(g.transmissionMap, M.transmissionMapTransform)), M.thickness.value = g.thickness, g.thicknessMap && (M.thicknessMap.value = g.thicknessMap, t(g.thicknessMap, M.thicknessMapTransform)), M.attenuationDistance.value = g.attenuationDistance, M.attenuationColor.value.copy(g.attenuationColor)), g.anisotropy > 0 && (M.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)), g.anisotropyMap && (M.anisotropyMap.value = g.anisotropyMap, t(g.anisotropyMap, M.anisotropyMapTransform))), M.specularIntensity.value = g.specularIntensity, M.specularColor.value.copy(g.specularColor), g.specularColorMap && (M.specularColorMap.value = g.specularColorMap, t(g.specularColorMap, M.specularColorMapTransform)), g.specularIntensityMap && (M.specularIntensityMap.value = g.specularIntensityMap, t(g.specularIntensityMap, M.specularIntensityMapTransform));
  }
  function _(M, g) {
    g.matcap && (M.matcap.value = g.matcap);
  }
  function w(M, g) {
    const x = e.get(g).light;
    M.referencePosition.value.setFromMatrixPosition(x.matrixWorld), M.nearDistance.value = x.shadow.camera.near, M.farDistance.value = x.shadow.camera.far;
  }
  return {
    refreshFogUniforms: i,
    refreshMaterialUniforms: r
  };
}
function UU(n, e, t, i) {
  let r = {}, s = {}, o = [];
  const l = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function c(x, S) {
    const T = S.program;
    i.uniformBlockBinding(x, T);
  }
  function f(x, S) {
    let T = r[x.id];
    T === void 0 && (_(x), T = h(x), r[x.id] = T, x.addEventListener("dispose", M));
    const C = S.program;
    i.updateUBOMapping(x, C);
    const P = e.render.frame;
    s[x.id] !== P && (m(x), s[x.id] = P);
  }
  function h(x) {
    const S = d();
    x.__bindingPointIndex = S;
    const T = n.createBuffer(), C = x.__size, P = x.usage;
    return n.bindBuffer(n.UNIFORM_BUFFER, T), n.bufferData(n.UNIFORM_BUFFER, C, P), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, S, T), T;
  }
  function d() {
    for (let x = 0; x < l; x++)
      if (o.indexOf(x) === -1)
        return o.push(x), x;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function m(x) {
    const S = r[x.id], T = x.uniforms, C = x.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, S);
    for (let P = 0, L = T.length; P < L; P++) {
      const N = T[P];
      if (v(N, P, C) === !0) {
        const R = N.__offset, b = Array.isArray(N.value) ? N.value : [N.value];
        let G = 0;
        for (let $ = 0; $ < b.length; $++) {
          const Y = b[$], K = w(Y);
          typeof Y == "number" ? (N.__data[0] = Y, n.bufferSubData(n.UNIFORM_BUFFER, R + G, N.__data)) : Y.isMatrix3 ? (N.__data[0] = Y.elements[0], N.__data[1] = Y.elements[1], N.__data[2] = Y.elements[2], N.__data[3] = Y.elements[0], N.__data[4] = Y.elements[3], N.__data[5] = Y.elements[4], N.__data[6] = Y.elements[5], N.__data[7] = Y.elements[0], N.__data[8] = Y.elements[6], N.__data[9] = Y.elements[7], N.__data[10] = Y.elements[8], N.__data[11] = Y.elements[0]) : (Y.toArray(N.__data, G), G += K.storage / Float32Array.BYTES_PER_ELEMENT);
        }
        n.bufferSubData(n.UNIFORM_BUFFER, R, N.__data);
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function v(x, S, T) {
    const C = x.value;
    if (T[S] === void 0) {
      if (typeof C == "number")
        T[S] = C;
      else {
        const P = Array.isArray(C) ? C : [C], L = [];
        for (let N = 0; N < P.length; N++)
          L.push(P[N].clone());
        T[S] = L;
      }
      return !0;
    } else if (typeof C == "number") {
      if (T[S] !== C)
        return T[S] = C, !0;
    } else {
      const P = Array.isArray(T[S]) ? T[S] : [T[S]], L = Array.isArray(C) ? C : [C];
      for (let N = 0; N < P.length; N++) {
        const R = P[N];
        if (R.equals(L[N]) === !1)
          return R.copy(L[N]), !0;
      }
    }
    return !1;
  }
  function _(x) {
    const S = x.uniforms;
    let T = 0;
    const C = 16;
    let P = 0;
    for (let L = 0, N = S.length; L < N; L++) {
      const R = S[L], b = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      }, G = Array.isArray(R.value) ? R.value : [R.value];
      for (let $ = 0, Y = G.length; $ < Y; $++) {
        const K = G[$], J = w(K);
        b.boundary += J.boundary, b.storage += J.storage;
      }
      if (R.__data = new Float32Array(b.storage / Float32Array.BYTES_PER_ELEMENT), R.__offset = T, L > 0) {
        P = T % C;
        const $ = C - P;
        P !== 0 && $ - b.boundary < 0 && (T += C - P, R.__offset = T);
      }
      T += b.storage;
    }
    return P = T % C, P > 0 && (T += C - P), x.__size = T, x.__cache = {}, this;
  }
  function w(x) {
    const S = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof x == "number" ? (S.boundary = 4, S.storage = 4) : x.isVector2 ? (S.boundary = 8, S.storage = 8) : x.isVector3 || x.isColor ? (S.boundary = 16, S.storage = 12) : x.isVector4 ? (S.boundary = 16, S.storage = 16) : x.isMatrix3 ? (S.boundary = 48, S.storage = 48) : x.isMatrix4 ? (S.boundary = 64, S.storage = 64) : x.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", x), S;
  }
  function M(x) {
    const S = x.target;
    S.removeEventListener("dispose", M);
    const T = o.indexOf(S.__bindingPointIndex);
    o.splice(T, 1), n.deleteBuffer(r[S.id]), delete r[S.id], delete s[S.id];
  }
  function g() {
    for (const x in r)
      n.deleteBuffer(r[x]);
    o = [], r = {}, s = {};
  }
  return {
    bind: c,
    update: f,
    dispose: g
  };
}
function OU() {
  const n = Lc("canvas");
  return n.style.display = "block", n;
}
class __ {
  constructor(e = {}) {
    const {
      canvas: t = OU(),
      context: i = null,
      depth: r = !0,
      stencil: s = !0,
      alpha: o = !1,
      antialias: l = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: f = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: d = !1
    } = e;
    this.isWebGLRenderer = !0;
    let m;
    i !== null ? m = i.getContextAttributes().alpha : m = o;
    const v = new Uint32Array(4), _ = new Int32Array(4);
    let w = null, M = null;
    const g = [], x = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputColorSpace = pt, this.useLegacyLights = !0, this.toneMapping = _r, this.toneMappingExposure = 1;
    const S = this;
    let T = !1, C = 0, P = 0, L = null, N = -1, R = null;
    const b = new kt(), G = new kt();
    let $ = null;
    const Y = new ze(0);
    let K = 0, J = t.width, oe = t.height, ne = 1, O = null, X = null;
    const W = new kt(0, 0, J, oe), V = new kt(0, 0, J, oe);
    let j = !1;
    const de = new Cp();
    let ye = !1, Te = !1, Ie = null;
    const Be = new dt(), je = new me(), vt = new D(), lt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function Re() {
      return L === null ? ne : 1;
    }
    let z = i;
    function ge(U, te) {
      for (let ce = 0; ce < U.length; ce++) {
        const Q = U[ce], he = t.getContext(Q, te);
        if (he !== null)
          return he;
      }
      return null;
    }
    try {
      const U = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: l,
        premultipliedAlpha: c,
        preserveDrawingBuffer: f,
        powerPreference: h,
        failIfMajorPerformanceCaveat: d
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Sp}`), t.addEventListener("webglcontextlost", Me, !1), t.addEventListener("webglcontextrestored", ie, !1), t.addEventListener("webglcontextcreationerror", Ae, !1), z === null) {
        const te = ["webgl2", "webgl", "experimental-webgl"];
        if (S.isWebGL1Renderer === !0 && te.shift(), z = ge(te, U), z === null)
          throw ge(te) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" && z instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), z.getShaderPrecisionFormat === void 0 && (z.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (U) {
      throw console.error("THREE.WebGLRenderer: " + U.message), U;
    }
    let fe, Se, ve, He, Oe, Fe, Je, mt, Ut, F, I, ae, we, _e, Pe, qe, be, ue, Qe, $e, et, Ve, B, pe;
    function Ne() {
      fe = new JN(z), Se = new XN(z, fe, e), fe.init(Se), Ve = new JA(z, fe, Se), ve = new bU(z, fe, Se), He = new eD(z), Oe = new yU(), Fe = new LU(z, fe, ve, Oe, Se, Ve, He), Je = new YN(S), mt = new KN(S), Ut = new c3(z, Se), B = new GN(z, fe, Ut, Se), F = new QN(z, Ut, He, B), I = new rD(z, F, Ut, He), Qe = new iD(z, Se, Fe), qe = new jN(Oe), ae = new vU(S, Je, mt, fe, Se, B, qe), we = new DU(S, Oe), _e = new xU(), Pe = new AU(fe, Se), ue = new VN(S, Je, mt, ve, I, m, c), be = new PU(S, I, Se), pe = new UU(z, He, Se, ve), $e = new WN(z, fe, He, Se), et = new $N(z, fe, He, Se), He.programs = ae.programs, S.capabilities = Se, S.extensions = fe, S.properties = Oe, S.renderLists = _e, S.shadowMap = be, S.state = ve, S.info = He;
    }
    Ne();
    const H = new NU(S, z);
    this.xr = H, this.getContext = function() {
      return z;
    }, this.getContextAttributes = function() {
      return z.getContextAttributes();
    }, this.forceContextLoss = function() {
      const U = fe.get("WEBGL_lose_context");
      U && U.loseContext();
    }, this.forceContextRestore = function() {
      const U = fe.get("WEBGL_lose_context");
      U && U.restoreContext();
    }, this.getPixelRatio = function() {
      return ne;
    }, this.setPixelRatio = function(U) {
      U !== void 0 && (ne = U, this.setSize(J, oe, !1));
    }, this.getSize = function(U) {
      return U.set(J, oe);
    }, this.setSize = function(U, te, ce = !0) {
      if (H.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      J = U, oe = te, t.width = Math.floor(U * ne), t.height = Math.floor(te * ne), ce === !0 && (t.style.width = U + "px", t.style.height = te + "px"), this.setViewport(0, 0, U, te);
    }, this.getDrawingBufferSize = function(U) {
      return U.set(J * ne, oe * ne).floor();
    }, this.setDrawingBufferSize = function(U, te, ce) {
      J = U, oe = te, ne = ce, t.width = Math.floor(U * ce), t.height = Math.floor(te * ce), this.setViewport(0, 0, U, te);
    }, this.getCurrentViewport = function(U) {
      return U.copy(b);
    }, this.getViewport = function(U) {
      return U.copy(W);
    }, this.setViewport = function(U, te, ce, Q) {
      U.isVector4 ? W.set(U.x, U.y, U.z, U.w) : W.set(U, te, ce, Q), ve.viewport(b.copy(W).multiplyScalar(ne).floor());
    }, this.getScissor = function(U) {
      return U.copy(V);
    }, this.setScissor = function(U, te, ce, Q) {
      U.isVector4 ? V.set(U.x, U.y, U.z, U.w) : V.set(U, te, ce, Q), ve.scissor(G.copy(V).multiplyScalar(ne).floor());
    }, this.getScissorTest = function() {
      return j;
    }, this.setScissorTest = function(U) {
      ve.setScissorTest(j = U);
    }, this.setOpaqueSort = function(U) {
      O = U;
    }, this.setTransparentSort = function(U) {
      X = U;
    }, this.getClearColor = function(U) {
      return U.copy(ue.getClearColor());
    }, this.setClearColor = function() {
      ue.setClearColor.apply(ue, arguments);
    }, this.getClearAlpha = function() {
      return ue.getClearAlpha();
    }, this.setClearAlpha = function() {
      ue.setClearAlpha.apply(ue, arguments);
    }, this.clear = function(U = !0, te = !0, ce = !0) {
      let Q = 0;
      if (U) {
        let he = !1;
        if (L !== null) {
          const We = L.texture.format;
          he = We === a_ || We === o_ || We === s_;
        }
        if (he) {
          const We = L.texture.type, tt = We === Hr || We === ms || We === Ep || We === no || We === i_ || We === r_, rt = ue.getClearColor(), st = ue.getClearAlpha(), St = rt.r, ot = rt.g, at = rt.b;
          tt ? (v[0] = St, v[1] = ot, v[2] = at, v[3] = st, z.clearBufferuiv(z.COLOR, 0, v)) : (_[0] = St, _[1] = ot, _[2] = at, _[3] = st, z.clearBufferiv(z.COLOR, 0, _));
        } else
          Q |= z.COLOR_BUFFER_BIT;
      }
      te && (Q |= z.DEPTH_BUFFER_BIT), ce && (Q |= z.STENCIL_BUFFER_BIT), z.clear(Q);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", Me, !1), t.removeEventListener("webglcontextrestored", ie, !1), t.removeEventListener("webglcontextcreationerror", Ae, !1), _e.dispose(), Pe.dispose(), Oe.dispose(), Je.dispose(), mt.dispose(), I.dispose(), B.dispose(), pe.dispose(), ae.dispose(), H.dispose(), H.removeEventListener("sessionstart", Nt), H.removeEventListener("sessionend", Mn), Ie && (Ie.dispose(), Ie = null), nn.stop();
    };
    function Me(U) {
      U.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), T = !0;
    }
    function ie() {
      console.log("THREE.WebGLRenderer: Context Restored."), T = !1;
      const U = He.autoReset, te = be.enabled, ce = be.autoUpdate, Q = be.needsUpdate, he = be.type;
      Ne(), He.autoReset = U, be.enabled = te, be.autoUpdate = ce, be.needsUpdate = Q, be.type = he;
    }
    function Ae(U) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", U.statusMessage);
    }
    function De(U) {
      const te = U.target;
      te.removeEventListener("dispose", De), Et(te);
    }
    function Et(U) {
      At(U), Oe.remove(U);
    }
    function At(U) {
      const te = Oe.get(U).programs;
      te !== void 0 && (te.forEach(function(ce) {
        ae.releaseProgram(ce);
      }), U.isShaderMaterial && ae.releaseShaderCache(U));
    }
    this.renderBufferDirect = function(U, te, ce, Q, he, We) {
      te === null && (te = lt);
      const tt = he.isMesh && he.matrixWorld.determinant() < 0, rt = Jp(U, te, ce, Q, he);
      ve.setMaterial(Q, tt);
      let st = ce.index, St = 1;
      Q.wireframe === !0 && (st = F.getWireframeAttribute(ce), St = 2);
      const ot = ce.drawRange, at = ce.attributes.position;
      let Vt = ot.start * St, Wt = (ot.start + ot.count) * St;
      We !== null && (Vt = Math.max(Vt, We.start * St), Wt = Math.min(Wt, (We.start + We.count) * St)), st !== null ? (Vt = Math.max(Vt, 0), Wt = Math.min(Wt, st.count)) : at != null && (Vt = Math.max(Vt, 0), Wt = Math.min(Wt, at.count));
      const wi = Wt - Vt;
      if (wi < 0 || wi === 1 / 0)
        return;
      B.setup(he, Q, rt, ce, st);
      let Ei, zt = $e;
      if (st !== null && (Ei = Ut.get(st), zt = et, zt.setIndex(Ei)), he.isMesh)
        Q.wireframe === !0 ? (ve.setLineWidth(Q.wireframeLinewidth * Re()), zt.setMode(z.LINES)) : zt.setMode(z.TRIANGLES);
      else if (he.isLine) {
        let ct = Q.linewidth;
        ct === void 0 && (ct = 1), ve.setLineWidth(ct * Re()), he.isLineSegments ? zt.setMode(z.LINES) : he.isLineLoop ? zt.setMode(z.LINE_LOOP) : zt.setMode(z.LINE_STRIP);
      } else
        he.isPoints ? zt.setMode(z.POINTS) : he.isSprite && zt.setMode(z.TRIANGLES);
      if (he.isInstancedMesh)
        zt.renderInstances(Vt, wi, he.count);
      else if (ce.isInstancedBufferGeometry) {
        const ct = ce._maxInstanceCount !== void 0 ? ce._maxInstanceCount : 1 / 0, Ot = Math.min(ce.instanceCount, ct);
        zt.renderInstances(Vt, wi, Ot);
      } else
        zt.render(Vt, wi);
    }, this.compile = function(U, te) {
      function ce(Q, he, We) {
        Q.transparent === !0 && Q.side === gr && Q.forceSinglePass === !1 ? (Q.side = ai, Q.needsUpdate = !0, Ar(Q, he, We), Q.side = Ms, Q.needsUpdate = !0, Ar(Q, he, We), Q.side = gr) : Ar(Q, he, We);
      }
      M = Pe.get(U), M.init(), x.push(M), U.traverseVisible(function(Q) {
        Q.isLight && Q.layers.test(te.layers) && (M.pushLight(Q), Q.castShadow && M.pushShadow(Q));
      }), M.setupLights(S.useLegacyLights), U.traverse(function(Q) {
        const he = Q.material;
        if (he)
          if (Array.isArray(he))
            for (let We = 0; We < he.length; We++) {
              const tt = he[We];
              ce(tt, U, Q);
            }
          else
            ce(he, U, Q);
      }), x.pop(), M = null;
    };
    let Dt = null;
    function Sn(U) {
      Dt && Dt(U);
    }
    function Nt() {
      nn.stop();
    }
    function Mn() {
      nn.start();
    }
    const nn = new jA();
    nn.setAnimationLoop(Sn), typeof self < "u" && nn.setContext(self), this.setAnimationLoop = function(U) {
      Dt = U, H.setAnimationLoop(U), U === null ? nn.stop() : nn.start();
    }, H.addEventListener("sessionstart", Nt), H.addEventListener("sessionend", Mn), this.render = function(U, te) {
      if (te !== void 0 && te.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (T === !0)
        return;
      U.matrixWorldAutoUpdate === !0 && U.updateMatrixWorld(), te.parent === null && te.matrixWorldAutoUpdate === !0 && te.updateMatrixWorld(), H.enabled === !0 && H.isPresenting === !0 && (H.cameraAutoUpdate === !0 && H.updateCamera(te), te = H.getCamera()), U.isScene === !0 && U.onBeforeRender(S, U, te, L), M = Pe.get(U, x.length), M.init(), x.push(M), Be.multiplyMatrices(te.projectionMatrix, te.matrixWorldInverse), de.setFromProjectionMatrix(Be), Te = this.localClippingEnabled, ye = qe.init(this.clippingPlanes, Te), w = _e.get(U, g.length), w.init(), g.push(w), nf(U, te, 0, S.sortObjects), w.finish(), S.sortObjects === !0 && w.sort(O, X), this.info.render.frame++, ye === !0 && qe.beginShadows();
      const ce = M.state.shadowsArray;
      if (be.render(ce, U, te), ye === !0 && qe.endShadows(), this.info.autoReset === !0 && this.info.reset(), ue.render(w, U), M.setupLights(S.useLegacyLights), te.isArrayCamera) {
        const Q = te.cameras;
        for (let he = 0, We = Q.length; he < We; he++) {
          const tt = Q[he];
          rf(w, U, tt, tt.viewport);
        }
      } else
        rf(w, U, te);
      L !== null && (Fe.updateMultisampleRenderTarget(L), Fe.updateRenderTargetMipmap(L)), U.isScene === !0 && U.onAfterRender(S, U, te), B.resetDefaultState(), N = -1, R = null, x.pop(), x.length > 0 ? M = x[x.length - 1] : M = null, g.pop(), g.length > 0 ? w = g[g.length - 1] : w = null;
    };
    function nf(U, te, ce, Q) {
      if (U.visible === !1)
        return;
      if (U.layers.test(te.layers)) {
        if (U.isGroup)
          ce = U.renderOrder;
        else if (U.isLOD)
          U.autoUpdate === !0 && U.update(te);
        else if (U.isLight)
          M.pushLight(U), U.castShadow && M.pushShadow(U);
        else if (U.isSprite) {
          if (!U.frustumCulled || de.intersectsSprite(U)) {
            Q && vt.setFromMatrixPosition(U.matrixWorld).applyMatrix4(Be);
            const tt = I.update(U), rt = U.material;
            rt.visible && w.push(U, tt, rt, ce, vt.z, null);
          }
        } else if ((U.isMesh || U.isLine || U.isPoints) && (!U.frustumCulled || de.intersectsObject(U))) {
          const tt = I.update(U), rt = U.material;
          if (Q && (U.boundingSphere !== void 0 ? (U.boundingSphere === null && U.computeBoundingSphere(), vt.copy(U.boundingSphere.center)) : (tt.boundingSphere === null && tt.computeBoundingSphere(), vt.copy(tt.boundingSphere.center)), vt.applyMatrix4(U.matrixWorld).applyMatrix4(Be)), Array.isArray(rt)) {
            const st = tt.groups;
            for (let St = 0, ot = st.length; St < ot; St++) {
              const at = st[St], Vt = rt[at.materialIndex];
              Vt && Vt.visible && w.push(U, tt, Vt, ce, vt.z, at);
            }
          } else
            rt.visible && w.push(U, tt, rt, ce, vt.z, null);
        }
      }
      const We = U.children;
      for (let tt = 0, rt = We.length; tt < rt; tt++)
        nf(We[tt], te, ce, Q);
    }
    function rf(U, te, ce, Q) {
      const he = U.opaque, We = U.transmissive, tt = U.transparent;
      M.setupLightsView(ce), ye === !0 && qe.setGlobalState(S.clippingPlanes, ce), We.length > 0 && sf(he, We, te, ce), Q && ve.viewport(b.copy(Q)), he.length > 0 && As(he, te, ce), We.length > 0 && As(We, te, ce), tt.length > 0 && As(tt, te, ce), ve.buffers.depth.setTest(!0), ve.buffers.depth.setMask(!0), ve.buffers.color.setMask(!0), ve.setPolygonOffset(!1);
    }
    function sf(U, te, ce, Q) {
      const he = Se.isWebGL2;
      Ie === null && (Ie = new Mr(1, 1, {
        generateMipmaps: !0,
        type: fe.has("EXT_color_buffer_half_float") ? Bl : Hr,
        minFilter: co,
        samples: he ? 4 : 0
      })), S.getDrawingBufferSize(je), he ? Ie.setSize(je.x, je.y) : Ie.setSize(np(je.x), np(je.y));
      const We = S.getRenderTarget();
      S.setRenderTarget(Ie), S.getClearColor(Y), K = S.getClearAlpha(), K < 1 && S.setClearColor(16777215, 0.5), S.clear();
      const tt = S.toneMapping;
      S.toneMapping = _r, As(U, ce, Q), Fe.updateMultisampleRenderTarget(Ie), Fe.updateRenderTargetMipmap(Ie);
      let rt = !1;
      for (let st = 0, St = te.length; st < St; st++) {
        const ot = te[st], at = ot.object, Vt = ot.geometry, Wt = ot.material, wi = ot.group;
        if (Wt.side === gr && at.layers.test(Q.layers)) {
          const Ei = Wt.side;
          Wt.side = ai, Wt.needsUpdate = !0, of(at, ce, Q, Vt, Wt, wi), Wt.side = Ei, Wt.needsUpdate = !0, rt = !0;
        }
      }
      rt === !0 && (Fe.updateMultisampleRenderTarget(Ie), Fe.updateRenderTargetMipmap(Ie)), S.setRenderTarget(We), S.setClearColor(Y, K), S.toneMapping = tt;
    }
    function As(U, te, ce) {
      const Q = te.isScene === !0 ? te.overrideMaterial : null;
      for (let he = 0, We = U.length; he < We; he++) {
        const tt = U[he], rt = tt.object, st = tt.geometry, St = Q === null ? tt.material : Q, ot = tt.group;
        rt.layers.test(ce.layers) && of(rt, te, ce, st, St, ot);
      }
    }
    function of(U, te, ce, Q, he, We) {
      U.onBeforeRender(S, te, ce, Q, he, We), U.modelViewMatrix.multiplyMatrices(ce.matrixWorldInverse, U.matrixWorld), U.normalMatrix.getNormalMatrix(U.modelViewMatrix), he.onBeforeRender(S, te, ce, Q, U, We), he.transparent === !0 && he.side === gr && he.forceSinglePass === !1 ? (he.side = ai, he.needsUpdate = !0, S.renderBufferDirect(ce, te, Q, he, U, We), he.side = Ms, he.needsUpdate = !0, S.renderBufferDirect(ce, te, Q, he, U, We), he.side = gr) : S.renderBufferDirect(ce, te, Q, he, U, We), U.onAfterRender(S, te, ce, Q, he, We);
    }
    function Ar(U, te, ce) {
      te.isScene !== !0 && (te = lt);
      const Q = Oe.get(U), he = M.state.lights, We = M.state.shadowsArray, tt = he.state.version, rt = ae.getParameters(U, he.state, We, te, ce), st = ae.getProgramCacheKey(rt);
      let St = Q.programs;
      Q.environment = U.isMeshStandardMaterial ? te.environment : null, Q.fog = te.fog, Q.envMap = (U.isMeshStandardMaterial ? mt : Je).get(U.envMap || Q.environment), St === void 0 && (U.addEventListener("dispose", De), St = /* @__PURE__ */ new Map(), Q.programs = St);
      let ot = St.get(st);
      if (ot !== void 0) {
        if (Q.currentProgram === ot && Q.lightsStateVersion === tt)
          return af(U, rt), ot;
      } else
        rt.uniforms = ae.getUniforms(U), U.onBuild(ce, rt, S), U.onBeforeCompile(rt, S), ot = ae.acquireProgram(rt, st), St.set(st, ot), Q.uniforms = rt.uniforms;
      const at = Q.uniforms;
      (!U.isShaderMaterial && !U.isRawShaderMaterial || U.clipping === !0) && (at.clippingPlanes = qe.uniform), af(U, rt), Q.needsLights = $p(U), Q.lightsStateVersion = tt, Q.needsLights && (at.ambientLightColor.value = he.state.ambient, at.lightProbe.value = he.state.probe, at.directionalLights.value = he.state.directional, at.directionalLightShadows.value = he.state.directionalShadow, at.spotLights.value = he.state.spot, at.spotLightShadows.value = he.state.spotShadow, at.rectAreaLights.value = he.state.rectArea, at.ltc_1.value = he.state.rectAreaLTC1, at.ltc_2.value = he.state.rectAreaLTC2, at.pointLights.value = he.state.point, at.pointLightShadows.value = he.state.pointShadow, at.hemisphereLights.value = he.state.hemi, at.directionalShadowMap.value = he.state.directionalShadowMap, at.directionalShadowMatrix.value = he.state.directionalShadowMatrix, at.spotShadowMap.value = he.state.spotShadowMap, at.spotLightMatrix.value = he.state.spotLightMatrix, at.spotLightMap.value = he.state.spotLightMap, at.pointShadowMap.value = he.state.pointShadowMap, at.pointShadowMatrix.value = he.state.pointShadowMatrix);
      const Vt = ot.getUniforms(), Wt = Cd.seqWithValue(Vt.seq, at);
      return Q.currentProgram = ot, Q.uniformsList = Wt, ot;
    }
    function af(U, te) {
      const ce = Oe.get(U);
      ce.outputColorSpace = te.outputColorSpace, ce.instancing = te.instancing, ce.skinning = te.skinning, ce.morphTargets = te.morphTargets, ce.morphNormals = te.morphNormals, ce.morphColors = te.morphColors, ce.morphTargetsCount = te.morphTargetsCount, ce.numClippingPlanes = te.numClippingPlanes, ce.numIntersection = te.numClipIntersection, ce.vertexAlphas = te.vertexAlphas, ce.vertexTangents = te.vertexTangents, ce.toneMapping = te.toneMapping;
    }
    function Jp(U, te, ce, Q, he) {
      te.isScene !== !0 && (te = lt), Fe.resetTextureUnits();
      const We = te.fog, tt = Q.isMeshStandardMaterial ? te.environment : null, rt = L === null ? S.outputColorSpace : L.isXRRenderTarget === !0 ? L.texture.colorSpace : Sr, st = (Q.isMeshStandardMaterial ? mt : Je).get(Q.envMap || tt), St = Q.vertexColors === !0 && !!ce.attributes.color && ce.attributes.color.itemSize === 4, ot = !!ce.attributes.tangent && (!!Q.normalMap || Q.anisotropy > 0), at = !!ce.morphAttributes.position, Vt = !!ce.morphAttributes.normal, Wt = !!ce.morphAttributes.color, wi = Q.toneMapped ? S.toneMapping : _r, Ei = ce.morphAttributes.position || ce.morphAttributes.normal || ce.morphAttributes.color, zt = Ei !== void 0 ? Ei.length : 0, ct = Oe.get(Q), Ot = M.state.lights;
      if (ye === !0 && (Te === !0 || U !== R)) {
        const Hn = U === R && Q.id === N;
        qe.setState(Q, U, Hn);
      }
      let ut = !1;
      Q.version === ct.__version ? (ct.needsLights && ct.lightsStateVersion !== Ot.state.version || ct.outputColorSpace !== rt || he.isInstancedMesh && ct.instancing === !1 || !he.isInstancedMesh && ct.instancing === !0 || he.isSkinnedMesh && ct.skinning === !1 || !he.isSkinnedMesh && ct.skinning === !0 || ct.envMap !== st || Q.fog === !0 && ct.fog !== We || ct.numClippingPlanes !== void 0 && (ct.numClippingPlanes !== qe.numPlanes || ct.numIntersection !== qe.numIntersection) || ct.vertexAlphas !== St || ct.vertexTangents !== ot || ct.morphTargets !== at || ct.morphNormals !== Vt || ct.morphColors !== Wt || ct.toneMapping !== wi || Se.isWebGL2 === !0 && ct.morphTargetsCount !== zt) && (ut = !0) : (ut = !0, ct.__version = Q.version);
      let Bn = ct.currentProgram;
      ut === !0 && (Bn = Ar(Q, te, he));
      let wn = !1, gn = !1, ir = !1;
      const rn = Bn.getUniforms(), sn = ct.uniforms;
      if (ve.useProgram(Bn.program) && (wn = !0, gn = !0, ir = !0), Q.id !== N && (N = Q.id, gn = !0), wn || R !== U) {
        if (rn.setValue(z, "projectionMatrix", U.projectionMatrix), Se.logarithmicDepthBuffer && rn.setValue(
          z,
          "logDepthBufFC",
          2 / (Math.log(U.far + 1) / Math.LN2)
        ), R !== U && (R = U, gn = !0, ir = !0), Q.isShaderMaterial || Q.isMeshPhongMaterial || Q.isMeshToonMaterial || Q.isMeshStandardMaterial || Q.envMap) {
          const Hn = rn.map.cameraPosition;
          Hn !== void 0 && Hn.setValue(
            z,
            vt.setFromMatrixPosition(U.matrixWorld)
          );
        }
        (Q.isMeshPhongMaterial || Q.isMeshToonMaterial || Q.isMeshLambertMaterial || Q.isMeshBasicMaterial || Q.isMeshStandardMaterial || Q.isShaderMaterial) && rn.setValue(z, "isOrthographic", U.isOrthographicCamera === !0), (Q.isMeshPhongMaterial || Q.isMeshToonMaterial || Q.isMeshLambertMaterial || Q.isMeshBasicMaterial || Q.isMeshStandardMaterial || Q.isShaderMaterial || Q.isShadowMaterial || he.isSkinnedMesh) && rn.setValue(z, "viewMatrix", U.matrixWorldInverse);
      }
      if (he.isSkinnedMesh) {
        rn.setOptional(z, he, "bindMatrix"), rn.setOptional(z, he, "bindMatrixInverse");
        const Hn = he.skeleton;
        Hn && (Se.floatVertexTextures ? (Hn.boneTexture === null && Hn.computeBoneTexture(), rn.setValue(z, "boneTexture", Hn.boneTexture, Fe), rn.setValue(z, "boneTextureSize", Hn.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      const Cs = ce.morphAttributes;
      if ((Cs.position !== void 0 || Cs.normal !== void 0 || Cs.color !== void 0 && Se.isWebGL2 === !0) && Qe.update(he, ce, Bn), (gn || ct.receiveShadow !== he.receiveShadow) && (ct.receiveShadow = he.receiveShadow, rn.setValue(z, "receiveShadow", he.receiveShadow)), Q.isMeshGouraudMaterial && Q.envMap !== null && (sn.envMap.value = st, sn.flipEnvMap.value = st.isCubeTexture && st.isRenderTargetTexture === !1 ? -1 : 1), gn && (rn.setValue(z, "toneMappingExposure", S.toneMappingExposure), ct.needsLights && Qp(sn, ir), We && Q.fog === !0 && we.refreshFogUniforms(sn, We), we.refreshMaterialUniforms(sn, Q, ne, oe, Ie), Cd.upload(z, ct.uniformsList, sn, Fe)), Q.isShaderMaterial && Q.uniformsNeedUpdate === !0 && (Cd.upload(z, ct.uniformsList, sn, Fe), Q.uniformsNeedUpdate = !1), Q.isSpriteMaterial && rn.setValue(z, "center", he.center), rn.setValue(z, "modelViewMatrix", he.modelViewMatrix), rn.setValue(z, "normalMatrix", he.normalMatrix), rn.setValue(z, "modelMatrix", he.matrixWorld), Q.isShaderMaterial || Q.isRawShaderMaterial) {
        const Hn = Q.uniformsGroups;
        for (let xa = 0, Sa = Hn.length; xa < Sa; xa++)
          if (Se.isWebGL2) {
            const Ql = Hn[xa];
            pe.update(Ql, Bn), pe.bind(Ql, Bn);
          } else
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return Bn;
    }
    function Qp(U, te) {
      U.ambientLightColor.needsUpdate = te, U.lightProbe.needsUpdate = te, U.directionalLights.needsUpdate = te, U.directionalLightShadows.needsUpdate = te, U.pointLights.needsUpdate = te, U.pointLightShadows.needsUpdate = te, U.spotLights.needsUpdate = te, U.spotLightShadows.needsUpdate = te, U.rectAreaLights.needsUpdate = te, U.hemisphereLights.needsUpdate = te;
    }
    function $p(U) {
      return U.isMeshLambertMaterial || U.isMeshToonMaterial || U.isMeshPhongMaterial || U.isMeshStandardMaterial || U.isShadowMaterial || U.isShaderMaterial && U.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return C;
    }, this.getActiveMipmapLevel = function() {
      return P;
    }, this.getRenderTarget = function() {
      return L;
    }, this.setRenderTargetTextures = function(U, te, ce) {
      Oe.get(U.texture).__webglTexture = te, Oe.get(U.depthTexture).__webglTexture = ce;
      const Q = Oe.get(U);
      Q.__hasExternalTextures = !0, Q.__hasExternalTextures && (Q.__autoAllocateDepthBuffer = ce === void 0, Q.__autoAllocateDepthBuffer || fe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Q.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function(U, te) {
      const ce = Oe.get(U);
      ce.__webglFramebuffer = te, ce.__useDefaultFramebuffer = te === void 0;
    }, this.setRenderTarget = function(U, te = 0, ce = 0) {
      L = U, C = te, P = ce;
      let Q = !0, he = null, We = !1, tt = !1;
      if (U) {
        const st = Oe.get(U);
        st.__useDefaultFramebuffer !== void 0 ? (ve.bindFramebuffer(z.FRAMEBUFFER, null), Q = !1) : st.__webglFramebuffer === void 0 ? Fe.setupRenderTarget(U) : st.__hasExternalTextures && Fe.rebindTextures(U, Oe.get(U.texture).__webglTexture, Oe.get(U.depthTexture).__webglTexture);
        const St = U.texture;
        (St.isData3DTexture || St.isDataArrayTexture || St.isCompressedArrayTexture) && (tt = !0);
        const ot = Oe.get(U).__webglFramebuffer;
        U.isWebGLCubeRenderTarget ? (he = ot[te], We = !0) : Se.isWebGL2 && U.samples > 0 && Fe.useMultisampledRTT(U) === !1 ? he = Oe.get(U).__webglMultisampledFramebuffer : he = ot, b.copy(U.viewport), G.copy(U.scissor), $ = U.scissorTest;
      } else
        b.copy(W).multiplyScalar(ne).floor(), G.copy(V).multiplyScalar(ne).floor(), $ = j;
      if (ve.bindFramebuffer(z.FRAMEBUFFER, he) && Se.drawBuffers && Q && ve.drawBuffers(U, he), ve.viewport(b), ve.scissor(G), ve.setScissorTest($), We) {
        const st = Oe.get(U.texture);
        z.framebufferTexture2D(z.FRAMEBUFFER, z.COLOR_ATTACHMENT0, z.TEXTURE_CUBE_MAP_POSITIVE_X + te, st.__webglTexture, ce);
      } else if (tt) {
        const st = Oe.get(U.texture), St = te || 0;
        z.framebufferTextureLayer(z.FRAMEBUFFER, z.COLOR_ATTACHMENT0, st.__webglTexture, ce || 0, St);
      }
      N = -1;
    }, this.readRenderTargetPixels = function(U, te, ce, Q, he, We, tt) {
      if (!(U && U.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let rt = Oe.get(U).__webglFramebuffer;
      if (U.isWebGLCubeRenderTarget && tt !== void 0 && (rt = rt[tt]), rt) {
        ve.bindFramebuffer(z.FRAMEBUFFER, rt);
        try {
          const st = U.texture, St = st.format, ot = st.type;
          if (St !== vi && Ve.convert(St) !== z.getParameter(z.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const at = ot === Bl && (fe.has("EXT_color_buffer_half_float") || Se.isWebGL2 && fe.has("EXT_color_buffer_float"));
          if (ot !== Hr && Ve.convert(ot) !== z.getParameter(z.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(ot === kr && (Se.isWebGL2 || fe.has("OES_texture_float") || fe.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !at) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          te >= 0 && te <= U.width - Q && ce >= 0 && ce <= U.height - he && z.readPixels(te, ce, Q, he, Ve.convert(St), Ve.convert(ot), We);
        } finally {
          const st = L !== null ? Oe.get(L).__webglFramebuffer : null;
          ve.bindFramebuffer(z.FRAMEBUFFER, st);
        }
      }
    }, this.copyFramebufferToTexture = function(U, te, ce = 0) {
      const Q = Math.pow(2, -ce), he = Math.floor(te.image.width * Q), We = Math.floor(te.image.height * Q);
      Fe.setTexture2D(te, 0), z.copyTexSubImage2D(z.TEXTURE_2D, ce, 0, 0, U.x, U.y, he, We), ve.unbindTexture();
    }, this.copyTextureToTexture = function(U, te, ce, Q = 0) {
      const he = te.image.width, We = te.image.height, tt = Ve.convert(ce.format), rt = Ve.convert(ce.type);
      Fe.setTexture2D(ce, 0), z.pixelStorei(z.UNPACK_FLIP_Y_WEBGL, ce.flipY), z.pixelStorei(z.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ce.premultiplyAlpha), z.pixelStorei(z.UNPACK_ALIGNMENT, ce.unpackAlignment), te.isDataTexture ? z.texSubImage2D(z.TEXTURE_2D, Q, U.x, U.y, he, We, tt, rt, te.image.data) : te.isCompressedTexture ? z.compressedTexSubImage2D(z.TEXTURE_2D, Q, U.x, U.y, te.mipmaps[0].width, te.mipmaps[0].height, tt, te.mipmaps[0].data) : z.texSubImage2D(z.TEXTURE_2D, Q, U.x, U.y, tt, rt, te.image), Q === 0 && ce.generateMipmaps && z.generateMipmap(z.TEXTURE_2D), ve.unbindTexture();
    }, this.copyTextureToTexture3D = function(U, te, ce, Q, he = 0) {
      if (S.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const We = U.max.x - U.min.x + 1, tt = U.max.y - U.min.y + 1, rt = U.max.z - U.min.z + 1, st = Ve.convert(Q.format), St = Ve.convert(Q.type);
      let ot;
      if (Q.isData3DTexture)
        Fe.setTexture3D(Q, 0), ot = z.TEXTURE_3D;
      else if (Q.isDataArrayTexture)
        Fe.setTexture2DArray(Q, 0), ot = z.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      z.pixelStorei(z.UNPACK_FLIP_Y_WEBGL, Q.flipY), z.pixelStorei(z.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Q.premultiplyAlpha), z.pixelStorei(z.UNPACK_ALIGNMENT, Q.unpackAlignment);
      const at = z.getParameter(z.UNPACK_ROW_LENGTH), Vt = z.getParameter(z.UNPACK_IMAGE_HEIGHT), Wt = z.getParameter(z.UNPACK_SKIP_PIXELS), wi = z.getParameter(z.UNPACK_SKIP_ROWS), Ei = z.getParameter(z.UNPACK_SKIP_IMAGES), zt = ce.isCompressedTexture ? ce.mipmaps[0] : ce.image;
      z.pixelStorei(z.UNPACK_ROW_LENGTH, zt.width), z.pixelStorei(z.UNPACK_IMAGE_HEIGHT, zt.height), z.pixelStorei(z.UNPACK_SKIP_PIXELS, U.min.x), z.pixelStorei(z.UNPACK_SKIP_ROWS, U.min.y), z.pixelStorei(z.UNPACK_SKIP_IMAGES, U.min.z), ce.isDataTexture || ce.isData3DTexture ? z.texSubImage3D(ot, he, te.x, te.y, te.z, We, tt, rt, st, St, zt.data) : ce.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), z.compressedTexSubImage3D(ot, he, te.x, te.y, te.z, We, tt, rt, st, zt.data)) : z.texSubImage3D(ot, he, te.x, te.y, te.z, We, tt, rt, st, St, zt), z.pixelStorei(z.UNPACK_ROW_LENGTH, at), z.pixelStorei(z.UNPACK_IMAGE_HEIGHT, Vt), z.pixelStorei(z.UNPACK_SKIP_PIXELS, Wt), z.pixelStorei(z.UNPACK_SKIP_ROWS, wi), z.pixelStorei(z.UNPACK_SKIP_IMAGES, Ei), he === 0 && Q.generateMipmaps && z.generateMipmap(ot), ve.unbindTexture();
    }, this.initTexture = function(U) {
      U.isCubeTexture ? Fe.setTextureCube(U, 0) : U.isData3DTexture ? Fe.setTexture3D(U, 0) : U.isDataArrayTexture || U.isCompressedArrayTexture ? Fe.setTexture2DArray(U, 0) : Fe.setTexture2D(U, 0), ve.unbindTexture();
    }, this.resetState = function() {
      C = 0, P = 0, L = null, ve.reset(), B.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return Fr;
  }
  get physicallyCorrectLights() {
    return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights;
  }
  set physicallyCorrectLights(e) {
    console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e;
  }
  get outputEncoding() {
    return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === pt ? ro : u_;
  }
  set outputEncoding(e) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === ro ? pt : Sr;
  }
}
class e2 extends __ {
}
e2.prototype.isWebGL1Renderer = !0;
class Pp {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new ze(e), this.density = t;
  }
  clone() {
    return new Pp(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class bp {
  constructor(e, t = 1, i = 1e3) {
    this.isFog = !0, this.name = "", this.color = new ze(e), this.near = t, this.far = i;
  }
  clone() {
    return new bp(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class x_ extends It {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t;
  }
}
class Lp {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Pc, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Oi();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, i) {
    e *= this.stride, i *= t.stride;
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Oi()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Oi()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const ii = /* @__PURE__ */ new D();
class ca {
  constructor(e, t, i, r = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = r;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      ii.fromBufferAttribute(this, t), ii.applyMatrix4(e), this.setXYZ(t, ii.x, ii.y, ii.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      ii.fromBufferAttribute(this, t), ii.applyNormalMatrix(e), this.setXYZ(t, ii.x, ii.y, ii.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      ii.fromBufferAttribute(this, t), ii.transformDirection(e), this.setXYZ(t, ii.x, ii.y, ii.z);
    return this;
  }
  setX(e, t) {
    return this.normalized && (t = xt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = xt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = xt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = xt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Di(t, this.array)), t;
  }
  setXY(e, t, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = xt(t, this.array), i = xt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = xt(t, this.array), i = xt(i, this.array), r = xt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this;
  }
  setXYZW(e, t, i, r, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = xt(t, this.array), i = xt(i, this.array), r = xt(r, this.array), s = xt(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[r + s]);
      }
      return new Ht(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new ca(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class S_ extends ei {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new ze(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let Ja;
const bu = /* @__PURE__ */ new D(), Qa = /* @__PURE__ */ new D(), $a = /* @__PURE__ */ new D(), el = /* @__PURE__ */ new me(), Lu = /* @__PURE__ */ new me(), t2 = /* @__PURE__ */ new dt(), kh = /* @__PURE__ */ new D(), Iu = /* @__PURE__ */ new D(), Fh = /* @__PURE__ */ new D(), yM = /* @__PURE__ */ new me(), Jg = /* @__PURE__ */ new me(), _M = /* @__PURE__ */ new me();
class n2 extends It {
  constructor(e) {
    if (super(), this.isSprite = !0, this.type = "Sprite", Ja === void 0) {
      Ja = new wt();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), i = new Lp(t, 5);
      Ja.setIndex([0, 1, 2, 0, 2, 3]), Ja.setAttribute("position", new ca(i, 3, 0, !1)), Ja.setAttribute("uv", new ca(i, 2, 3, !1));
    }
    this.geometry = Ja, this.material = e !== void 0 ? e : new S_(), this.center = new me(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Qa.setFromMatrixScale(this.matrixWorld), t2.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), $a.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Qa.multiplyScalar(-$a.z);
    const i = this.material.rotation;
    let r, s;
    i !== 0 && (s = Math.cos(i), r = Math.sin(i));
    const o = this.center;
    zh(kh.set(-0.5, -0.5, 0), $a, o, Qa, r, s), zh(Iu.set(0.5, -0.5, 0), $a, o, Qa, r, s), zh(Fh.set(0.5, 0.5, 0), $a, o, Qa, r, s), yM.set(0, 0), Jg.set(1, 0), _M.set(1, 1);
    let l = e.ray.intersectTriangle(kh, Iu, Fh, !1, bu);
    if (l === null && (zh(Iu.set(-0.5, 0.5, 0), $a, o, Qa, r, s), Jg.set(0, 1), l = e.ray.intersectTriangle(kh, Fh, Iu, !1, bu), l === null))
      return;
    const c = e.ray.origin.distanceTo(bu);
    c < e.near || c > e.far || t.push({
      distance: c,
      point: bu.clone(),
      uv: gi.getInterpolation(bu, kh, Iu, Fh, yM, Jg, _M, new me()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function zh(n, e, t, i, r, s) {
  el.subVectors(n, t).addScalar(0.5).multiply(i), r !== void 0 ? (Lu.x = s * el.x - r * el.y, Lu.y = r * el.x + s * el.y) : Lu.copy(el), n.copy(e), n.x += Lu.x, n.y += Lu.y, n.applyMatrix4(t2);
}
const Bh = /* @__PURE__ */ new D(), xM = /* @__PURE__ */ new D();
class i2 extends It {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++)
      ;
    return r.splice(s, 0, { distance: t, hysteresis: i, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let s = t[i].distance;
        if (t[i].object.visible && (s -= s * t[i].hysteresis), e < s)
          break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Bh.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(Bh);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Bh.setFromMatrixPosition(e.matrixWorld), xM.setFromMatrixPosition(this.matrixWorld);
      const i = Bh.distanceTo(xM) / e.zoom;
      t[0].object.visible = !0;
      let r, s;
      for (r = 1, s = t.length; r < s; r++) {
        let o = t[r].distance;
        if (t[r].object.visible && (o -= o * t[r].hysteresis), i >= o)
          t[r - 1].object.visible = !1, t[r].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = r - 1; r < s; r++)
        t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const i = this.levels;
    for (let r = 0, s = i.length; r < s; r++) {
      const o = i[r];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis
      });
    }
    return t;
  }
}
const SM = /* @__PURE__ */ new D(), MM = /* @__PURE__ */ new kt(), wM = /* @__PURE__ */ new kt(), kU = /* @__PURE__ */ new D(), EM = /* @__PURE__ */ new dt(), tl = /* @__PURE__ */ new D(), Qg = /* @__PURE__ */ new wr(), TM = /* @__PURE__ */ new dt(), $g = /* @__PURE__ */ new ma();
class r2 extends kn {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new dt(), this.bindMatrixInverse = new dt(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new jr()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      tl.fromBufferAttribute(t, i), this.applyBoneTransform(i, tl), this.boundingBox.expandByPoint(tl);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new wr()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      tl.fromBufferAttribute(t, i), this.applyBoneTransform(i, tl), this.boundingSphere.expandByPoint(tl);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const i = this.material, r = this.matrixWorld;
    i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Qg.copy(this.boundingSphere), Qg.applyMatrix4(r), e.ray.intersectsSphere(Qg) !== !1 && (TM.copy(r).invert(), $g.copy(e.ray).applyMatrix4(TM), !(this.boundingBox !== null && $g.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, $g)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new kt(), t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton, r = this.geometry;
    MM.fromBufferAttribute(r.attributes.skinIndex, e), wM.fromBufferAttribute(r.attributes.skinWeight, e), SM.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = wM.getComponent(s);
      if (o !== 0) {
        const l = MM.getComponent(s);
        EM.multiplyMatrices(i.bones[l].matrixWorld, i.boneInverses[l]), t.addScaledVector(kU.copy(SM).applyMatrix4(EM), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t);
  }
}
class M_ extends It {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class Il extends mn {
  constructor(e = null, t = 1, i = 1, r, s, o, l, c, f = hn, h = hn, d, m) {
    super(null, o, l, c, f, h, r, s, d, m), this.isDataTexture = !0, this.image = { data: e, width: t, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const AM = /* @__PURE__ */ new dt(), FU = /* @__PURE__ */ new dt();
class Ip {
  constructor(e = [], t = []) {
    this.uuid = Oi(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new dt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new dt();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, i = this.boneMatrices, r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const l = e[s] ? e[s].matrixWorld : FU;
      AM.multiplyMatrices(l, t[s]), AM.toArray(i, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new Ip(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = FA(e), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Il(t, e, e, vi, kr);
    return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this.boneTextureSize = e, this;
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e)
        return r;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let o = t[s];
      o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new M_()), this.bones.push(o), this.boneInverses.push(new dt().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const l = i[r];
      e.boneInverses.push(l.toArray());
    }
    return e;
  }
}
class Gl extends Ht {
  constructor(e, t, i, r = 1) {
    super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const nl = /* @__PURE__ */ new dt(), CM = /* @__PURE__ */ new dt(), Hh = [], RM = /* @__PURE__ */ new jr(), zU = /* @__PURE__ */ new dt(), Nu = /* @__PURE__ */ new kn(), Du = /* @__PURE__ */ new wr();
class s2 extends kn {
  constructor(e, t, i) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Gl(new Float32Array(i * 16), 16), this.instanceColor = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
    for (let r = 0; r < i; r++)
      this.setMatrixAt(r, zU);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new jr()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, nl), RM.copy(e.boundingBox).applyMatrix4(nl), this.boundingBox.union(RM);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new wr()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, nl), Du.copy(e.boundingSphere).applyMatrix4(nl), this.boundingSphere.union(Du);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld, r = this.count;
    if (Nu.geometry = this.geometry, Nu.material = this.material, Nu.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Du.copy(this.boundingSphere), Du.applyMatrix4(i), e.ray.intersectsSphere(Du) !== !1))
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, nl), CM.multiplyMatrices(i, nl), Nu.matrixWorld = CM, Nu.raycast(e, Hh);
        for (let o = 0, l = Hh.length; o < l; o++) {
          const c = Hh[o];
          c.instanceId = s, c.object = this, t.push(c);
        }
        Hh.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new Gl(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ci extends ei {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new ze(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const PM = /* @__PURE__ */ new D(), bM = /* @__PURE__ */ new D(), LM = /* @__PURE__ */ new dt(), e0 = /* @__PURE__ */ new ma(), Vh = /* @__PURE__ */ new wr();
class fo extends It {
  constructor(e = new wt(), t = new ci()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [0];
      for (let r = 1, s = t.count; r < s; r++)
        PM.fromBufferAttribute(t, r - 1), bM.fromBufferAttribute(t, r), i[r] = i[r - 1], i[r] += PM.distanceTo(bM);
      e.setAttribute("lineDistance", new Ye(i, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.matrixWorld, s = e.params.Line.threshold, o = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), Vh.copy(i.boundingSphere), Vh.applyMatrix4(r), Vh.radius += s, e.ray.intersectsSphere(Vh) === !1)
      return;
    LM.copy(r).invert(), e0.copy(e.ray).applyMatrix4(LM);
    const l = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = l * l, f = new D(), h = new D(), d = new D(), m = new D(), v = this.isLineSegments ? 2 : 1, _ = i.index, M = i.attributes.position;
    if (_ !== null) {
      const g = Math.max(0, o.start), x = Math.min(_.count, o.start + o.count);
      for (let S = g, T = x - 1; S < T; S += v) {
        const C = _.getX(S), P = _.getX(S + 1);
        if (f.fromBufferAttribute(M, C), h.fromBufferAttribute(M, P), e0.distanceSqToSegment(f, h, m, d) > c)
          continue;
        m.applyMatrix4(this.matrixWorld);
        const N = e.ray.origin.distanceTo(m);
        N < e.near || N > e.far || t.push({
          distance: N,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: d.clone().applyMatrix4(this.matrixWorld),
          index: S,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const g = Math.max(0, o.start), x = Math.min(M.count, o.start + o.count);
      for (let S = g, T = x - 1; S < T; S += v) {
        if (f.fromBufferAttribute(M, S), h.fromBufferAttribute(M, S + 1), e0.distanceSqToSegment(f, h, m, d) > c)
          continue;
        m.applyMatrix4(this.matrixWorld);
        const P = e.ray.origin.distanceTo(m);
        P < e.near || P > e.far || t.push({
          distance: P,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: d.clone().applyMatrix4(this.matrixWorld),
          index: S,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const l = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = s;
        }
      }
    }
  }
}
const IM = /* @__PURE__ */ new D(), NM = /* @__PURE__ */ new D();
class Yr extends fo {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        IM.fromBufferAttribute(t, r), NM.fromBufferAttribute(t, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + IM.distanceTo(NM);
      e.setAttribute("lineDistance", new Ye(i, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class o2 extends fo {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class w_ extends ei {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new ze(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const DM = /* @__PURE__ */ new dt(), jv = /* @__PURE__ */ new ma(), Gh = /* @__PURE__ */ new wr(), Wh = /* @__PURE__ */ new D();
class a2 extends It {
  constructor(e = new wt(), t = new w_()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.matrixWorld, s = e.params.Points.threshold, o = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), Gh.copy(i.boundingSphere), Gh.applyMatrix4(r), Gh.radius += s, e.ray.intersectsSphere(Gh) === !1)
      return;
    DM.copy(r).invert(), jv.copy(e.ray).applyMatrix4(DM);
    const l = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = l * l, f = i.index, d = i.attributes.position;
    if (f !== null) {
      const m = Math.max(0, o.start), v = Math.min(f.count, o.start + o.count);
      for (let _ = m, w = v; _ < w; _++) {
        const M = f.getX(_);
        Wh.fromBufferAttribute(d, M), UM(Wh, M, c, r, e, t, this);
      }
    } else {
      const m = Math.max(0, o.start), v = Math.min(d.count, o.start + o.count);
      for (let _ = m, w = v; _ < w; _++)
        Wh.fromBufferAttribute(d, _), UM(Wh, _, c, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const l = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = s;
        }
      }
    }
  }
}
function UM(n, e, t, i, r, s, o) {
  const l = jv.distanceSqToPoint(n);
  if (l < t) {
    const c = new D();
    jv.closestPointToPoint(n, c), c.applyMatrix4(i);
    const f = r.ray.origin.distanceTo(c);
    if (f < r.near || f > r.far)
      return;
    s.push({
      distance: f,
      distanceToRay: Math.sqrt(l),
      point: c,
      index: e,
      face: null,
      object: o
    });
  }
}
class BU extends mn {
  constructor(e, t, i, r, s, o, l, c, f) {
    super(e, t, i, r, s, o, l, c, f), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : pn, this.magFilter = s !== void 0 ? s : pn, this.generateMipmaps = !1;
    const h = this;
    function d() {
      h.needsUpdate = !0, e.requestVideoFrameCallback(d);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class HU extends mn {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = hn, this.minFilter = hn, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class E_ extends mn {
  constructor(e, t, i, r, s, o, l, c, f, h, d, m) {
    super(null, o, l, c, f, h, r, s, d, m), this.isCompressedTexture = !0, this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class VU extends E_ {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, s, o), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = Jn;
  }
}
class GU extends mn {
  constructor(e, t, i, r, s, o, l, c, f) {
    super(e, t, i, r, s, o, l, c, f), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class Er {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPointAt(i / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i, r = this.getPoint(0), s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      i = this.getPoint(o / e), s += i.distanceTo(r), t.push(s), r = i;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let r = 0;
    const s = i.length;
    let o;
    t ? o = t : o = e * i[s - 1];
    let l = 0, c = s - 1, f;
    for (; l <= c; )
      if (r = Math.floor(l + (c - l) / 2), f = i[r] - o, f < 0)
        l = r + 1;
      else if (f > 0)
        c = r - 1;
      else {
        c = r;
        break;
      }
    if (r = c, i[r] === o)
      return r / (s - 1);
    const h = i[r], m = i[r + 1] - h, v = (o - h) / m;
    return (r + v) / (s - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let r = e - 1e-4, s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const o = this.getPoint(r), l = this.getPoint(s), c = t || (o.isVector2 ? new me() : new D());
    return c.copy(l).sub(o).normalize(), c;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new D(), r = [], s = [], o = [], l = new D(), c = new dt();
    for (let v = 0; v <= e; v++) {
      const _ = v / e;
      r[v] = this.getTangentAt(_, new D());
    }
    s[0] = new D(), o[0] = new D();
    let f = Number.MAX_VALUE;
    const h = Math.abs(r[0].x), d = Math.abs(r[0].y), m = Math.abs(r[0].z);
    h <= f && (f = h, i.set(1, 0, 0)), d <= f && (f = d, i.set(0, 1, 0)), m <= f && i.set(0, 0, 1), l.crossVectors(r[0], i).normalize(), s[0].crossVectors(r[0], l), o[0].crossVectors(r[0], s[0]);
    for (let v = 1; v <= e; v++) {
      if (s[v] = s[v - 1].clone(), o[v] = o[v - 1].clone(), l.crossVectors(r[v - 1], r[v]), l.length() > Number.EPSILON) {
        l.normalize();
        const _ = Math.acos(un(r[v - 1].dot(r[v]), -1, 1));
        s[v].applyMatrix4(c.makeRotationAxis(l, _));
      }
      o[v].crossVectors(r[v], s[v]);
    }
    if (t === !0) {
      let v = Math.acos(un(s[0].dot(s[e]), -1, 1));
      v /= e, r[0].dot(l.crossVectors(s[0], s[e])) > 0 && (v = -v);
      for (let _ = 1; _ <= e; _++)
        s[_].applyMatrix4(c.makeRotationAxis(r[_], v * _)), o[_].crossVectors(r[_], s[_]);
    }
    return {
      tangents: r,
      normals: s,
      binormals: o
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Np extends Er {
  constructor(e = 0, t = 0, i = 1, r = 1, s = 0, o = Math.PI * 2, l = !1, c = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = l, this.aRotation = c;
  }
  getPoint(e, t) {
    const i = t || new me(), r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; )
      s += r;
    for (; s > r; )
      s -= r;
    s < Number.EPSILON && (o ? s = 0 : s = r), this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
    const l = this.aStartAngle + e * s;
    let c = this.aX + this.xRadius * Math.cos(l), f = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), m = c - this.aX, v = f - this.aY;
      c = m * h - v * d + this.aX, f = m * d + v * h + this.aY;
    }
    return i.set(c, f);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class l2 extends Np {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, i, r, s, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function T_() {
  let n = 0, e = 0, t = 0, i = 0;
  function r(s, o, l, c) {
    n = s, e = l, t = -3 * s + 3 * o - 2 * l - c, i = 2 * s - 2 * o + l + c;
  }
  return {
    initCatmullRom: function(s, o, l, c, f) {
      r(o, l, f * (l - s), f * (c - o));
    },
    initNonuniformCatmullRom: function(s, o, l, c, f, h, d) {
      let m = (o - s) / f - (l - s) / (f + h) + (l - o) / h, v = (l - o) / h - (c - o) / (h + d) + (c - l) / d;
      m *= h, v *= h, r(o, l, m, v);
    },
    calc: function(s) {
      const o = s * s, l = o * s;
      return n + e * s + t * o + i * l;
    }
  };
}
const Xh = /* @__PURE__ */ new D(), t0 = /* @__PURE__ */ new T_(), n0 = /* @__PURE__ */ new T_(), i0 = /* @__PURE__ */ new T_();
class u2 extends Er {
  constructor(e = [], t = !1, i = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = r;
  }
  getPoint(e, t = new D()) {
    const i = t, r = this.points, s = r.length, o = (s - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(o), c = o - l;
    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s) + 1) * s : c === 0 && l === s - 1 && (l = s - 2, c = 1);
    let f, h;
    this.closed || l > 0 ? f = r[(l - 1) % s] : (Xh.subVectors(r[0], r[1]).add(r[0]), f = Xh);
    const d = r[l % s], m = r[(l + 1) % s];
    if (this.closed || l + 2 < s ? h = r[(l + 2) % s] : (Xh.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), h = Xh), this.curveType === "centripetal" || this.curveType === "chordal") {
      const v = this.curveType === "chordal" ? 0.5 : 0.25;
      let _ = Math.pow(f.distanceToSquared(d), v), w = Math.pow(d.distanceToSquared(m), v), M = Math.pow(m.distanceToSquared(h), v);
      w < 1e-4 && (w = 1), _ < 1e-4 && (_ = w), M < 1e-4 && (M = w), t0.initNonuniformCatmullRom(f.x, d.x, m.x, h.x, _, w, M), n0.initNonuniformCatmullRom(f.y, d.y, m.y, h.y, _, w, M), i0.initNonuniformCatmullRom(f.z, d.z, m.z, h.z, _, w, M);
    } else
      this.curveType === "catmullrom" && (t0.initCatmullRom(f.x, d.x, m.x, h.x, this.tension), n0.initCatmullRom(f.y, d.y, m.y, h.y, this.tension), i0.initCatmullRom(f.z, d.z, m.z, h.z, this.tension));
    return i.set(
      t0.calc(c),
      n0.calc(c),
      i0.calc(c)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new D().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function OM(n, e, t, i, r) {
  const s = (i - e) * 0.5, o = (r - t) * 0.5, l = n * n, c = n * l;
  return (2 * t - 2 * i + s + o) * c + (-3 * t + 3 * i - 2 * s - o) * l + s * n + t;
}
function WU(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function XU(n, e) {
  return 2 * (1 - n) * n * e;
}
function jU(n, e) {
  return n * n * e;
}
function ic(n, e, t, i) {
  return WU(n, e) + XU(n, t) + jU(n, i);
}
function YU(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function qU(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function ZU(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function KU(n, e) {
  return n * n * n * e;
}
function rc(n, e, t, i, r) {
  return YU(n, e) + qU(n, t) + ZU(n, i) + KU(n, r);
}
class A_ extends Er {
  constructor(e = new me(), t = new me(), i = new me(), r = new me()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r;
  }
  getPoint(e, t = new me()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2, l = this.v3;
    return i.set(
      rc(e, r.x, s.x, o.x, l.x),
      rc(e, r.y, s.y, o.y, l.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class c2 extends Er {
  constructor(e = new D(), t = new D(), i = new D(), r = new D()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r;
  }
  getPoint(e, t = new D()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2, l = this.v3;
    return i.set(
      rc(e, r.x, s.x, o.x, l.x),
      rc(e, r.y, s.y, o.y, l.y),
      rc(e, r.z, s.z, o.z, l.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Dp extends Er {
  constructor(e = new me(), t = new me()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new me()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new me()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class f2 extends Er {
  constructor(e = new D(), t = new D()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new D()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new D()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class C_ extends Er {
  constructor(e = new me(), t = new me(), i = new me()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new me()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2;
    return i.set(
      ic(e, r.x, s.x, o.x),
      ic(e, r.y, s.y, o.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class R_ extends Er {
  constructor(e = new D(), t = new D(), i = new D()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new D()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2;
    return i.set(
      ic(e, r.x, s.x, o.x),
      ic(e, r.y, s.y, o.y),
      ic(e, r.z, s.z, o.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class P_ extends Er {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new me()) {
    const i = t, r = this.points, s = (r.length - 1) * e, o = Math.floor(s), l = s - o, c = r[o === 0 ? o : o - 1], f = r[o], h = r[o > r.length - 2 ? r.length - 1 : o + 1], d = r[o > r.length - 3 ? r.length - 1 : o + 2];
    return i.set(
      OM(l, c.x, f.x, h.x, d.x),
      OM(l, c.y, f.y, h.y, d.y)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new me().fromArray(r));
    }
    return this;
  }
}
var b_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: l2,
  CatmullRomCurve3: u2,
  CubicBezierCurve: A_,
  CubicBezierCurve3: c2,
  EllipseCurve: Np,
  LineCurve: Dp,
  LineCurve3: f2,
  QuadraticBezierCurve: C_,
  QuadraticBezierCurve3: R_,
  SplineCurve: P_
});
class h2 extends Er {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new Dp(t, e));
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const i = e * this.getLength(), r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const o = r[s] - i, l = this.curves[s], c = l.getLength(), f = c === 0 ? 0 : 1 - o / c;
        return l.getPointAt(f, t);
      }
      s++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      t += this.curves[i].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++)
      t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r], l = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, c = o.getPoints(l);
      for (let f = 0; f < c.length; f++) {
        const h = c[f];
        i && i.equals(h) || (t.push(h), i = h);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(new b_[r.type]().fromJSON(r));
    }
    return this;
  }
}
class Ic extends h2 {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new me(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new Dp(this.currentPoint.clone(), new me(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new C_(
      this.currentPoint.clone(),
      new me(e, t),
      new me(i, r)
    );
    return this.curves.push(s), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    const l = new A_(
      this.currentPoint.clone(),
      new me(e, t),
      new me(i, r),
      new me(s, o)
    );
    return this.curves.push(l), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), i = new P_(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, r, s, o) {
    const l = this.currentPoint.x, c = this.currentPoint.y;
    return this.absarc(
      e + l,
      t + c,
      i,
      r,
      s,
      o
    ), this;
  }
  absarc(e, t, i, r, s, o) {
    return this.absellipse(e, t, i, i, r, s, o), this;
  }
  ellipse(e, t, i, r, s, o, l, c) {
    const f = this.currentPoint.x, h = this.currentPoint.y;
    return this.absellipse(e + f, t + h, i, r, s, o, l, c), this;
  }
  absellipse(e, t, i, r, s, o, l, c) {
    const f = new Np(e, t, i, r, s, o, l, c);
    if (this.curves.length > 0) {
      const d = f.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(f);
    const h = f.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Kc extends wt {
  constructor(e = [new me(0, -0.5), new me(0.5, 0), new me(0, 0.5)], t = 12, i = 0, r = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: i,
      phiLength: r
    }, t = Math.floor(t), r = un(r, 0, Math.PI * 2);
    const s = [], o = [], l = [], c = [], f = [], h = 1 / t, d = new D(), m = new me(), v = new D(), _ = new D(), w = new D();
    let M = 0, g = 0;
    for (let x = 0; x <= e.length - 1; x++)
      switch (x) {
        case 0:
          M = e[x + 1].x - e[x].x, g = e[x + 1].y - e[x].y, v.x = g * 1, v.y = -M, v.z = g * 0, w.copy(v), v.normalize(), c.push(v.x, v.y, v.z);
          break;
        case e.length - 1:
          c.push(w.x, w.y, w.z);
          break;
        default:
          M = e[x + 1].x - e[x].x, g = e[x + 1].y - e[x].y, v.x = g * 1, v.y = -M, v.z = g * 0, _.copy(v), v.x += w.x, v.y += w.y, v.z += w.z, v.normalize(), c.push(v.x, v.y, v.z), w.copy(_);
      }
    for (let x = 0; x <= t; x++) {
      const S = i + x * h * r, T = Math.sin(S), C = Math.cos(S);
      for (let P = 0; P <= e.length - 1; P++) {
        d.x = e[P].x * T, d.y = e[P].y, d.z = e[P].x * C, o.push(d.x, d.y, d.z), m.x = x / t, m.y = P / (e.length - 1), l.push(m.x, m.y);
        const L = c[3 * P + 0] * T, N = c[3 * P + 1], R = c[3 * P + 0] * C;
        f.push(L, N, R);
      }
    }
    for (let x = 0; x < t; x++)
      for (let S = 0; S < e.length - 1; S++) {
        const T = S + x * e.length, C = T, P = T + e.length, L = T + e.length + 1, N = T + 1;
        s.push(C, P, N), s.push(L, N, P);
      }
    this.setIndex(s), this.setAttribute("position", new Ye(o, 3)), this.setAttribute("uv", new Ye(l, 2)), this.setAttribute("normal", new Ye(f, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Kc(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Up extends Kc {
  constructor(e = 1, t = 1, i = 4, r = 8) {
    const s = new Ic();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(s.getPoints(i), r), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      height: t,
      capSegments: i,
      radialSegments: r
    };
  }
  static fromJSON(e) {
    return new Up(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Op extends wt {
  constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: i,
      thetaLength: r
    }, t = Math.max(3, t);
    const s = [], o = [], l = [], c = [], f = new D(), h = new me();
    o.push(0, 0, 0), l.push(0, 0, 1), c.push(0.5, 0.5);
    for (let d = 0, m = 3; d <= t; d++, m += 3) {
      const v = i + d / t * r;
      f.x = e * Math.cos(v), f.y = e * Math.sin(v), o.push(f.x, f.y, f.z), l.push(0, 0, 1), h.x = (o[m] / e + 1) / 2, h.y = (o[m + 1] / e + 1) / 2, c.push(h.x, h.y);
    }
    for (let d = 1; d <= t; d++)
      s.push(d, d + 1, 0);
    this.setIndex(s), this.setAttribute("position", new Ye(o, 3)), this.setAttribute("normal", new Ye(l, 3)), this.setAttribute("uv", new Ye(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Op(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Kl extends wt {
  constructor(e = 1, t = 1, i = 1, r = 32, s = 1, o = !1, l = 0, c = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: i,
      radialSegments: r,
      heightSegments: s,
      openEnded: o,
      thetaStart: l,
      thetaLength: c
    };
    const f = this;
    r = Math.floor(r), s = Math.floor(s);
    const h = [], d = [], m = [], v = [];
    let _ = 0;
    const w = [], M = i / 2;
    let g = 0;
    x(), o === !1 && (e > 0 && S(!0), t > 0 && S(!1)), this.setIndex(h), this.setAttribute("position", new Ye(d, 3)), this.setAttribute("normal", new Ye(m, 3)), this.setAttribute("uv", new Ye(v, 2));
    function x() {
      const T = new D(), C = new D();
      let P = 0;
      const L = (t - e) / i;
      for (let N = 0; N <= s; N++) {
        const R = [], b = N / s, G = b * (t - e) + e;
        for (let $ = 0; $ <= r; $++) {
          const Y = $ / r, K = Y * c + l, J = Math.sin(K), oe = Math.cos(K);
          C.x = G * J, C.y = -b * i + M, C.z = G * oe, d.push(C.x, C.y, C.z), T.set(J, L, oe).normalize(), m.push(T.x, T.y, T.z), v.push(Y, 1 - b), R.push(_++);
        }
        w.push(R);
      }
      for (let N = 0; N < r; N++)
        for (let R = 0; R < s; R++) {
          const b = w[R][N], G = w[R + 1][N], $ = w[R + 1][N + 1], Y = w[R][N + 1];
          h.push(b, G, Y), h.push(G, $, Y), P += 6;
        }
      f.addGroup(g, P, 0), g += P;
    }
    function S(T) {
      const C = _, P = new me(), L = new D();
      let N = 0;
      const R = T === !0 ? e : t, b = T === !0 ? 1 : -1;
      for (let $ = 1; $ <= r; $++)
        d.push(0, M * b, 0), m.push(0, b, 0), v.push(0.5, 0.5), _++;
      const G = _;
      for (let $ = 0; $ <= r; $++) {
        const K = $ / r * c + l, J = Math.cos(K), oe = Math.sin(K);
        L.x = R * oe, L.y = M * b, L.z = R * J, d.push(L.x, L.y, L.z), m.push(0, b, 0), P.x = J * 0.5 + 0.5, P.y = oe * 0.5 * b + 0.5, v.push(P.x, P.y), _++;
      }
      for (let $ = 0; $ < r; $++) {
        const Y = C + $, K = G + $;
        T === !0 ? h.push(K, K + 1, Y) : h.push(K + 1, K, Y), N += 3;
      }
      f.addGroup(g, N, T === !0 ? 1 : 2), g += N;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Kl(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class kp extends Kl {
  constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, l = Math.PI * 2) {
    super(0, e, t, i, r, s, o, l), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: i,
      heightSegments: r,
      openEnded: s,
      thetaStart: o,
      thetaLength: l
    };
  }
  static fromJSON(e) {
    return new kp(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class yo extends wt {
  constructor(e = [], t = [], i = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: i,
      detail: r
    };
    const s = [], o = [];
    l(r), f(i), h(), this.setAttribute("position", new Ye(s, 3)), this.setAttribute("normal", new Ye(s.slice(), 3)), this.setAttribute("uv", new Ye(o, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function l(x) {
      const S = new D(), T = new D(), C = new D();
      for (let P = 0; P < t.length; P += 3)
        v(t[P + 0], S), v(t[P + 1], T), v(t[P + 2], C), c(S, T, C, x);
    }
    function c(x, S, T, C) {
      const P = C + 1, L = [];
      for (let N = 0; N <= P; N++) {
        L[N] = [];
        const R = x.clone().lerp(T, N / P), b = S.clone().lerp(T, N / P), G = P - N;
        for (let $ = 0; $ <= G; $++)
          $ === 0 && N === P ? L[N][$] = R : L[N][$] = R.clone().lerp(b, $ / G);
      }
      for (let N = 0; N < P; N++)
        for (let R = 0; R < 2 * (P - N) - 1; R++) {
          const b = Math.floor(R / 2);
          R % 2 === 0 ? (m(L[N][b + 1]), m(L[N + 1][b]), m(L[N][b])) : (m(L[N][b + 1]), m(L[N + 1][b + 1]), m(L[N + 1][b]));
        }
    }
    function f(x) {
      const S = new D();
      for (let T = 0; T < s.length; T += 3)
        S.x = s[T + 0], S.y = s[T + 1], S.z = s[T + 2], S.normalize().multiplyScalar(x), s[T + 0] = S.x, s[T + 1] = S.y, s[T + 2] = S.z;
    }
    function h() {
      const x = new D();
      for (let S = 0; S < s.length; S += 3) {
        x.x = s[S + 0], x.y = s[S + 1], x.z = s[S + 2];
        const T = M(x) / 2 / Math.PI + 0.5, C = g(x) / Math.PI + 0.5;
        o.push(T, 1 - C);
      }
      _(), d();
    }
    function d() {
      for (let x = 0; x < o.length; x += 6) {
        const S = o[x + 0], T = o[x + 2], C = o[x + 4], P = Math.max(S, T, C), L = Math.min(S, T, C);
        P > 0.9 && L < 0.1 && (S < 0.2 && (o[x + 0] += 1), T < 0.2 && (o[x + 2] += 1), C < 0.2 && (o[x + 4] += 1));
      }
    }
    function m(x) {
      s.push(x.x, x.y, x.z);
    }
    function v(x, S) {
      const T = x * 3;
      S.x = e[T + 0], S.y = e[T + 1], S.z = e[T + 2];
    }
    function _() {
      const x = new D(), S = new D(), T = new D(), C = new D(), P = new me(), L = new me(), N = new me();
      for (let R = 0, b = 0; R < s.length; R += 9, b += 6) {
        x.set(s[R + 0], s[R + 1], s[R + 2]), S.set(s[R + 3], s[R + 4], s[R + 5]), T.set(s[R + 6], s[R + 7], s[R + 8]), P.set(o[b + 0], o[b + 1]), L.set(o[b + 2], o[b + 3]), N.set(o[b + 4], o[b + 5]), C.copy(x).add(S).add(T).divideScalar(3);
        const G = M(C);
        w(P, b + 0, x, G), w(L, b + 2, S, G), w(N, b + 4, T, G);
      }
    }
    function w(x, S, T, C) {
      C < 0 && x.x === 1 && (o[S] = x.x - 1), T.x === 0 && T.z === 0 && (o[S] = C / 2 / Math.PI + 0.5);
    }
    function M(x) {
      return Math.atan2(x.z, -x.x);
    }
    function g(x) {
      return Math.atan2(-x.y, Math.sqrt(x.x * x.x + x.z * x.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new yo(e.vertices, e.indices, e.radius, e.details);
  }
}
class Fp extends yo {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, r = 1 / i, s = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -r,
      -i,
      0,
      -r,
      i,
      0,
      r,
      -i,
      0,
      r,
      i,
      // (1/, , 0)
      -r,
      -i,
      0,
      -r,
      i,
      0,
      r,
      -i,
      0,
      r,
      i,
      0,
      // (, 0, 1/)
      -i,
      0,
      -r,
      i,
      0,
      -r,
      -i,
      0,
      r,
      i,
      0,
      r
    ], o = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Fp(e.radius, e.detail);
  }
}
const jh = /* @__PURE__ */ new D(), Yh = /* @__PURE__ */ new D(), r0 = /* @__PURE__ */ new D(), qh = /* @__PURE__ */ new gi();
class d2 extends wt {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const r = Math.pow(10, 4), s = Math.cos(ta * t), o = e.getIndex(), l = e.getAttribute("position"), c = o ? o.count : l.count, f = [0, 0, 0], h = ["a", "b", "c"], d = new Array(3), m = {}, v = [];
      for (let _ = 0; _ < c; _ += 3) {
        o ? (f[0] = o.getX(_), f[1] = o.getX(_ + 1), f[2] = o.getX(_ + 2)) : (f[0] = _, f[1] = _ + 1, f[2] = _ + 2);
        const { a: w, b: M, c: g } = qh;
        if (w.fromBufferAttribute(l, f[0]), M.fromBufferAttribute(l, f[1]), g.fromBufferAttribute(l, f[2]), qh.getNormal(r0), d[0] = `${Math.round(w.x * r)},${Math.round(w.y * r)},${Math.round(w.z * r)}`, d[1] = `${Math.round(M.x * r)},${Math.round(M.y * r)},${Math.round(M.z * r)}`, d[2] = `${Math.round(g.x * r)},${Math.round(g.y * r)},${Math.round(g.z * r)}`, !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
          for (let x = 0; x < 3; x++) {
            const S = (x + 1) % 3, T = d[x], C = d[S], P = qh[h[x]], L = qh[h[S]], N = `${T}_${C}`, R = `${C}_${T}`;
            R in m && m[R] ? (r0.dot(m[R].normal) <= s && (v.push(P.x, P.y, P.z), v.push(L.x, L.y, L.z)), m[R] = null) : N in m || (m[N] = {
              index0: f[x],
              index1: f[S],
              normal: r0.clone()
            });
          }
      }
      for (const _ in m)
        if (m[_]) {
          const { index0: w, index1: M } = m[_];
          jh.fromBufferAttribute(l, w), Yh.fromBufferAttribute(l, M), v.push(jh.x, jh.y, jh.z), v.push(Yh.x, Yh.y, Yh.z);
        }
      this.setAttribute("position", new Ye(v, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class ia extends Ic {
  constructor(e) {
    super(e), this.uuid = Oi(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(new Ic().fromJSON(r));
    }
    return this;
  }
}
const JU = {
  triangulate: function(n, e, t = 2) {
    const i = e && e.length, r = i ? e[0] * t : n.length;
    let s = p2(n, 0, r, t, !0);
    const o = [];
    if (!s || s.next === s.prev)
      return o;
    let l, c, f, h, d, m, v;
    if (i && (s = nO(n, e, s, t)), n.length > 80 * t) {
      l = f = n[0], c = h = n[1];
      for (let _ = t; _ < r; _ += t)
        d = n[_], m = n[_ + 1], d < l && (l = d), m < c && (c = m), d > f && (f = d), m > h && (h = m);
      v = Math.max(f - l, h - c), v = v !== 0 ? 32767 / v : 0;
    }
    return Nc(s, o, t, l, c, v, 0), o;
  }
};
function p2(n, e, t, i, r) {
  let s, o;
  if (r === dO(n, e, t, i) > 0)
    for (s = e; s < t; s += i)
      o = kM(s, n[s], n[s + 1], o);
  else
    for (s = t - i; s >= e; s -= i)
      o = kM(s, n[s], n[s + 1], o);
  return o && zp(o, o.next) && (Uc(o), o = o.next), o;
}
function fa(n, e) {
  if (!n)
    return n;
  e || (e = n);
  let t = n, i;
  do
    if (i = !1, !t.steiner && (zp(t, t.next) || $t(t.prev, t, t.next) === 0)) {
      if (Uc(t), t = e = t.prev, t === t.next)
        break;
      i = !0;
    } else
      t = t.next;
  while (i || t !== e);
  return e;
}
function Nc(n, e, t, i, r, s, o) {
  if (!n)
    return;
  !o && s && aO(n, i, r, s);
  let l = n, c, f;
  for (; n.prev !== n.next; ) {
    if (c = n.prev, f = n.next, s ? $U(n, i, r, s) : QU(n)) {
      e.push(c.i / t | 0), e.push(n.i / t | 0), e.push(f.i / t | 0), Uc(n), n = f.next, l = f.next;
      continue;
    }
    if (n = f, n === l) {
      o ? o === 1 ? (n = eO(fa(n), e, t), Nc(n, e, t, i, r, s, 2)) : o === 2 && tO(n, e, t, i, r, s) : Nc(fa(n), e, t, i, r, s, 1);
      break;
    }
  }
}
function QU(n) {
  const e = n.prev, t = n, i = n.next;
  if ($t(e, t, i) >= 0)
    return !1;
  const r = e.x, s = t.x, o = i.x, l = e.y, c = t.y, f = i.y, h = r < s ? r < o ? r : o : s < o ? s : o, d = l < c ? l < f ? l : f : c < f ? c : f, m = r > s ? r > o ? r : o : s > o ? s : o, v = l > c ? l > f ? l : f : c > f ? c : f;
  let _ = i.next;
  for (; _ !== e; ) {
    if (_.x >= h && _.x <= m && _.y >= d && _.y <= v && wl(r, l, s, c, o, f, _.x, _.y) && $t(_.prev, _, _.next) >= 0)
      return !1;
    _ = _.next;
  }
  return !0;
}
function $U(n, e, t, i) {
  const r = n.prev, s = n, o = n.next;
  if ($t(r, s, o) >= 0)
    return !1;
  const l = r.x, c = s.x, f = o.x, h = r.y, d = s.y, m = o.y, v = l < c ? l < f ? l : f : c < f ? c : f, _ = h < d ? h < m ? h : m : d < m ? d : m, w = l > c ? l > f ? l : f : c > f ? c : f, M = h > d ? h > m ? h : m : d > m ? d : m, g = Yv(v, _, e, t, i), x = Yv(w, M, e, t, i);
  let S = n.prevZ, T = n.nextZ;
  for (; S && S.z >= g && T && T.z <= x; ) {
    if (S.x >= v && S.x <= w && S.y >= _ && S.y <= M && S !== r && S !== o && wl(l, h, c, d, f, m, S.x, S.y) && $t(S.prev, S, S.next) >= 0 || (S = S.prevZ, T.x >= v && T.x <= w && T.y >= _ && T.y <= M && T !== r && T !== o && wl(l, h, c, d, f, m, T.x, T.y) && $t(T.prev, T, T.next) >= 0))
      return !1;
    T = T.nextZ;
  }
  for (; S && S.z >= g; ) {
    if (S.x >= v && S.x <= w && S.y >= _ && S.y <= M && S !== r && S !== o && wl(l, h, c, d, f, m, S.x, S.y) && $t(S.prev, S, S.next) >= 0)
      return !1;
    S = S.prevZ;
  }
  for (; T && T.z <= x; ) {
    if (T.x >= v && T.x <= w && T.y >= _ && T.y <= M && T !== r && T !== o && wl(l, h, c, d, f, m, T.x, T.y) && $t(T.prev, T, T.next) >= 0)
      return !1;
    T = T.nextZ;
  }
  return !0;
}
function eO(n, e, t) {
  let i = n;
  do {
    const r = i.prev, s = i.next.next;
    !zp(r, s) && m2(r, i, i.next, s) && Dc(r, s) && Dc(s, r) && (e.push(r.i / t | 0), e.push(i.i / t | 0), e.push(s.i / t | 0), Uc(i), Uc(i.next), i = n = s), i = i.next;
  } while (i !== n);
  return fa(i);
}
function tO(n, e, t, i, r, s) {
  let o = n;
  do {
    let l = o.next.next;
    for (; l !== o.prev; ) {
      if (o.i !== l.i && cO(o, l)) {
        let c = g2(o, l);
        o = fa(o, o.next), c = fa(c, c.next), Nc(o, e, t, i, r, s, 0), Nc(c, e, t, i, r, s, 0);
        return;
      }
      l = l.next;
    }
    o = o.next;
  } while (o !== n);
}
function nO(n, e, t, i) {
  const r = [];
  let s, o, l, c, f;
  for (s = 0, o = e.length; s < o; s++)
    l = e[s] * i, c = s < o - 1 ? e[s + 1] * i : n.length, f = p2(n, l, c, i, !1), f === f.next && (f.steiner = !0), r.push(uO(f));
  for (r.sort(iO), s = 0; s < r.length; s++)
    t = rO(r[s], t);
  return t;
}
function iO(n, e) {
  return n.x - e.x;
}
function rO(n, e) {
  const t = sO(n, e);
  if (!t)
    return e;
  const i = g2(t, n);
  return fa(i, i.next), fa(t, t.next);
}
function sO(n, e) {
  let t = e, i = -1 / 0, r;
  const s = n.x, o = n.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const m = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (m <= s && m > i && (i = m, r = t.x < t.next.x ? t : t.next, m === s))
        return r;
    }
    t = t.next;
  } while (t !== e);
  if (!r)
    return null;
  const l = r, c = r.x, f = r.y;
  let h = 1 / 0, d;
  t = r;
  do
    s >= t.x && t.x >= c && s !== t.x && wl(o < f ? s : i, o, c, f, o < f ? i : s, o, t.x, t.y) && (d = Math.abs(o - t.y) / (s - t.x), Dc(t, n) && (d < h || d === h && (t.x > r.x || t.x === r.x && oO(r, t))) && (r = t, h = d)), t = t.next;
  while (t !== l);
  return r;
}
function oO(n, e) {
  return $t(n.prev, n, e.prev) < 0 && $t(e.next, n, n.next) < 0;
}
function aO(n, e, t, i) {
  let r = n;
  do
    r.z === 0 && (r.z = Yv(r.x, r.y, e, t, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== n);
  r.prevZ.nextZ = null, r.prevZ = null, lO(r);
}
function lO(n) {
  let e, t, i, r, s, o, l, c, f = 1;
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, i = t, l = 0, e = 0; e < f && (l++, i = i.nextZ, !!i); e++)
        ;
      for (c = f; l > 0 || c > 0 && i; )
        l !== 0 && (c === 0 || !i || t.z <= i.z) ? (r = t, t = t.nextZ, l--) : (r = i, i = i.nextZ, c--), s ? s.nextZ = r : n = r, r.prevZ = s, s = r;
      t = i;
    }
    s.nextZ = null, f *= 2;
  } while (o > 1);
  return n;
}
function Yv(n, e, t, i, r) {
  return n = (n - t) * r | 0, e = (e - i) * r | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1;
}
function uO(n) {
  let e = n, t = n;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== n);
  return t;
}
function wl(n, e, t, i, r, s, o, l) {
  return (r - o) * (e - l) >= (n - o) * (s - l) && (n - o) * (i - l) >= (t - o) * (e - l) && (t - o) * (s - l) >= (r - o) * (i - l);
}
function cO(n, e) {
  return n.next.i !== e.i && n.prev.i !== e.i && !fO(n, e) && // dones't intersect other edges
  (Dc(n, e) && Dc(e, n) && hO(n, e) && // locally visible
  ($t(n.prev, n, e.prev) || $t(n, e.prev, e)) || // does not create opposite-facing sectors
  zp(n, e) && $t(n.prev, n, n.next) > 0 && $t(e.prev, e, e.next) > 0);
}
function $t(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function zp(n, e) {
  return n.x === e.x && n.y === e.y;
}
function m2(n, e, t, i) {
  const r = Kh($t(n, e, t)), s = Kh($t(n, e, i)), o = Kh($t(t, i, n)), l = Kh($t(t, i, e));
  return !!(r !== s && o !== l || r === 0 && Zh(n, t, e) || s === 0 && Zh(n, i, e) || o === 0 && Zh(t, n, i) || l === 0 && Zh(t, e, i));
}
function Zh(n, e, t) {
  return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y);
}
function Kh(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function fO(n, e) {
  let t = n;
  do {
    if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && m2(t, t.next, n, e))
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function Dc(n, e) {
  return $t(n.prev, n, n.next) < 0 ? $t(n, e, n.next) >= 0 && $t(n, n.prev, e) >= 0 : $t(n, e, n.prev) < 0 || $t(n, n.next, e) < 0;
}
function hO(n, e) {
  let t = n, i = !1;
  const r = (n.x + e.x) / 2, s = (n.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
  while (t !== n);
  return i;
}
function g2(n, e) {
  const t = new qv(n.i, n.x, n.y), i = new qv(e.i, e.x, e.y), r = n.next, s = e.prev;
  return n.next = e, e.prev = n, t.next = r, r.prev = t, i.next = t, t.prev = i, s.next = i, i.prev = s, i;
}
function kM(n, e, t, i) {
  const r = new qv(n, e, t);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}
function Uc(n) {
  n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function qv(n, e, t) {
  this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function dO(n, e, t, i) {
  let r = 0;
  for (let s = e, o = t - i; s < t; s += i)
    r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]), o = s;
  return r;
}
class Gr {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      i += e[r].x * e[s].y - e[s].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return Gr.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [], r = [], s = [];
    FM(e), zM(i, e);
    let o = e.length;
    t.forEach(FM);
    for (let c = 0; c < t.length; c++)
      r.push(o), o += t[c].length, zM(i, t[c]);
    const l = JU.triangulate(i, r);
    for (let c = 0; c < l.length; c += 3)
      s.push(l.slice(c, c + 3));
    return s;
  }
}
function FM(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function zM(n, e) {
  for (let t = 0; t < e.length; t++)
    n.push(e[t].x), n.push(e[t].y);
}
class Bp extends wt {
  constructor(e = new ia([new me(0.5, 0.5), new me(-0.5, 0.5), new me(-0.5, -0.5), new me(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const i = this, r = [], s = [];
    for (let l = 0, c = e.length; l < c; l++) {
      const f = e[l];
      o(f);
    }
    this.setAttribute("position", new Ye(r, 3)), this.setAttribute("uv", new Ye(s, 2)), this.computeVertexNormals();
    function o(l) {
      const c = [], f = t.curveSegments !== void 0 ? t.curveSegments : 12, h = t.steps !== void 0 ? t.steps : 1, d = t.depth !== void 0 ? t.depth : 1;
      let m = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, v = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, _ = t.bevelSize !== void 0 ? t.bevelSize : v - 0.1, w = t.bevelOffset !== void 0 ? t.bevelOffset : 0, M = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const g = t.extrudePath, x = t.UVGenerator !== void 0 ? t.UVGenerator : pO;
      let S, T = !1, C, P, L, N;
      g && (S = g.getSpacedPoints(h), T = !0, m = !1, C = g.computeFrenetFrames(h, !1), P = new D(), L = new D(), N = new D()), m || (M = 0, v = 0, _ = 0, w = 0);
      const R = l.extractPoints(f);
      let b = R.shape;
      const G = R.holes;
      if (!Gr.isClockWise(b)) {
        b = b.reverse();
        for (let z = 0, ge = G.length; z < ge; z++) {
          const fe = G[z];
          Gr.isClockWise(fe) && (G[z] = fe.reverse());
        }
      }
      const Y = Gr.triangulateShape(b, G), K = b;
      for (let z = 0, ge = G.length; z < ge; z++) {
        const fe = G[z];
        b = b.concat(fe);
      }
      function J(z, ge, fe) {
        return ge || console.error("THREE.ExtrudeGeometry: vec does not exist"), z.clone().addScaledVector(ge, fe);
      }
      const oe = b.length, ne = Y.length;
      function O(z, ge, fe) {
        let Se, ve, He;
        const Oe = z.x - ge.x, Fe = z.y - ge.y, Je = fe.x - z.x, mt = fe.y - z.y, Ut = Oe * Oe + Fe * Fe, F = Oe * mt - Fe * Je;
        if (Math.abs(F) > Number.EPSILON) {
          const I = Math.sqrt(Ut), ae = Math.sqrt(Je * Je + mt * mt), we = ge.x - Fe / I, _e = ge.y + Oe / I, Pe = fe.x - mt / ae, qe = fe.y + Je / ae, be = ((Pe - we) * mt - (qe - _e) * Je) / (Oe * mt - Fe * Je);
          Se = we + Oe * be - z.x, ve = _e + Fe * be - z.y;
          const ue = Se * Se + ve * ve;
          if (ue <= 2)
            return new me(Se, ve);
          He = Math.sqrt(ue / 2);
        } else {
          let I = !1;
          Oe > Number.EPSILON ? Je > Number.EPSILON && (I = !0) : Oe < -Number.EPSILON ? Je < -Number.EPSILON && (I = !0) : Math.sign(Fe) === Math.sign(mt) && (I = !0), I ? (Se = -Fe, ve = Oe, He = Math.sqrt(Ut)) : (Se = Oe, ve = Fe, He = Math.sqrt(Ut / 2));
        }
        return new me(Se / He, ve / He);
      }
      const X = [];
      for (let z = 0, ge = K.length, fe = ge - 1, Se = z + 1; z < ge; z++, fe++, Se++)
        fe === ge && (fe = 0), Se === ge && (Se = 0), X[z] = O(K[z], K[fe], K[Se]);
      const W = [];
      let V, j = X.concat();
      for (let z = 0, ge = G.length; z < ge; z++) {
        const fe = G[z];
        V = [];
        for (let Se = 0, ve = fe.length, He = ve - 1, Oe = Se + 1; Se < ve; Se++, He++, Oe++)
          He === ve && (He = 0), Oe === ve && (Oe = 0), V[Se] = O(fe[Se], fe[He], fe[Oe]);
        W.push(V), j = j.concat(V);
      }
      for (let z = 0; z < M; z++) {
        const ge = z / M, fe = v * Math.cos(ge * Math.PI / 2), Se = _ * Math.sin(ge * Math.PI / 2) + w;
        for (let ve = 0, He = K.length; ve < He; ve++) {
          const Oe = J(K[ve], X[ve], Se);
          Be(Oe.x, Oe.y, -fe);
        }
        for (let ve = 0, He = G.length; ve < He; ve++) {
          const Oe = G[ve];
          V = W[ve];
          for (let Fe = 0, Je = Oe.length; Fe < Je; Fe++) {
            const mt = J(Oe[Fe], V[Fe], Se);
            Be(mt.x, mt.y, -fe);
          }
        }
      }
      const de = _ + w;
      for (let z = 0; z < oe; z++) {
        const ge = m ? J(b[z], j[z], de) : b[z];
        T ? (L.copy(C.normals[0]).multiplyScalar(ge.x), P.copy(C.binormals[0]).multiplyScalar(ge.y), N.copy(S[0]).add(L).add(P), Be(N.x, N.y, N.z)) : Be(ge.x, ge.y, 0);
      }
      for (let z = 1; z <= h; z++)
        for (let ge = 0; ge < oe; ge++) {
          const fe = m ? J(b[ge], j[ge], de) : b[ge];
          T ? (L.copy(C.normals[z]).multiplyScalar(fe.x), P.copy(C.binormals[z]).multiplyScalar(fe.y), N.copy(S[z]).add(L).add(P), Be(N.x, N.y, N.z)) : Be(fe.x, fe.y, d / h * z);
        }
      for (let z = M - 1; z >= 0; z--) {
        const ge = z / M, fe = v * Math.cos(ge * Math.PI / 2), Se = _ * Math.sin(ge * Math.PI / 2) + w;
        for (let ve = 0, He = K.length; ve < He; ve++) {
          const Oe = J(K[ve], X[ve], Se);
          Be(Oe.x, Oe.y, d + fe);
        }
        for (let ve = 0, He = G.length; ve < He; ve++) {
          const Oe = G[ve];
          V = W[ve];
          for (let Fe = 0, Je = Oe.length; Fe < Je; Fe++) {
            const mt = J(Oe[Fe], V[Fe], Se);
            T ? Be(mt.x, mt.y + S[h - 1].y, S[h - 1].x + fe) : Be(mt.x, mt.y, d + fe);
          }
        }
      }
      ye(), Te();
      function ye() {
        const z = r.length / 3;
        if (m) {
          let ge = 0, fe = oe * ge;
          for (let Se = 0; Se < ne; Se++) {
            const ve = Y[Se];
            je(ve[2] + fe, ve[1] + fe, ve[0] + fe);
          }
          ge = h + M * 2, fe = oe * ge;
          for (let Se = 0; Se < ne; Se++) {
            const ve = Y[Se];
            je(ve[0] + fe, ve[1] + fe, ve[2] + fe);
          }
        } else {
          for (let ge = 0; ge < ne; ge++) {
            const fe = Y[ge];
            je(fe[2], fe[1], fe[0]);
          }
          for (let ge = 0; ge < ne; ge++) {
            const fe = Y[ge];
            je(fe[0] + oe * h, fe[1] + oe * h, fe[2] + oe * h);
          }
        }
        i.addGroup(z, r.length / 3 - z, 0);
      }
      function Te() {
        const z = r.length / 3;
        let ge = 0;
        Ie(K, ge), ge += K.length;
        for (let fe = 0, Se = G.length; fe < Se; fe++) {
          const ve = G[fe];
          Ie(ve, ge), ge += ve.length;
        }
        i.addGroup(z, r.length / 3 - z, 1);
      }
      function Ie(z, ge) {
        let fe = z.length;
        for (; --fe >= 0; ) {
          const Se = fe;
          let ve = fe - 1;
          ve < 0 && (ve = z.length - 1);
          for (let He = 0, Oe = h + M * 2; He < Oe; He++) {
            const Fe = oe * He, Je = oe * (He + 1), mt = ge + Se + Fe, Ut = ge + ve + Fe, F = ge + ve + Je, I = ge + Se + Je;
            vt(mt, Ut, F, I);
          }
        }
      }
      function Be(z, ge, fe) {
        c.push(z), c.push(ge), c.push(fe);
      }
      function je(z, ge, fe) {
        lt(z), lt(ge), lt(fe);
        const Se = r.length / 3, ve = x.generateTopUV(i, r, Se - 3, Se - 2, Se - 1);
        Re(ve[0]), Re(ve[1]), Re(ve[2]);
      }
      function vt(z, ge, fe, Se) {
        lt(z), lt(ge), lt(Se), lt(ge), lt(fe), lt(Se);
        const ve = r.length / 3, He = x.generateSideWallUV(i, r, ve - 6, ve - 3, ve - 2, ve - 1);
        Re(He[0]), Re(He[1]), Re(He[3]), Re(He[1]), Re(He[2]), Re(He[3]);
      }
      function lt(z) {
        r.push(c[z * 3 + 0]), r.push(c[z * 3 + 1]), r.push(c[z * 3 + 2]);
      }
      function Re(z) {
        s.push(z.x), s.push(z.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, i = this.parameters.options;
    return mO(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const l = t[e.shapes[s]];
      i.push(l);
    }
    const r = e.options.extrudePath;
    return r !== void 0 && (e.options.extrudePath = new b_[r.type]().fromJSON(r)), new Bp(i, e.options);
  }
}
const pO = {
  generateTopUV: function(n, e, t, i, r) {
    const s = e[t * 3], o = e[t * 3 + 1], l = e[i * 3], c = e[i * 3 + 1], f = e[r * 3], h = e[r * 3 + 1];
    return [
      new me(s, o),
      new me(l, c),
      new me(f, h)
    ];
  },
  generateSideWallUV: function(n, e, t, i, r, s) {
    const o = e[t * 3], l = e[t * 3 + 1], c = e[t * 3 + 2], f = e[i * 3], h = e[i * 3 + 1], d = e[i * 3 + 2], m = e[r * 3], v = e[r * 3 + 1], _ = e[r * 3 + 2], w = e[s * 3], M = e[s * 3 + 1], g = e[s * 3 + 2];
    return Math.abs(l - h) < Math.abs(o - f) ? [
      new me(o, 1 - c),
      new me(f, 1 - d),
      new me(m, 1 - _),
      new me(w, 1 - g)
    ] : [
      new me(l, 1 - c),
      new me(h, 1 - d),
      new me(v, 1 - _),
      new me(M, 1 - g)
    ];
  }
};
function mO(n, e, t) {
  if (t.shapes = [], Array.isArray(n))
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i];
      t.shapes.push(s.uuid);
    }
  else
    t.shapes.push(n.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class Hp extends yo {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, r = [
      -1,
      i,
      0,
      1,
      i,
      0,
      -1,
      -i,
      0,
      1,
      -i,
      0,
      0,
      -1,
      i,
      0,
      1,
      i,
      0,
      -1,
      -i,
      0,
      1,
      -i,
      i,
      0,
      -1,
      i,
      0,
      1,
      -i,
      0,
      -1,
      -i,
      0,
      1
    ], s = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(r, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Hp(e.radius, e.detail);
  }
}
class Jc extends yo {
  constructor(e = 1, t = 0) {
    const i = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], r = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(i, r, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Jc(e.radius, e.detail);
  }
}
class Vp extends wt {
  constructor(e = 0.5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: i,
      phiSegments: r,
      thetaStart: s,
      thetaLength: o
    }, i = Math.max(3, i), r = Math.max(1, r);
    const l = [], c = [], f = [], h = [];
    let d = e;
    const m = (t - e) / r, v = new D(), _ = new me();
    for (let w = 0; w <= r; w++) {
      for (let M = 0; M <= i; M++) {
        const g = s + M / i * o;
        v.x = d * Math.cos(g), v.y = d * Math.sin(g), c.push(v.x, v.y, v.z), f.push(0, 0, 1), _.x = (v.x / t + 1) / 2, _.y = (v.y / t + 1) / 2, h.push(_.x, _.y);
      }
      d += m;
    }
    for (let w = 0; w < r; w++) {
      const M = w * (i + 1);
      for (let g = 0; g < i; g++) {
        const x = g + M, S = x, T = x + i + 1, C = x + i + 2, P = x + 1;
        l.push(S, T, P), l.push(T, C, P);
      }
    }
    this.setIndex(l), this.setAttribute("position", new Ye(c, 3)), this.setAttribute("normal", new Ye(f, 3)), this.setAttribute("uv", new Ye(h, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Vp(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class Gp extends wt {
  constructor(e = new ia([new me(0, 0.5), new me(-0.5, -0.5), new me(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const i = [], r = [], s = [], o = [];
    let l = 0, c = 0;
    if (Array.isArray(e) === !1)
      f(e);
    else
      for (let h = 0; h < e.length; h++)
        f(e[h]), this.addGroup(l, c, h), l += c, c = 0;
    this.setIndex(i), this.setAttribute("position", new Ye(r, 3)), this.setAttribute("normal", new Ye(s, 3)), this.setAttribute("uv", new Ye(o, 2));
    function f(h) {
      const d = r.length / 3, m = h.extractPoints(t);
      let v = m.shape;
      const _ = m.holes;
      Gr.isClockWise(v) === !1 && (v = v.reverse());
      for (let M = 0, g = _.length; M < g; M++) {
        const x = _[M];
        Gr.isClockWise(x) === !0 && (_[M] = x.reverse());
      }
      const w = Gr.triangulateShape(v, _);
      for (let M = 0, g = _.length; M < g; M++) {
        const x = _[M];
        v = v.concat(x);
      }
      for (let M = 0, g = v.length; M < g; M++) {
        const x = v[M];
        r.push(x.x, x.y, 0), s.push(0, 0, 1), o.push(x.x, x.y);
      }
      for (let M = 0, g = w.length; M < g; M++) {
        const x = w[M], S = x[0] + d, T = x[1] + d, C = x[2] + d;
        i.push(S, T, C), c += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return gO(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const o = t[e.shapes[r]];
      i.push(o);
    }
    return new Gp(i, e.curveSegments);
  }
}
function gO(n, e) {
  if (e.shapes = [], Array.isArray(n))
    for (let t = 0, i = n.length; t < i; t++) {
      const r = n[t];
      e.shapes.push(r.uuid);
    }
  else
    e.shapes.push(n.uuid);
  return e;
}
class Qc extends wt {
  constructor(e = 1, t = 32, i = 16, r = 0, s = Math.PI * 2, o = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: i,
      phiStart: r,
      phiLength: s,
      thetaStart: o,
      thetaLength: l
    }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
    const c = Math.min(o + l, Math.PI);
    let f = 0;
    const h = [], d = new D(), m = new D(), v = [], _ = [], w = [], M = [];
    for (let g = 0; g <= i; g++) {
      const x = [], S = g / i;
      let T = 0;
      g === 0 && o === 0 ? T = 0.5 / t : g === i && c === Math.PI && (T = -0.5 / t);
      for (let C = 0; C <= t; C++) {
        const P = C / t;
        d.x = -e * Math.cos(r + P * s) * Math.sin(o + S * l), d.y = e * Math.cos(o + S * l), d.z = e * Math.sin(r + P * s) * Math.sin(o + S * l), _.push(d.x, d.y, d.z), m.copy(d).normalize(), w.push(m.x, m.y, m.z), M.push(P + T, 1 - S), x.push(f++);
      }
      h.push(x);
    }
    for (let g = 0; g < i; g++)
      for (let x = 0; x < t; x++) {
        const S = h[g][x + 1], T = h[g][x], C = h[g + 1][x], P = h[g + 1][x + 1];
        (g !== 0 || o > 0) && v.push(S, T, P), (g !== i - 1 || c < Math.PI) && v.push(T, C, P);
      }
    this.setIndex(v), this.setAttribute("position", new Ye(_, 3)), this.setAttribute("normal", new Ye(w, 3)), this.setAttribute("uv", new Ye(M, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Qc(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class Wp extends yo {
  constructor(e = 1, t = 0) {
    const i = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], r = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(i, r, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Wp(e.radius, e.detail);
  }
}
class Xp extends wt {
  constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: i,
      tubularSegments: r,
      arc: s
    }, i = Math.floor(i), r = Math.floor(r);
    const o = [], l = [], c = [], f = [], h = new D(), d = new D(), m = new D();
    for (let v = 0; v <= i; v++)
      for (let _ = 0; _ <= r; _++) {
        const w = _ / r * s, M = v / i * Math.PI * 2;
        d.x = (e + t * Math.cos(M)) * Math.cos(w), d.y = (e + t * Math.cos(M)) * Math.sin(w), d.z = t * Math.sin(M), l.push(d.x, d.y, d.z), h.x = e * Math.cos(w), h.y = e * Math.sin(w), m.subVectors(d, h).normalize(), c.push(m.x, m.y, m.z), f.push(_ / r), f.push(v / i);
      }
    for (let v = 1; v <= i; v++)
      for (let _ = 1; _ <= r; _++) {
        const w = (r + 1) * v + _ - 1, M = (r + 1) * (v - 1) + _ - 1, g = (r + 1) * (v - 1) + _, x = (r + 1) * v + _;
        o.push(w, M, x), o.push(M, g, x);
      }
    this.setIndex(o), this.setAttribute("position", new Ye(l, 3)), this.setAttribute("normal", new Ye(c, 3)), this.setAttribute("uv", new Ye(f, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Xp(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class jp extends wt {
  constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, o = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: i,
      radialSegments: r,
      p: s,
      q: o
    }, i = Math.floor(i), r = Math.floor(r);
    const l = [], c = [], f = [], h = [], d = new D(), m = new D(), v = new D(), _ = new D(), w = new D(), M = new D(), g = new D();
    for (let S = 0; S <= i; ++S) {
      const T = S / i * s * Math.PI * 2;
      x(T, s, o, e, v), x(T + 0.01, s, o, e, _), M.subVectors(_, v), g.addVectors(_, v), w.crossVectors(M, g), g.crossVectors(w, M), w.normalize(), g.normalize();
      for (let C = 0; C <= r; ++C) {
        const P = C / r * Math.PI * 2, L = -t * Math.cos(P), N = t * Math.sin(P);
        d.x = v.x + (L * g.x + N * w.x), d.y = v.y + (L * g.y + N * w.y), d.z = v.z + (L * g.z + N * w.z), c.push(d.x, d.y, d.z), m.subVectors(d, v).normalize(), f.push(m.x, m.y, m.z), h.push(S / i), h.push(C / r);
      }
    }
    for (let S = 1; S <= i; S++)
      for (let T = 1; T <= r; T++) {
        const C = (r + 1) * (S - 1) + (T - 1), P = (r + 1) * S + (T - 1), L = (r + 1) * S + T, N = (r + 1) * (S - 1) + T;
        l.push(C, P, N), l.push(P, L, N);
      }
    this.setIndex(l), this.setAttribute("position", new Ye(c, 3)), this.setAttribute("normal", new Ye(f, 3)), this.setAttribute("uv", new Ye(h, 2));
    function x(S, T, C, P, L) {
      const N = Math.cos(S), R = Math.sin(S), b = C / T * S, G = Math.cos(b);
      L.x = P * (2 + G) * 0.5 * N, L.y = P * (2 + G) * R * 0.5, L.z = P * Math.sin(b) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new jp(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class Yp extends wt {
  constructor(e = new R_(new D(-1, -1, 0), new D(-1, 1, 0), new D(1, 1, 0)), t = 64, i = 1, r = 8, s = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: i,
      radialSegments: r,
      closed: s
    };
    const o = e.computeFrenetFrames(t, s);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const l = new D(), c = new D(), f = new me();
    let h = new D();
    const d = [], m = [], v = [], _ = [];
    w(), this.setIndex(_), this.setAttribute("position", new Ye(d, 3)), this.setAttribute("normal", new Ye(m, 3)), this.setAttribute("uv", new Ye(v, 2));
    function w() {
      for (let S = 0; S < t; S++)
        M(S);
      M(s === !1 ? t : 0), x(), g();
    }
    function M(S) {
      h = e.getPointAt(S / t, h);
      const T = o.normals[S], C = o.binormals[S];
      for (let P = 0; P <= r; P++) {
        const L = P / r * Math.PI * 2, N = Math.sin(L), R = -Math.cos(L);
        c.x = R * T.x + N * C.x, c.y = R * T.y + N * C.y, c.z = R * T.z + N * C.z, c.normalize(), m.push(c.x, c.y, c.z), l.x = h.x + i * c.x, l.y = h.y + i * c.y, l.z = h.z + i * c.z, d.push(l.x, l.y, l.z);
      }
    }
    function g() {
      for (let S = 1; S <= t; S++)
        for (let T = 1; T <= r; T++) {
          const C = (r + 1) * (S - 1) + (T - 1), P = (r + 1) * S + (T - 1), L = (r + 1) * S + T, N = (r + 1) * (S - 1) + T;
          _.push(C, P, N), _.push(P, L, N);
        }
    }
    function x() {
      for (let S = 0; S <= t; S++)
        for (let T = 0; T <= r; T++)
          f.x = S / t, f.y = T / r, v.push(f.x, f.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new Yp(
      new b_[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class v2 extends wt {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], i = /* @__PURE__ */ new Set(), r = new D(), s = new D();
      if (e.index !== null) {
        const o = e.attributes.position, l = e.index;
        let c = e.groups;
        c.length === 0 && (c = [{ start: 0, count: l.count, materialIndex: 0 }]);
        for (let f = 0, h = c.length; f < h; ++f) {
          const d = c[f], m = d.start, v = d.count;
          for (let _ = m, w = m + v; _ < w; _ += 3)
            for (let M = 0; M < 3; M++) {
              const g = l.getX(_ + M), x = l.getX(_ + (M + 1) % 3);
              r.fromBufferAttribute(o, g), s.fromBufferAttribute(o, x), BM(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let l = 0, c = o.count / 3; l < c; l++)
          for (let f = 0; f < 3; f++) {
            const h = 3 * l + f, d = 3 * l + (f + 1) % 3;
            r.fromBufferAttribute(o, h), s.fromBufferAttribute(o, d), BM(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new Ye(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function BM(n, e, t) {
  const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0);
}
var HM = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: ga,
  CapsuleGeometry: Up,
  CircleGeometry: Op,
  ConeGeometry: kp,
  CylinderGeometry: Kl,
  DodecahedronGeometry: Fp,
  EdgesGeometry: d2,
  ExtrudeGeometry: Bp,
  IcosahedronGeometry: Hp,
  LatheGeometry: Kc,
  OctahedronGeometry: Jc,
  PlaneGeometry: Zc,
  PolyhedronGeometry: yo,
  RingGeometry: Vp,
  ShapeGeometry: Gp,
  SphereGeometry: Qc,
  TetrahedronGeometry: Wp,
  TorusGeometry: Xp,
  TorusKnotGeometry: jp,
  TubeGeometry: Yp,
  WireframeGeometry: v2
});
class y2 extends ei {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new ze(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class _2 extends Wr {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class L_ extends ei {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new ze(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ze(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = go, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class x2 extends L_ {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new me(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return un(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new ze(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new ze(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ze(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class S2 extends ei {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new ze(16777215), this.specular = new ze(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ze(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = go, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Xc, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class M2 extends ei {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new ze(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ze(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = go, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class w2 extends ei {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = go, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class E2 extends ei {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new ze(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ze(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = go, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Xc, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class T2 extends ei {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new ze(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = go, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class A2 extends ci {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function Ki(n, e, t) {
  return I_(n) ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length)) : n.slice(e, t);
}
function Jo(n, e, t) {
  return !n || // let 'undefined' and 'null' pass
  !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n);
}
function I_(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function C2(n) {
  function e(r, s) {
    return n[r] - n[s];
  }
  const t = n.length, i = new Array(t);
  for (let r = 0; r !== t; ++r)
    i[r] = r;
  return i.sort(e), i;
}
function Zv(n, e, t) {
  const i = n.length, r = new n.constructor(i);
  for (let s = 0, o = 0; o !== i; ++s) {
    const l = t[s] * e;
    for (let c = 0; c !== e; ++c)
      r[o++] = n[l + c];
  }
  return r;
}
function N_(n, e, t, i) {
  let r = 1, s = n[0];
  for (; s !== void 0 && s[i] === void 0; )
    s = n[r++];
  if (s === void 0)
    return;
  let o = s[i];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        o = s[i], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = n[r++];
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        o = s[i], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = n[r++];
      while (s !== void 0);
    else
      do
        o = s[i], o !== void 0 && (e.push(s.time), t.push(o)), s = n[r++];
      while (s !== void 0);
}
function vO(n, e, t, i, r = 30) {
  const s = n.clone();
  s.name = e;
  const o = [];
  for (let c = 0; c < s.tracks.length; ++c) {
    const f = s.tracks[c], h = f.getValueSize(), d = [], m = [];
    for (let v = 0; v < f.times.length; ++v) {
      const _ = f.times[v] * r;
      if (!(_ < t || _ >= i)) {
        d.push(f.times[v]);
        for (let w = 0; w < h; ++w)
          m.push(f.values[v * h + w]);
      }
    }
    d.length !== 0 && (f.times = Jo(d, f.times.constructor), f.values = Jo(m, f.values.constructor), o.push(f));
  }
  s.tracks = o;
  let l = 1 / 0;
  for (let c = 0; c < s.tracks.length; ++c)
    l > s.tracks[c].times[0] && (l = s.tracks[c].times[0]);
  for (let c = 0; c < s.tracks.length; ++c)
    s.tracks[c].shift(-1 * l);
  return s.resetDuration(), s;
}
function yO(n, e = 0, t = n, i = 30) {
  i <= 0 && (i = 30);
  const r = t.tracks.length, s = e / i;
  for (let o = 0; o < r; ++o) {
    const l = t.tracks[o], c = l.ValueTypeName;
    if (c === "bool" || c === "string")
      continue;
    const f = n.tracks.find(function(g) {
      return g.name === l.name && g.ValueTypeName === c;
    });
    if (f === void 0)
      continue;
    let h = 0;
    const d = l.getValueSize();
    l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = d / 3);
    let m = 0;
    const v = f.getValueSize();
    f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (m = v / 3);
    const _ = l.times.length - 1;
    let w;
    if (s <= l.times[0]) {
      const g = h, x = d - h;
      w = Ki(l.values, g, x);
    } else if (s >= l.times[_]) {
      const g = _ * d + h, x = g + d - h;
      w = Ki(l.values, g, x);
    } else {
      const g = l.createInterpolant(), x = h, S = d - h;
      g.evaluate(s), w = Ki(g.resultBuffer, x, S);
    }
    c === "quaternion" && new Qn().fromArray(w).normalize().conjugate().toArray(w);
    const M = f.times.length;
    for (let g = 0; g < M; ++g) {
      const x = g * v + m;
      if (c === "quaternion")
        Qn.multiplyQuaternionsFlat(
          f.values,
          x,
          w,
          0,
          f.values,
          x
        );
      else {
        const S = v - m * 2;
        for (let T = 0; T < S; ++T)
          f.values[x + T] -= w[T];
      }
    }
  }
  return n.blendMode = l_, n;
}
const _O = {
  arraySlice: Ki,
  convertArray: Jo,
  isTypedArray: I_,
  getKeyframeOrder: C2,
  sortedArray: Zv,
  flattenJSON: N_,
  subclip: vO,
  makeClipAdditive: yO
};
class $c {
  constructor(e, t, i, r) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex, r = t[i], s = t[i - 1];
    e: {
      t: {
        let o;
        n: {
          i:
            if (!(e < r)) {
              for (let l = i + 2; ; ) {
                if (r === void 0) {
                  if (e < s)
                    break i;
                  return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
                }
                if (i === l)
                  break;
                if (s = r, r = t[++i], e < r)
                  break t;
              }
              o = t.length;
              break n;
            }
          if (!(e >= s)) {
            const l = t[1];
            e < l && (i = 2, s = l);
            for (let c = i - 2; ; ) {
              if (s === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (i === c)
                break;
              if (r = s, s = t[--i - 1], e >= s)
                break t;
            }
            o = i, i = 0;
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const l = i + o >>> 1;
          e < t[l] ? o = l : i = l + 1;
        }
        if (r = t[i], s = t[i - 1], s === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (r === void 0)
          return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
      }
      this._cachedIndex = i, this.intervalChanged_(i, s, r);
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, s = e * r;
    for (let o = 0; o !== r; ++o)
      t[o] = i[s + o];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class R2 extends $c {
  constructor(e, t, i, r) {
    super(e, t, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: qo,
      endingEnd: qo
    };
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2, o = e + 1, l = r[s], c = r[o];
    if (l === void 0)
      switch (this.getSettings_().endingStart) {
        case Zo:
          s = e, l = 2 * t - i;
          break;
        case Rc:
          s = r.length - 2, l = t + r[s] - r[s + 1];
          break;
        default:
          s = e, l = i;
      }
    if (c === void 0)
      switch (this.getSettings_().endingEnd) {
        case Zo:
          o = e, c = 2 * i - t;
          break;
        case Rc:
          o = 1, c = i + r[1] - r[0];
          break;
        default:
          o = e - 1, c = t;
      }
    const f = (i - t) * 0.5, h = this.valueSize;
    this._weightPrev = f / (t - l), this._weightNext = f / (c - i), this._offsetPrev = s * h, this._offsetNext = o * h;
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, o = this.sampleValues, l = this.valueSize, c = e * l, f = c - l, h = this._offsetPrev, d = this._offsetNext, m = this._weightPrev, v = this._weightNext, _ = (i - t) / (r - t), w = _ * _, M = w * _, g = -m * M + 2 * m * w - m * _, x = (1 + m) * M + (-1.5 - 2 * m) * w + (-0.5 + m) * _ + 1, S = (-1 - v) * M + (1.5 + v) * w + 0.5 * _, T = v * M - v * w;
    for (let C = 0; C !== l; ++C)
      s[C] = g * o[h + C] + x * o[f + C] + S * o[c + C] + T * o[d + C];
    return s;
  }
}
class D_ extends $c {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, o = this.sampleValues, l = this.valueSize, c = e * l, f = c - l, h = (i - t) / (r - t), d = 1 - h;
    for (let m = 0; m !== l; ++m)
      s[m] = o[f + m] * d + o[c + m] * h;
    return s;
  }
}
class P2 extends $c {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Tr {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = Jo(t, this.TimeBufferType), this.values = Jo(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON)
      i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: Jo(e.times, Array),
        values: Jo(e.values, Array)
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return i.type = e.ValueTypeName, i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new P2(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new D_(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new R2(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Ac:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Cc:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Td:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Ac;
      case this.InterpolantFactoryMethodLinear:
        return Cc;
      case this.InterpolantFactoryMethodSmooth:
        return Td;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i)
        t[i] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i)
        t[i] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const i = this.times, r = i.length;
    let s = 0, o = r - 1;
    for (; s !== r && i[s] < e; )
      ++s;
    for (; o !== -1 && i[o] > t; )
      --o;
    if (++o, s !== 0 || o !== r) {
      s >= o && (o = Math.max(o, 1), s = o - 1);
      const l = this.getValueSize();
      this.times = Ki(i, s, o), this.values = Ki(this.values, s * l, o * l);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const i = this.times, r = this.values, s = i.length;
    s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let o = null;
    for (let l = 0; l !== s; l++) {
      const c = i[l];
      if (typeof c == "number" && isNaN(c)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, l, c), e = !1;
        break;
      }
      if (o !== null && o > c) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, l, c, o), e = !1;
        break;
      }
      o = c;
    }
    if (r !== void 0 && I_(r))
      for (let l = 0, c = r.length; l !== c; ++l) {
        const f = r[l];
        if (isNaN(f)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, l, f), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = Ki(this.times), t = Ki(this.values), i = this.getValueSize(), r = this.getInterpolation() === Td, s = e.length - 1;
    let o = 1;
    for (let l = 1; l < s; ++l) {
      let c = !1;
      const f = e[l], h = e[l + 1];
      if (f !== h && (l !== 1 || f !== e[0]))
        if (r)
          c = !0;
        else {
          const d = l * i, m = d - i, v = d + i;
          for (let _ = 0; _ !== i; ++_) {
            const w = t[d + _];
            if (w !== t[m + _] || w !== t[v + _]) {
              c = !0;
              break;
            }
          }
        }
      if (c) {
        if (l !== o) {
          e[o] = e[l];
          const d = l * i, m = o * i;
          for (let v = 0; v !== i; ++v)
            t[m + v] = t[d + v];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let l = s * i, c = o * i, f = 0; f !== i; ++f)
        t[c + f] = t[l + f];
      ++o;
    }
    return o !== e.length ? (this.times = Ki(e, 0, o), this.values = Ki(t, 0, o * i)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = Ki(this.times, 0), t = Ki(this.values, 0), i = this.constructor, r = new i(this.name, e, t);
    return r.createInterpolant = this.createInterpolant, r;
  }
}
Tr.prototype.TimeBufferType = Float32Array;
Tr.prototype.ValueBufferType = Float32Array;
Tr.prototype.DefaultInterpolation = Cc;
class va extends Tr {
}
va.prototype.ValueTypeName = "bool";
va.prototype.ValueBufferType = Array;
va.prototype.DefaultInterpolation = Ac;
va.prototype.InterpolantFactoryMethodLinear = void 0;
va.prototype.InterpolantFactoryMethodSmooth = void 0;
class U_ extends Tr {
}
U_.prototype.ValueTypeName = "color";
class Oc extends Tr {
}
Oc.prototype.ValueTypeName = "number";
class b2 extends $c {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, o = this.sampleValues, l = this.valueSize, c = (i - t) / (r - t);
    let f = e * l;
    for (let h = f + l; f !== h; f += 4)
      Qn.slerpFlat(s, 0, o, f - l, o, f, c);
    return s;
  }
}
class Jl extends Tr {
  InterpolantFactoryMethodLinear(e) {
    return new b2(this.times, this.values, this.getValueSize(), e);
  }
}
Jl.prototype.ValueTypeName = "quaternion";
Jl.prototype.DefaultInterpolation = Cc;
Jl.prototype.InterpolantFactoryMethodSmooth = void 0;
class ya extends Tr {
}
ya.prototype.ValueTypeName = "string";
ya.prototype.ValueBufferType = Array;
ya.prototype.DefaultInterpolation = Ac;
ya.prototype.InterpolantFactoryMethodLinear = void 0;
ya.prototype.InterpolantFactoryMethodSmooth = void 0;
class kc extends Tr {
}
kc.prototype.ValueTypeName = "vector";
class Fc {
  constructor(e, t = -1, i, r = Tp) {
    this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = Oi(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], i = e.tracks, r = 1 / (e.fps || 1);
    for (let o = 0, l = i.length; o !== l; ++o)
      t.push(SO(i[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return s.uuid = e.uuid, s;
  }
  static toJSON(e) {
    const t = [], i = e.tracks, r = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let s = 0, o = i.length; s !== o; ++s)
      t.push(Tr.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length, o = [];
    for (let l = 0; l < s; l++) {
      let c = [], f = [];
      c.push(
        (l + s - 1) % s,
        l,
        (l + 1) % s
      ), f.push(0, 1, 0);
      const h = C2(c);
      c = Zv(c, 1, h), f = Zv(f, 1, h), !r && c[0] === 0 && (c.push(s), f.push(f[0])), o.push(
        new Oc(
          ".morphTargetInfluences[" + t[l].name + "]",
          c,
          f
        ).scale(1 / i)
      );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < i.length; r++)
      if (i[r].name === t)
        return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let l = 0, c = e.length; l < c; l++) {
      const f = e[l], h = f.name.match(s);
      if (h && h.length > 1) {
        const d = h[1];
        let m = r[d];
        m || (r[d] = m = []), m.push(f);
      }
    }
    const o = [];
    for (const l in r)
      o.push(this.CreateFromMorphTargetSequence(l, r[l], t, i));
    return o;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const i = function(d, m, v, _, w) {
      if (v.length !== 0) {
        const M = [], g = [];
        N_(v, M, g, _), M.length !== 0 && w.push(new d(m, M, g));
      }
    }, r = [], s = e.name || "default", o = e.fps || 30, l = e.blendMode;
    let c = e.length || -1;
    const f = e.hierarchy || [];
    for (let d = 0; d < f.length; d++) {
      const m = f[d].keys;
      if (!(!m || m.length === 0))
        if (m[0].morphTargets) {
          const v = {};
          let _;
          for (_ = 0; _ < m.length; _++)
            if (m[_].morphTargets)
              for (let w = 0; w < m[_].morphTargets.length; w++)
                v[m[_].morphTargets[w]] = -1;
          for (const w in v) {
            const M = [], g = [];
            for (let x = 0; x !== m[_].morphTargets.length; ++x) {
              const S = m[_];
              M.push(S.time), g.push(S.morphTarget === w ? 1 : 0);
            }
            r.push(new Oc(".morphTargetInfluence[" + w + "]", M, g));
          }
          c = v.length * o;
        } else {
          const v = ".bones[" + t[d].name + "]";
          i(
            kc,
            v + ".position",
            m,
            "pos",
            r
          ), i(
            Jl,
            v + ".quaternion",
            m,
            "rot",
            r
          ), i(
            kc,
            v + ".scale",
            m,
            "scl",
            r
          );
        }
    }
    return r.length === 0 ? null : new this(s, c, r, l);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function xO(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Oc;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return kc;
    case "color":
      return U_;
    case "quaternion":
      return Jl;
    case "bool":
    case "boolean":
      return va;
    case "string":
      return ya;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function SO(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = xO(n.type);
  if (n.times === void 0) {
    const t = [], i = [];
    N_(n.keys, t, i, "value"), n.times = t, n.values = i;
  }
  return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation);
}
const ha = {
  enabled: !1,
  files: {},
  add: function(n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function(n) {
    if (this.enabled !== !1)
      return this.files[n];
  },
  remove: function(n) {
    delete this.files[n];
  },
  clear: function() {
    this.files = {};
  }
};
class O_ {
  constructor(e, t, i) {
    const r = this;
    let s = !1, o = 0, l = 0, c;
    const f = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(h) {
      l++, s === !1 && r.onStart !== void 0 && r.onStart(h, o, l), s = !0;
    }, this.itemEnd = function(h) {
      o++, r.onProgress !== void 0 && r.onProgress(h, o, l), o === l && (s = !1, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(h) {
      r.onError !== void 0 && r.onError(h);
    }, this.resolveURL = function(h) {
      return c ? c(h) : h;
    }, this.setURLModifier = function(h) {
      return c = h, this;
    }, this.addHandler = function(h, d) {
      return f.push(h, d), this;
    }, this.removeHandler = function(h) {
      const d = f.indexOf(h);
      return d !== -1 && f.splice(d, 2), this;
    }, this.getHandler = function(h) {
      for (let d = 0, m = f.length; d < m; d += 2) {
        const v = f[d], _ = f[d + 1];
        if (v.global && (v.lastIndex = 0), v.test(h))
          return _;
      }
      return null;
    };
  }
}
const L2 = /* @__PURE__ */ new O_();
class Mi {
  constructor(e) {
    this.manager = e !== void 0 ? e : L2, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const i = this;
    return new Promise(function(r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
Mi.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const os = {};
class MO extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class ws extends Mi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = ha.get(e);
    if (s !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(s), this.manager.itemEnd(e);
      }, 0), s;
    if (os[e] !== void 0) {
      os[e].push({
        onLoad: t,
        onProgress: i,
        onError: r
      });
      return;
    }
    os[e] = [], os[e].push({
      onLoad: t,
      onProgress: i,
      onError: r
    });
    const o = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), l = this.mimeType, c = this.responseType;
    fetch(o).then((f) => {
      if (f.status === 200 || f.status === 0) {
        if (f.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || f.body === void 0 || f.body.getReader === void 0)
          return f;
        const h = os[e], d = f.body.getReader(), m = f.headers.get("Content-Length") || f.headers.get("X-File-Size"), v = m ? parseInt(m) : 0, _ = v !== 0;
        let w = 0;
        const M = new ReadableStream({
          start(g) {
            x();
            function x() {
              d.read().then(({ done: S, value: T }) => {
                if (S)
                  g.close();
                else {
                  w += T.byteLength;
                  const C = new ProgressEvent("progress", { lengthComputable: _, loaded: w, total: v });
                  for (let P = 0, L = h.length; P < L; P++) {
                    const N = h[P];
                    N.onProgress && N.onProgress(C);
                  }
                  g.enqueue(T), x();
                }
              });
            }
          }
        });
        return new Response(M);
      } else
        throw new MO(`fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`, f);
    }).then((f) => {
      switch (c) {
        case "arraybuffer":
          return f.arrayBuffer();
        case "blob":
          return f.blob();
        case "document":
          return f.text().then((h) => new DOMParser().parseFromString(h, l));
        case "json":
          return f.json();
        default:
          if (l === void 0)
            return f.text();
          {
            const d = /charset="?([^;"\s]*)"?/i.exec(l), m = d && d[1] ? d[1].toLowerCase() : void 0, v = new TextDecoder(m);
            return f.arrayBuffer().then((_) => v.decode(_));
          }
      }
    }).then((f) => {
      ha.add(e, f);
      const h = os[e];
      delete os[e];
      for (let d = 0, m = h.length; d < m; d++) {
        const v = h[d];
        v.onLoad && v.onLoad(f);
      }
    }).catch((f) => {
      const h = os[e];
      if (h === void 0)
        throw this.manager.itemError(e), f;
      delete os[e];
      for (let d = 0, m = h.length; d < m; d++) {
        const v = h[d];
        v.onError && v.onError(f);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class wO extends Mi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new ws(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
      try {
        t(s.parse(JSON.parse(l)));
      } catch (c) {
        r ? r(c) : console.error(c), s.manager.itemError(e);
      }
    }, i, r);
  }
  parse(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const r = Fc.parse(e[i]);
      t.push(r);
    }
    return t;
  }
}
class EO extends Mi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = [], l = new E_(), c = new ws(this.manager);
    c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(s.withCredentials);
    let f = 0;
    function h(d) {
      c.load(e[d], function(m) {
        const v = s.parse(m, !0);
        o[d] = {
          width: v.width,
          height: v.height,
          format: v.format,
          mipmaps: v.mipmaps
        }, f += 1, f === 6 && (v.mipmapCount === 1 && (l.minFilter = pn), l.image = o, l.format = v.format, l.needsUpdate = !0, t && t(l));
      }, i, r);
    }
    if (Array.isArray(e))
      for (let d = 0, m = e.length; d < m; ++d)
        h(d);
    else
      c.load(e, function(d) {
        const m = s.parse(d, !0);
        if (m.isCubemap) {
          const v = m.mipmaps.length / m.mipmapCount;
          for (let _ = 0; _ < v; _++) {
            o[_] = { mipmaps: [] };
            for (let w = 0; w < m.mipmapCount; w++)
              o[_].mipmaps.push(m.mipmaps[_ * m.mipmapCount + w]), o[_].format = m.format, o[_].width = m.width, o[_].height = m.height;
          }
          l.image = o;
        } else
          l.image.width = m.width, l.image.height = m.height, l.mipmaps = m.mipmaps;
        m.mipmapCount === 1 && (l.minFilter = pn), l.format = m.format, l.needsUpdate = !0, t && t(l);
      }, i, r);
    return l;
  }
}
class zc extends Mi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, o = ha.get(e);
    if (o !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(o), s.manager.itemEnd(e);
      }, 0), o;
    const l = Lc("img");
    function c() {
      h(), ha.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function f(d) {
      h(), r && r(d), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function h() {
      l.removeEventListener("load", c, !1), l.removeEventListener("error", f, !1);
    }
    return l.addEventListener("load", c, !1), l.addEventListener("error", f, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin), s.manager.itemStart(e), l.src = e, l;
  }
}
class TO extends Mi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new qc();
    s.colorSpace = pt;
    const o = new zc(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let l = 0;
    function c(f) {
      o.load(e[f], function(h) {
        s.images[f] = h, l++, l === 6 && (s.needsUpdate = !0, t && t(s));
      }, void 0, r);
    }
    for (let f = 0; f < e.length; ++f)
      c(f);
    return s;
  }
}
class AO extends Mi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new Il(), l = new ws(this.manager);
    return l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setPath(this.path), l.setWithCredentials(s.withCredentials), l.load(e, function(c) {
      const f = s.parse(c);
      f && (f.image !== void 0 ? o.image = f.image : f.data !== void 0 && (o.image.width = f.width, o.image.height = f.height, o.image.data = f.data), o.wrapS = f.wrapS !== void 0 ? f.wrapS : Jn, o.wrapT = f.wrapT !== void 0 ? f.wrapT : Jn, o.magFilter = f.magFilter !== void 0 ? f.magFilter : pn, o.minFilter = f.minFilter !== void 0 ? f.minFilter : pn, o.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1, f.colorSpace !== void 0 ? o.colorSpace = f.colorSpace : f.encoding !== void 0 && (o.encoding = f.encoding), f.flipY !== void 0 && (o.flipY = f.flipY), f.format !== void 0 && (o.format = f.format), f.type !== void 0 && (o.type = f.type), f.mipmaps !== void 0 && (o.mipmaps = f.mipmaps, o.minFilter = co), f.mipmapCount === 1 && (o.minFilter = pn), f.generateMipmaps !== void 0 && (o.generateMipmaps = f.generateMipmaps), o.needsUpdate = !0, t && t(o, f));
    }, i, r), o;
  }
}
class CO extends Mi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new mn(), o = new zc(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(l) {
      s.image = l, s.needsUpdate = !0, t !== void 0 && t(s);
    }, i, r), s;
  }
}
class _o extends It {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new ze(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class I2 extends _o {
  constructor(e, t, i) {
    super(e, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(It.DEFAULT_UP), this.updateMatrix(), this.groundColor = new ze(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const s0 = /* @__PURE__ */ new dt(), VM = /* @__PURE__ */ new D(), GM = /* @__PURE__ */ new D();
class k_ {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new me(512, 512), this.map = null, this.mapPass = null, this.matrix = new dt(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Cp(), this._frameExtents = new me(1, 1), this._viewportCount = 1, this._viewports = [
      new kt(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, i = this.matrix;
    VM.setFromMatrixPosition(e.matrixWorld), t.position.copy(VM), GM.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(GM), t.updateMatrixWorld(), s0.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(s0), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(s0);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class RO extends k_ {
  constructor() {
    super(new Qt(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, i = Hl * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
    (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class N2 extends _o {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(It.DEFAULT_UP), this.updateMatrix(), this.target = new It(), this.distance = i, this.angle = r, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new RO();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const WM = /* @__PURE__ */ new dt(), Uu = /* @__PURE__ */ new D(), o0 = /* @__PURE__ */ new D();
class PO extends k_ {
  constructor() {
    super(new Qt(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new me(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new kt(2, 1, 1, 1),
      // negative X
      new kt(0, 1, 1, 1),
      // positive Z
      new kt(3, 1, 1, 1),
      // negative Z
      new kt(1, 1, 1, 1),
      // positive Y
      new kt(3, 0, 1, 1),
      // negative Y
      new kt(1, 0, 1, 1)
    ], this._cubeDirections = [
      new D(1, 0, 0),
      new D(-1, 0, 0),
      new D(0, 0, 1),
      new D(0, 0, -1),
      new D(0, 1, 0),
      new D(0, -1, 0)
    ], this._cubeUps = [
      new D(0, 1, 0),
      new D(0, 1, 0),
      new D(0, 1, 0),
      new D(0, 1, 0),
      new D(0, 0, 1),
      new D(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const i = this.camera, r = this.matrix, s = e.distance || i.far;
    s !== i.far && (i.far = s, i.updateProjectionMatrix()), Uu.setFromMatrixPosition(e.matrixWorld), i.position.copy(Uu), o0.copy(i.position), o0.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(o0), i.updateMatrixWorld(), r.makeTranslation(-Uu.x, -Uu.y, -Uu.z), WM.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(WM);
  }
}
class D2 extends _o {
  constructor(e, t, i = 0, r = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new PO();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class bO extends k_ {
  constructor() {
    super(new Vr(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class U2 extends _o {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(It.DEFAULT_UP), this.updateMatrix(), this.target = new It(), this.shadow = new bO();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class O2 extends _o {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class k2 extends _o {
  constructor(e, t, i = 10, r = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = r;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class F2 {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new D());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const i = e.x, r = e.y, s = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.282095), t.addScaledVector(o[1], 0.488603 * r), t.addScaledVector(o[2], 0.488603 * s), t.addScaledVector(o[3], 0.488603 * i), t.addScaledVector(o[4], 1.092548 * (i * r)), t.addScaledVector(o[5], 1.092548 * (r * s)), t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)), t.addScaledVector(o[7], 1.092548 * (i * s)), t.addScaledVector(o[8], 0.546274 * (i * i - r * r)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const i = e.x, r = e.y, s = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.886227), t.addScaledVector(o[1], 2 * 0.511664 * r), t.addScaledVector(o[2], 2 * 0.511664 * s), t.addScaledVector(o[3], 2 * 0.511664 * i), t.addScaledVector(o[4], 2 * 0.429043 * i * r), t.addScaledVector(o[5], 2 * 0.429043 * r * s), t.addScaledVector(o[6], 0.743125 * s * s - 0.247708), t.addScaledVector(o[7], 2 * 0.429043 * i * s), t.addScaledVector(o[8], 0.429043 * (i * i - r * r)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++)
      i[r].fromArray(e, t + r * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++)
      i[r].toArray(e, t + r * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const i = e.x, r = e.y, s = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * r, t[2] = 0.488603 * s, t[3] = 0.488603 * i, t[4] = 1.092548 * i * r, t[5] = 1.092548 * r * s, t[6] = 0.315392 * (3 * s * s - 1), t[7] = 1.092548 * i * s, t[8] = 0.546274 * (i * i - r * r);
  }
}
class qp extends _o {
  constructor(e = new F2(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class Zp extends Mi {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, i, r) {
    const s = this, o = new ws(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(l) {
      try {
        t(s.parse(JSON.parse(l)));
      } catch (c) {
        r ? r(c) : console.error(c), s.manager.itemError(e);
      }
    }, i, r);
  }
  parse(e) {
    const t = this.textures;
    function i(s) {
      return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s];
    }
    const r = Zp.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new ze().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== 1 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const s in e.uniforms) {
        const o = e.uniforms[s];
        switch (r.uniforms[s] = {}, o.type) {
          case "t":
            r.uniforms[s].value = i(o.value);
            break;
          case "c":
            r.uniforms[s].value = new ze().setHex(o.value);
            break;
          case "v2":
            r.uniforms[s].value = new me().fromArray(o.value);
            break;
          case "v3":
            r.uniforms[s].value = new D().fromArray(o.value);
            break;
          case "v4":
            r.uniforms[s].value = new kt().fromArray(o.value);
            break;
          case "m3":
            r.uniforms[s].value = new _t().fromArray(o.value);
            break;
          case "m4":
            r.uniforms[s].value = new dt().fromArray(o.value);
            break;
          default:
            r.uniforms[s].value = o.value;
        }
      }
    if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const s in e.extensions)
        r.extensions[s] = e.extensions[s];
    if (e.lights !== void 0 && (r.lights = e.lights), e.clipping !== void 0 && (r.clipping = e.clipping), e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = i(e.map)), e.matcap !== void 0 && (r.matcap = i(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]), r.normalScale = new me().fromArray(s);
    }
    return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = i(e.envMap)), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new me().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)), e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)), r;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: y2,
      SpriteMaterial: S_,
      RawShaderMaterial: _2,
      ShaderMaterial: Wr,
      PointsMaterial: w_,
      MeshPhysicalMaterial: x2,
      MeshStandardMaterial: L_,
      MeshPhongMaterial: S2,
      MeshToonMaterial: M2,
      MeshNormalMaterial: w2,
      MeshLambertMaterial: E2,
      MeshDepthMaterial: v_,
      MeshDistanceMaterial: y_,
      MeshBasicMaterial: vo,
      MeshMatcapMaterial: T2,
      LineDashedMaterial: A2,
      LineBasicMaterial: ci,
      Material: ei
    };
    return new t[e]();
  }
}
class Kv {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++)
      t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class z2 extends wt {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class B2 extends Mi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new ws(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(l) {
      try {
        t(s.parse(JSON.parse(l)));
      } catch (c) {
        r ? r(c) : console.error(c), s.manager.itemError(e);
      }
    }, i, r);
  }
  parse(e) {
    const t = {}, i = {};
    function r(v, _) {
      if (t[_] !== void 0)
        return t[_];
      const M = v.interleavedBuffers[_], g = s(v, M.buffer), x = xl(M.type, g), S = new Lp(x, M.stride);
      return S.uuid = M.uuid, t[_] = S, S;
    }
    function s(v, _) {
      if (i[_] !== void 0)
        return i[_];
      const M = v.arrayBuffers[_], g = new Uint32Array(M).buffer;
      return i[_] = g, g;
    }
    const o = e.isInstancedBufferGeometry ? new z2() : new wt(), l = e.data.index;
    if (l !== void 0) {
      const v = xl(l.type, l.array);
      o.setIndex(new Ht(v, 1));
    }
    const c = e.data.attributes;
    for (const v in c) {
      const _ = c[v];
      let w;
      if (_.isInterleavedBufferAttribute) {
        const M = r(e.data, _.data);
        w = new ca(M, _.itemSize, _.offset, _.normalized);
      } else {
        const M = xl(_.type, _.array), g = _.isInstancedBufferAttribute ? Gl : Ht;
        w = new g(M, _.itemSize, _.normalized);
      }
      _.name !== void 0 && (w.name = _.name), _.usage !== void 0 && w.setUsage(_.usage), _.updateRange !== void 0 && (w.updateRange.offset = _.updateRange.offset, w.updateRange.count = _.updateRange.count), o.setAttribute(v, w);
    }
    const f = e.data.morphAttributes;
    if (f)
      for (const v in f) {
        const _ = f[v], w = [];
        for (let M = 0, g = _.length; M < g; M++) {
          const x = _[M];
          let S;
          if (x.isInterleavedBufferAttribute) {
            const T = r(e.data, x.data);
            S = new ca(T, x.itemSize, x.offset, x.normalized);
          } else {
            const T = xl(x.type, x.array);
            S = new Ht(T, x.itemSize, x.normalized);
          }
          x.name !== void 0 && (S.name = x.name), w.push(S);
        }
        o.morphAttributes[v] = w;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const d = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (d !== void 0)
      for (let v = 0, _ = d.length; v !== _; ++v) {
        const w = d[v];
        o.addGroup(w.start, w.count, w.materialIndex);
      }
    const m = e.data.boundingSphere;
    if (m !== void 0) {
      const v = new D();
      m.center !== void 0 && v.fromArray(m.center), o.boundingSphere = new wr(v, m.radius);
    }
    return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o;
  }
}
class LO extends Mi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = this.path === "" ? Kv.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const l = new ws(this.manager);
    l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
      let f = null;
      try {
        f = JSON.parse(c);
      } catch (d) {
        r !== void 0 && r(d), console.error("THREE:ObjectLoader: Can't parse " + e + ".", d.message);
        return;
      }
      const h = f.metadata;
      if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
        r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      s.parse(f, t);
    }, i, r);
  }
  async loadAsync(e, t) {
    const i = this, r = this.path === "" ? Kv.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new ws(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
    const o = await s.loadAsync(e, t), l = JSON.parse(o), c = l.metadata;
    if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(l);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, r), o = this.parseImages(e.images, function() {
      t !== void 0 && t(f);
    }), l = this.parseTextures(e.textures, o), c = this.parseMaterials(e.materials, l), f = this.parseObject(e.object, s, c, l, i), h = this.parseSkeletons(e.skeletons, f);
    if (this.bindSkeletons(f, h), t !== void 0) {
      let d = !1;
      for (const m in o)
        if (o[m].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && t(f);
    }
    return f;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, i), s = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, s), l = this.parseMaterials(e.materials, o), c = this.parseObject(e.object, r, l, o, t), f = this.parseSkeletons(e.skeletons, c);
    return this.bindSkeletons(c, f), c;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0, r = e.length; i < r; i++) {
        const s = new ia().fromJSON(e[i]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {}, r = {};
    if (t.traverse(function(s) {
      s.isBone && (r[s.uuid] = s);
    }), e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const l = new Ip().fromJSON(e[s], r);
        i[l.uuid] = l;
      }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const r = new B2();
      for (let s = 0, o = e.length; s < o; s++) {
        let l;
        const c = e[s];
        switch (c.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            l = r.parse(c);
            break;
          default:
            c.type in HM ? l = HM[c.type].fromJSON(c, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${c.type}"`);
        }
        l.uuid = c.uuid, c.name !== void 0 && (l.name = c.name), c.userData !== void 0 && (l.userData = c.userData), i[c.uuid] = l;
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {}, r = {};
    if (e !== void 0) {
      const s = new Zp();
      s.setTextures(t);
      for (let o = 0, l = e.length; o < l; o++) {
        const c = e[o];
        i[c.uuid] === void 0 && (i[c.uuid] = s.parse(c)), r[c.uuid] = i[c.uuid];
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const r = e[i], s = Fc.parse(r);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const i = this, r = {};
    let s;
    function o(c) {
      return i.manager.itemStart(c), s.load(c, function() {
        i.manager.itemEnd(c);
      }, void 0, function() {
        i.manager.itemError(c), i.manager.itemEnd(c);
      });
    }
    function l(c) {
      if (typeof c == "string") {
        const f = c, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : i.resourcePath + f;
        return o(h);
      } else
        return c.data ? {
          data: xl(c.type, c.data),
          width: c.width,
          height: c.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const c = new O_(t);
      s = new zc(c), s.setCrossOrigin(this.crossOrigin);
      for (let f = 0, h = e.length; f < h; f++) {
        const d = e[f], m = d.url;
        if (Array.isArray(m)) {
          const v = [];
          for (let _ = 0, w = m.length; _ < w; _++) {
            const M = m[_], g = l(M);
            g !== null && (g instanceof HTMLImageElement ? v.push(g) : v.push(new Il(g.data, g.width, g.height)));
          }
          r[d.uuid] = new Ko(v);
        } else {
          const v = l(d.url);
          r[d.uuid] = new Ko(v);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this, i = {};
    let r;
    async function s(o) {
      if (typeof o == "string") {
        const l = o, c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l) ? l : t.resourcePath + l;
        return await r.loadAsync(c);
      } else
        return o.data ? {
          data: xl(o.type, o.data),
          width: o.width,
          height: o.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      r = new zc(this.manager), r.setCrossOrigin(this.crossOrigin);
      for (let o = 0, l = e.length; o < l; o++) {
        const c = e[o], f = c.url;
        if (Array.isArray(f)) {
          const h = [];
          for (let d = 0, m = f.length; d < m; d++) {
            const v = f[d], _ = await s(v);
            _ !== null && (_ instanceof HTMLImageElement ? h.push(_) : h.push(new Il(_.data, _.width, _.height)));
          }
          i[c.uuid] = new Ko(h);
        } else {
          const h = await s(c.url);
          i[c.uuid] = new Ko(h);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(s, o) {
      return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), o[s]);
    }
    const r = {};
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const l = e[s];
        l.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', l.uuid), t[l.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", l.image);
        const c = t[l.image], f = c.data;
        let h;
        Array.isArray(f) ? (h = new qc(), f.length === 6 && (h.needsUpdate = !0)) : (f && f.data ? h = new Il() : h = new mn(), f && (h.needsUpdate = !0)), h.source = c, h.uuid = l.uuid, l.name !== void 0 && (h.name = l.name), l.mapping !== void 0 && (h.mapping = i(l.mapping, IO)), l.channel !== void 0 && (h.channel = l.channel), l.offset !== void 0 && h.offset.fromArray(l.offset), l.repeat !== void 0 && h.repeat.fromArray(l.repeat), l.center !== void 0 && h.center.fromArray(l.center), l.rotation !== void 0 && (h.rotation = l.rotation), l.wrap !== void 0 && (h.wrapS = i(l.wrap[0], XM), h.wrapT = i(l.wrap[1], XM)), l.format !== void 0 && (h.format = l.format), l.internalFormat !== void 0 && (h.internalFormat = l.internalFormat), l.type !== void 0 && (h.type = l.type), l.colorSpace !== void 0 && (h.colorSpace = l.colorSpace), l.encoding !== void 0 && (h.encoding = l.encoding), l.minFilter !== void 0 && (h.minFilter = i(l.minFilter, jM)), l.magFilter !== void 0 && (h.magFilter = i(l.magFilter, jM)), l.anisotropy !== void 0 && (h.anisotropy = l.anisotropy), l.flipY !== void 0 && (h.flipY = l.flipY), l.generateMipmaps !== void 0 && (h.generateMipmaps = l.generateMipmaps), l.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = l.premultiplyAlpha), l.unpackAlignment !== void 0 && (h.unpackAlignment = l.unpackAlignment), l.compareFunction !== void 0 && (h.compareFunction = l.compareFunction), l.userData !== void 0 && (h.userData = l.userData), r[l.uuid] = h;
      }
    return r;
  }
  parseObject(e, t, i, r, s) {
    let o;
    function l(m) {
      return t[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", m), t[m];
    }
    function c(m) {
      if (m !== void 0) {
        if (Array.isArray(m)) {
          const v = [];
          for (let _ = 0, w = m.length; _ < w; _++) {
            const M = m[_];
            i[M] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", M), v.push(i[M]);
          }
          return v;
        }
        return i[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", m), i[m];
      }
    }
    function f(m) {
      return r[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", m), r[m];
    }
    let h, d;
    switch (e.type) {
      case "Scene":
        o = new x_(), e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new ze(e.background) : o.background = f(e.background)), e.environment !== void 0 && (o.environment = f(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new bp(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new Pp(e.fog.color, e.fog.density))), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        o = new Qt(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        o = new Vr(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new O2(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new U2(e.color, e.intensity);
        break;
      case "PointLight":
        o = new D2(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new k2(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new N2(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        o = new I2(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new qp().fromJSON(e);
        break;
      case "SkinnedMesh":
        h = l(e.geometry), d = c(e.material), o = new r2(h, d), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        h = l(e.geometry), d = c(e.material), o = new kn(h, d);
        break;
      case "InstancedMesh":
        h = l(e.geometry), d = c(e.material);
        const m = e.count, v = e.instanceMatrix, _ = e.instanceColor;
        o = new s2(h, d, m), o.instanceMatrix = new Gl(new Float32Array(v.array), 16), _ !== void 0 && (o.instanceColor = new Gl(new Float32Array(_.array), _.itemSize));
        break;
      case "LOD":
        o = new i2();
        break;
      case "Line":
        o = new fo(l(e.geometry), c(e.material));
        break;
      case "LineLoop":
        o = new o2(l(e.geometry), c(e.material));
        break;
      case "LineSegments":
        o = new Yr(l(e.geometry), c(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new a2(l(e.geometry), c(e.material));
        break;
      case "Sprite":
        o = new n2(c(e.material));
        break;
      case "Group":
        o = new Ml();
        break;
      case "Bone":
        o = new M_();
        break;
      default:
        o = new It();
    }
    if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
      const m = e.children;
      for (let v = 0; v < m.length; v++)
        o.add(this.parseObject(m[v], t, i, r, s));
    }
    if (e.animations !== void 0) {
      const m = e.animations;
      for (let v = 0; v < m.length; v++) {
        const _ = m[v];
        o.animations.push(s[_]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const m = e.levels;
      for (let v = 0; v < m.length; v++) {
        const _ = m[v], w = o.getObjectByProperty("uuid", _.object);
        w !== void 0 && o.addLevel(w, _.distance, _.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(i) {
      if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
        const r = t[i.skeleton];
        r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(r, i.bindMatrix);
      }
    });
  }
}
const IO = {
  UVMapping: wp,
  CubeReflectionMapping: lo,
  CubeRefractionMapping: uo,
  EquirectangularReflectionMapping: Mc,
  EquirectangularRefractionMapping: wc,
  CubeUVReflectionMapping: ql
}, XM = {
  RepeatWrapping: Ec,
  ClampToEdgeWrapping: Jn,
  MirroredRepeatWrapping: Tc
}, jM = {
  NearestFilter: hn,
  NearestMipmapNearestFilter: ep,
  NearestMipmapLinearFilter: ec,
  LinearFilter: pn,
  LinearMipmapNearestFilter: t_,
  LinearMipmapLinearFilter: co
};
class NO extends Mi {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, o = ha.get(e);
    if (o !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(o), s.manager.itemEnd(e);
      }, 0), o;
    const l = {};
    l.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", l.headers = this.requestHeader, fetch(e, l).then(function(c) {
      return c.blob();
    }).then(function(c) {
      return createImageBitmap(c, Object.assign(s.options, { colorSpaceConversion: "none" }));
    }).then(function(c) {
      ha.add(e, c), t && t(c), s.manager.itemEnd(e);
    }).catch(function(c) {
      r && r(c), s.manager.itemError(e), s.manager.itemEnd(e);
    }), s.manager.itemStart(e);
  }
}
let Jh;
class F_ {
  static getContext() {
    return Jh === void 0 && (Jh = new (window.AudioContext || window.webkitAudioContext)()), Jh;
  }
  static setContext(e) {
    Jh = e;
  }
}
class DO extends Mi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new ws(this.manager);
    o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(c) {
      try {
        const f = c.slice(0);
        F_.getContext().decodeAudioData(f, function(d) {
          t(d);
        }, l);
      } catch (f) {
        l(f);
      }
    }, i, r);
    function l(c) {
      r ? r(c) : console.error(c), s.manager.itemError(e);
    }
  }
}
class UO extends qp {
  constructor(e, t, i = 1) {
    super(void 0, i), this.isHemisphereLightProbe = !0;
    const r = new ze().set(e), s = new ze().set(t), o = new D(r.r, r.g, r.b), l = new D(s.r, s.g, s.b), c = Math.sqrt(Math.PI), f = c * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(o).add(l).multiplyScalar(c), this.sh.coefficients[1].copy(o).sub(l).multiplyScalar(f);
  }
}
class OO extends qp {
  constructor(e, t = 1) {
    super(void 0, t), this.isAmbientLightProbe = !0;
    const i = new ze().set(e);
    this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
const YM = /* @__PURE__ */ new dt(), qM = /* @__PURE__ */ new dt(), No = /* @__PURE__ */ new dt();
class kO {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Qt(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Qt(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, No.copy(e.projectionMatrix);
      const r = t.eyeSep / 2, s = r * t.near / t.focus, o = t.near * Math.tan(ta * t.fov * 0.5) / t.zoom;
      let l, c;
      qM.elements[12] = -r, YM.elements[12] = r, l = -o * t.aspect + s, c = o * t.aspect + s, No.elements[0] = 2 * t.near / (c - l), No.elements[8] = (c + l) / (c - l), this.cameraL.projectionMatrix.copy(No), l = -o * t.aspect - s, c = o * t.aspect - s, No.elements[0] = 2 * t.near / (c - l), No.elements[8] = (c + l) / (c - l), this.cameraR.projectionMatrix.copy(No);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(qM), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(YM);
  }
}
class z_ {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = ZM(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = ZM();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function ZM() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Do = /* @__PURE__ */ new D(), KM = /* @__PURE__ */ new Qn(), FO = /* @__PURE__ */ new D(), Uo = /* @__PURE__ */ new D();
class zO extends It {
  constructor() {
    super(), this.type = "AudioListener", this.context = F_.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new z_();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, i = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Do, KM, FO), Uo.set(0, 0, -1).applyQuaternion(KM), t.positionX) {
      const r = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Do.x, r), t.positionY.linearRampToValueAtTime(Do.y, r), t.positionZ.linearRampToValueAtTime(Do.z, r), t.forwardX.linearRampToValueAtTime(Uo.x, r), t.forwardY.linearRampToValueAtTime(Uo.y, r), t.forwardZ.linearRampToValueAtTime(Uo.z, r), t.upX.linearRampToValueAtTime(i.x, r), t.upY.linearRampToValueAtTime(i.y, r), t.upZ.linearRampToValueAtTime(i.z, r);
    } else
      t.setPosition(Do.x, Do.y, Do.z), t.setOrientation(Uo.x, Uo.y, Uo.z, i.x, i.y, i.z);
  }
}
class H2 extends It {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this._connected = !1, this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const Oo = /* @__PURE__ */ new D(), JM = /* @__PURE__ */ new Qn(), BO = /* @__PURE__ */ new D(), ko = /* @__PURE__ */ new D();
class HO extends H2 {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, i) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(Oo, JM, BO), ko.set(0, 0, 1).applyQuaternion(JM);
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Oo.x, i), t.positionY.linearRampToValueAtTime(Oo.y, i), t.positionZ.linearRampToValueAtTime(Oo.z, i), t.orientationX.linearRampToValueAtTime(ko.x, i), t.orientationY.linearRampToValueAtTime(ko.y, i), t.orientationZ.linearRampToValueAtTime(ko.z, i);
    } else
      t.setPosition(Oo.x, Oo.y, Oo.z), t.setOrientation(ko.x, ko.y, ko.z);
  }
}
class VO {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t.length; i++)
      e += t[i];
    return e / t.length;
  }
}
class V2 {
  constructor(e, t, i) {
    this.binding = e, this.valueSize = i;
    let r, s, o;
    switch (t) {
      case "quaternion":
        r = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        r = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
        break;
      default:
        r = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5);
    }
    this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const i = this.buffer, r = this.valueSize, s = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let l = 0; l !== r; ++l)
        i[s + l] = i[l];
      o = t;
    } else {
      o += t;
      const l = t / o;
      this._mixBufferRegion(i, s, 0, l, r);
    }
    this.cumulativeWeight = o;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, i = this.valueSize, r = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, i), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, i = this.buffer, r = e * t + t, s = this.cumulativeWeight, o = this.cumulativeWeightAdditive, l = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const c = t * this._origIndex;
      this._mixBufferRegion(
        i,
        r,
        c,
        1 - s,
        t
      );
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
    for (let c = t, f = t + t; c !== f; ++c)
      if (i[c] !== i[c + t]) {
        l.setValue(i, r);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, i = this.valueSize, r = i * this._origIndex;
    e.getValue(t, r);
    for (let s = i, o = r; s !== o; ++s)
      t[s] = t[r + s % i];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let i = e; i < t; i++)
      this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  // mix functions
  _select(e, t, i, r, s) {
    if (r >= 0.5)
      for (let o = 0; o !== s; ++o)
        e[t + o] = e[i + o];
  }
  _slerp(e, t, i, r) {
    Qn.slerpFlat(e, t, e, t, e, i, r);
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s;
    Qn.multiplyQuaternionsFlat(e, o, e, t, e, i), Qn.slerpFlat(e, t, e, t, e, o, r);
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r;
    for (let l = 0; l !== s; ++l) {
      const c = t + l;
      e[c] = e[c] * o + e[i + l] * r;
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const l = t + o;
      e[l] = e[l] + e[i + o] * r;
    }
  }
}
const B_ = "\\[\\]\\.:\\/", GO = new RegExp("[" + B_ + "]", "g"), H_ = "[^" + B_ + "]", WO = "[^" + B_.replace("\\.", "") + "]", XO = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", H_), jO = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", WO), YO = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", H_), qO = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", H_), ZO = new RegExp(
  "^" + XO + jO + YO + qO + "$"
), KO = ["material", "materials", "bones", "map"];
class JO {
  constructor(e, t, i) {
    const r = i || Ct.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, r);
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_, r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class Ct {
  constructor(e, t, i) {
    this.path = t, this.parsedPath = i || Ct.parseTrackName(t), this.node = Ct.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup ? new Ct.Composite(e, t, i) : new Ct(e, t, i);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(GO, "");
  }
  static parseTrackName(e) {
    const t = ZO.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      KO.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r), i.objectName = s);
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return i;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0)
        return i;
    }
    if (e.children) {
      const i = function(s) {
        for (let o = 0; o < s.length; o++) {
          const l = s[o];
          if (l.name === t || l.uuid === t)
            return l;
          const c = i(l.children);
          if (c)
            return c;
        }
        return null;
      }, r = i(e.children);
      if (r)
        return r;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      i[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r)
      i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, i = t.objectName, r = t.propertyName;
    let s = t.propertyIndex;
    if (e || (e = Ct.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (i) {
      let f = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === f) {
              f = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[i];
      }
      if (f !== void 0) {
        if (e[f] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[f];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const f = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + f + "." + r + " but it wasn't found.", e);
      return;
    }
    let l = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? l = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (l = this.Versioning.MatrixWorldNeedsUpdate);
    let c = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
      }
      c = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s;
    } else
      o.fromArray !== void 0 && o.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (c = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Ct.Composite = JO;
Ct.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Ct.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Ct.prototype.GetterByBindingType = [
  Ct.prototype._getValue_direct,
  Ct.prototype._getValue_array,
  Ct.prototype._getValue_arrayElement,
  Ct.prototype._getValue_toArray
];
Ct.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Ct.prototype._setValue_direct,
    Ct.prototype._setValue_direct_setNeedsUpdate,
    Ct.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Ct.prototype._setValue_array,
    Ct.prototype._setValue_array_setNeedsUpdate,
    Ct.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Ct.prototype._setValue_arrayElement,
    Ct.prototype._setValue_arrayElement_setNeedsUpdate,
    Ct.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Ct.prototype._setValue_fromArray,
    Ct.prototype._setValue_fromArray_setNeedsUpdate,
    Ct.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class QO {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = Oi(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, r = arguments.length; i !== r; ++i)
      e[arguments[i].uuid] = i;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, i = this._paths, r = this._parsedPaths, s = this._bindings, o = s.length;
    let l, c = e.length, f = this.nCachedObjects_;
    for (let h = 0, d = arguments.length; h !== d; ++h) {
      const m = arguments[h], v = m.uuid;
      let _ = t[v];
      if (_ === void 0) {
        _ = c++, t[v] = _, e.push(m);
        for (let w = 0, M = o; w !== M; ++w)
          s[w].push(new Ct(m, i[w], r[w]));
      } else if (_ < f) {
        l = e[_];
        const w = --f, M = e[w];
        t[M.uuid] = _, e[_] = M, t[v] = w, e[w] = m;
        for (let g = 0, x = o; g !== x; ++g) {
          const S = s[g], T = S[w];
          let C = S[_];
          S[_] = T, C === void 0 && (C = new Ct(m, i[g], r[g])), S[w] = C;
        }
      } else
        e[_] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = f;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length;
    let s = this.nCachedObjects_;
    for (let o = 0, l = arguments.length; o !== l; ++o) {
      const c = arguments[o], f = c.uuid, h = t[f];
      if (h !== void 0 && h >= s) {
        const d = s++, m = e[d];
        t[m.uuid] = h, e[h] = m, t[f] = d, e[d] = c;
        for (let v = 0, _ = r; v !== _; ++v) {
          const w = i[v], M = w[d], g = w[h];
          w[h] = M, w[d] = g;
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length;
    let s = this.nCachedObjects_, o = e.length;
    for (let l = 0, c = arguments.length; l !== c; ++l) {
      const f = arguments[l], h = f.uuid, d = t[h];
      if (d !== void 0)
        if (delete t[h], d < s) {
          const m = --s, v = e[m], _ = --o, w = e[_];
          t[v.uuid] = d, e[d] = v, t[w.uuid] = m, e[m] = w, e.pop();
          for (let M = 0, g = r; M !== g; ++M) {
            const x = i[M], S = x[m], T = x[_];
            x[d] = S, x[m] = T, x.pop();
          }
        } else {
          const m = --o, v = e[m];
          m > 0 && (t[v.uuid] = d), e[d] = v, e.pop();
          for (let _ = 0, w = r; _ !== w; ++_) {
            const M = i[_];
            M[d] = M[m], M.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath;
    let r = i[e];
    const s = this._bindings;
    if (r !== void 0)
      return s[r];
    const o = this._paths, l = this._parsedPaths, c = this._objects, f = c.length, h = this.nCachedObjects_, d = new Array(f);
    r = s.length, i[e] = r, o.push(e), l.push(t), s.push(d);
    for (let m = h, v = c.length; m !== v; ++m) {
      const _ = c[m];
      d[m] = new Ct(_, e, t);
    }
    return d;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, i = t[e];
    if (i !== void 0) {
      const r = this._paths, s = this._parsedPaths, o = this._bindings, l = o.length - 1, c = o[l], f = e[l];
      t[f] = i, o[i] = c, o.pop(), s[i] = s[l], s.pop(), r[i] = r[l], r.pop();
    }
  }
}
class G2 {
  constructor(e, t, i = null, r = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = r;
    const s = t.tracks, o = s.length, l = new Array(o), c = {
      endingStart: qo,
      endingEnd: qo
    };
    for (let f = 0; f !== o; ++f) {
      const h = s[f].createInterpolant(null);
      l[f] = h, h.settings = c;
    }
    this._interpolantSettings = c, this._interpolants = l, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = EA, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if (e.fadeOut(t), this.fadeIn(t), i) {
      const r = this._clip.duration, s = e._clip.duration, o = s / r, l = r / s;
      e.warp(1, o, t), this.warp(l, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const r = this._mixer, s = r.time, o = this.timeScale;
    let l = this._timeScaleInterpolant;
    l === null && (l = r._lendControlInterpolant(), this._timeScaleInterpolant = l);
    const c = l.parameterPositions, f = l.sampleValues;
    return c[0] = s, c[1] = s + i, f[0] = e / o, f[1] = t / o, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const c = (e - s) * i;
      c < 0 || i === 0 ? t = 0 : (this._startTime = null, t = i * c);
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t), l = this._updateWeight(e);
    if (l > 0) {
      const c = this._interpolants, f = this._propertyBindings;
      switch (this.blendMode) {
        case l_:
          for (let h = 0, d = c.length; h !== d; ++h)
            c[h].evaluate(o), f[h].accumulateAdditive(l);
          break;
        case Tp:
        default:
          for (let h = 0, d = c.length; h !== d; ++h)
            c[h].evaluate(o), f[h].accumulate(r, l);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        t *= r, e > i.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        t *= r, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, i = this.loop;
    let r = this.time + e, s = this._loopCount;
    const o = i === TA;
    if (e === 0)
      return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
    if (i === wA) {
      s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (r >= t)
          r = t;
        else if (r < 0)
          r = 0;
        else {
          this.time = r;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), r >= t || r < 0) {
        const l = Math.floor(r / t);
        r -= t * l, s += Math.abs(l);
        const c = this.repetitions - s;
        if (c <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (c === 1) {
            const f = e < 0;
            this._setEndings(f, !f, o);
          } else
            this._setEndings(!1, !1, o);
          this._loopCount = s, this.time = r, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: l
          });
        }
      } else
        this.time = r;
      if (o && (s & 1) === 1)
        return t - r;
    }
    return r;
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings;
    i ? (r.endingStart = Zo, r.endingEnd = Zo) : (e ? r.endingStart = this.zeroSlopeAtStart ? Zo : qo : r.endingStart = Rc, t ? r.endingEnd = this.zeroSlopeAtEnd ? Zo : qo : r.endingEnd = Rc);
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer, s = r.time;
    let o = this._weightInterpolant;
    o === null && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
    const l = o.parameterPositions, c = o.sampleValues;
    return l[0] = s, c[0] = t, l[1] = s + e, c[1] = i, this;
  }
}
const $O = new Float32Array(1);
class ek extends Ts {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root, r = e._clip.tracks, s = r.length, o = e._propertyBindings, l = e._interpolants, c = i.uuid, f = this._bindingsByRootAndName;
    let h = f[c];
    h === void 0 && (h = {}, f[c] = h);
    for (let d = 0; d !== s; ++d) {
      const m = r[d], v = m.name;
      let _ = h[v];
      if (_ !== void 0)
        ++_.referenceCount, o[d] = _;
      else {
        if (_ = o[d], _ !== void 0) {
          _._cacheIndex === null && (++_.referenceCount, this._addInactiveBinding(_, c, v));
          continue;
        }
        const w = t && t._propertyBindings[d].binding.parsedPath;
        _ = new V2(
          Ct.create(i, v, w),
          m.ValueTypeName,
          m.getValueSize()
        ), ++_.referenceCount, this._addInactiveBinding(_, c, v), o[d] = _;
      }
      l[d].resultBuffer = _.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid, r = e._clip.uuid, s = this._actionsByClip[r];
        this._bindAction(
          e,
          s && s.knownActions[0]
        ), this._addInactiveAction(e, r, i);
      }
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions, s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      o = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, s[t] = o;
    else {
      const l = o.knownActions;
      e._byClipCacheIndex = l.length, l.push(e);
    }
    e._cacheIndex = r.length, r.push(e), o.actionByRoot[i] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, i = t[t.length - 1], r = e._cacheIndex;
    i._cacheIndex = r, t[r] = i, t.pop(), e._cacheIndex = null;
    const s = e._clip.uuid, o = this._actionsByClip, l = o[s], c = l.knownActions, f = c[c.length - 1], h = e._byClipCacheIndex;
    f._byClipCacheIndex = h, c[h] = f, c.pop(), e._byClipCacheIndex = null;
    const d = l.actionByRoot, m = (e._localRoot || this._root).uuid;
    delete d[m], c.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions, i = e._cacheIndex, r = this._nActiveActions++, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _takeBackAction(e) {
    const t = this._actions, i = e._cacheIndex, r = --this._nActiveActions, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName, s = this._bindings;
    let o = r[t];
    o === void 0 && (o = {}, r[t] = o), o[i] = e, e._cacheIndex = s.length, s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, i = e.binding, r = i.rootNode.uuid, s = i.path, o = this._bindingsByRootAndName, l = o[r], c = t[t.length - 1], f = e._cacheIndex;
    c._cacheIndex = f, t[f] = c, t.pop(), delete l[s], Object.keys(l).length === 0 && delete o[r];
  }
  _lendBinding(e) {
    const t = this._bindings, i = e._cacheIndex, r = this._nActiveBindings++, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _takeBackBinding(e) {
    const t = this._bindings, i = e._cacheIndex, r = --this._nActiveBindings, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let i = e[t];
    return i === void 0 && (i = new D_(
      new Float32Array(2),
      new Float32Array(2),
      1,
      $O
    ), i.__cacheIndex = t, e[t] = i), i;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, i = e.__cacheIndex, r = --this._nActiveControlInterpolants, s = t[r];
    e.__cacheIndex = r, t[r] = e, s.__cacheIndex = i, t[i] = s;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, i) {
    const r = t || this._root, s = r.uuid;
    let o = typeof e == "string" ? Fc.findByName(r, e) : e;
    const l = o !== null ? o.uuid : e, c = this._actionsByClip[l];
    let f = null;
    if (i === void 0 && (o !== null ? i = o.blendMode : i = Tp), c !== void 0) {
      const d = c.actionByRoot[s];
      if (d !== void 0 && d.blendMode === i)
        return d;
      f = c.knownActions[0], o === null && (o = f._clip);
    }
    if (o === null)
      return null;
    const h = new G2(this, o, t, i);
    return this._bindAction(h, f), this._addInactiveAction(h, l, s), h;
  }
  // get an existing action
  existingAction(e, t) {
    const i = t || this._root, r = i.uuid, s = typeof e == "string" ? Fc.findByName(i, e) : e, o = s ? s.uuid : e, l = this._actionsByClip[o];
    return l !== void 0 && l.actionByRoot[r] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i)
      e[i].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, i = this._nActiveActions, r = this.time += e, s = Math.sign(e), o = this._accuIndex ^= 1;
    for (let f = 0; f !== i; ++f)
      t[f]._update(r, e, s, o);
    const l = this._bindings, c = this._nActiveBindings;
    for (let f = 0; f !== c; ++f)
      l[f].apply(o);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, i = e.uuid, r = this._actionsByClip, s = r[i];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let l = 0, c = o.length; l !== c; ++l) {
        const f = o[l];
        this._deactivateAction(f);
        const h = f._cacheIndex, d = t[t.length - 1];
        f._cacheIndex = null, f._byClipCacheIndex = null, d._cacheIndex = h, t[h] = d, t.pop(), this._removeInactiveBindingsForAction(f);
      }
      delete r[i];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, i = this._actionsByClip;
    for (const o in i) {
      const l = i[o].actionByRoot, c = l[t];
      c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c));
    }
    const r = this._bindingsByRootAndName, s = r[t];
    if (s !== void 0)
      for (const o in s) {
        const l = s[o];
        l.restoreOriginalState(), this._removeInactiveBinding(l);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class V_ {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new V_(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let tk = 0;
class nk extends Ts {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: tk++ }), this.name = "", this.usage = Pc, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, r = t.length; i < r; i++)
      this.uniforms.push(t[i].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ik extends Lp {
  constructor(e, t, i = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class rk {
  constructor(e, t, i, r, s) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = i, this.elementSize = r, this.count = s, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class W2 {
  constructor(e, t, i = 0, r = 1 / 0) {
    this.ray = new ma(e, t), this.near = i, this.far = r, this.camera = null, this.layers = new na(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, i = []) {
    return Jv(e, this, i, t), i.sort(QM), i;
  }
  intersectObjects(e, t = !0, i = []) {
    for (let r = 0, s = e.length; r < s; r++)
      Jv(e[r], this, i, t);
    return i.sort(QM), i;
  }
}
function QM(n, e) {
  return n.distance - e.distance;
}
function Jv(n, e, t, i) {
  if (n.layers.test(e.layers) && n.raycast(e, t), i === !0) {
    const r = n.children;
    for (let s = 0, o = r.length; s < o; s++)
      Jv(r[s], e, t, !0);
  }
}
class Qv {
  constructor(e = 1, t = 0, i = 0) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  set(e, t, i) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(un(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class sk {
  constructor(e = 1, t = 0, i = 0) {
    return this.radius = e, this.theta = t, this.y = i, this;
  }
  set(e, t, i) {
    return this.radius = e, this.theta = t, this.y = i, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const $M = /* @__PURE__ */ new me();
class ok {
  constructor(e = new me(1 / 0, 1 / 0), t = new me(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = $M.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, $M).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const ew = /* @__PURE__ */ new D(), Qh = /* @__PURE__ */ new D();
class ak {
  constructor(e = new D(), t = new D()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    ew.subVectors(e, this.start), Qh.subVectors(this.end, this.start);
    const i = Qh.dot(Qh);
    let s = Qh.dot(ew) / i;
    return t && (s = un(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const tw = /* @__PURE__ */ new D();
class lk extends It {
  constructor(e, t) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const i = new wt(), r = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let o = 0, l = 1, c = 32; o < c; o++, l++) {
      const f = o / c * Math.PI * 2, h = l / c * Math.PI * 2;
      r.push(
        Math.cos(f),
        Math.sin(f),
        1,
        Math.cos(h),
        Math.sin(h),
        1
      );
    }
    i.setAttribute("position", new Ye(r, 3));
    const s = new ci({ fog: !1, toneMapped: !1 });
    this.cone = new Yr(i, s), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), tw.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(tw), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const Hs = /* @__PURE__ */ new D(), $h = /* @__PURE__ */ new dt(), a0 = /* @__PURE__ */ new dt();
class uk extends Yr {
  constructor(e) {
    const t = X2(e), i = new wt(), r = [], s = [], o = new ze(0, 0, 1), l = new ze(0, 1, 0);
    for (let f = 0; f < t.length; f++) {
      const h = t[f];
      h.parent && h.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), s.push(o.r, o.g, o.b), s.push(l.r, l.g, l.b));
    }
    i.setAttribute("position", new Ye(r, 3)), i.setAttribute("color", new Ye(s, 3));
    const c = new ci({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(i, c), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, i = this.geometry, r = i.getAttribute("position");
    a0.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const l = t[s];
      l.parent && l.parent.isBone && ($h.multiplyMatrices(a0, l.matrixWorld), Hs.setFromMatrixPosition($h), r.setXYZ(o, Hs.x, Hs.y, Hs.z), $h.multiplyMatrices(a0, l.parent.matrixWorld), Hs.setFromMatrixPosition($h), r.setXYZ(o + 1, Hs.x, Hs.y, Hs.z), o += 2);
    }
    i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function X2(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, X2(n.children[t]));
  return e;
}
class ck extends kn {
  constructor(e, t, i) {
    const r = new Qc(t, 4, 2), s = new vo({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, s), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const fk = /* @__PURE__ */ new D(), nw = /* @__PURE__ */ new ze(), iw = /* @__PURE__ */ new ze();
class hk extends It {
  constructor(e, t, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "HemisphereLightHelper";
    const r = new Jc(t);
    r.rotateY(Math.PI * 0.5), this.material = new vo({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const s = r.getAttribute("position"), o = new Float32Array(s.count * 3);
    r.setAttribute("color", new Ht(o, 3)), this.add(new kn(r, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      nw.copy(this.light.color), iw.copy(this.light.groundColor);
      for (let i = 0, r = t.count; i < r; i++) {
        const s = i < r / 2 ? nw : iw;
        t.setXYZ(i, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(fk.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class dk extends Yr {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    i = new ze(i), r = new ze(r);
    const s = t / 2, o = e / t, l = e / 2, c = [], f = [];
    for (let m = 0, v = 0, _ = -l; m <= t; m++, _ += o) {
      c.push(-l, 0, _, l, 0, _), c.push(_, 0, -l, _, 0, l);
      const w = m === s ? i : r;
      w.toArray(f, v), v += 3, w.toArray(f, v), v += 3, w.toArray(f, v), v += 3, w.toArray(f, v), v += 3;
    }
    const h = new wt();
    h.setAttribute("position", new Ye(c, 3)), h.setAttribute("color", new Ye(f, 3));
    const d = new ci({ vertexColors: !0, toneMapped: !1 });
    super(h, d), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class pk extends Yr {
  constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) {
    s = new ze(s), o = new ze(o);
    const l = [], c = [];
    if (t > 1)
      for (let d = 0; d < t; d++) {
        const m = d / t * (Math.PI * 2), v = Math.sin(m) * e, _ = Math.cos(m) * e;
        l.push(0, 0, 0), l.push(v, 0, _);
        const w = d & 1 ? s : o;
        c.push(w.r, w.g, w.b), c.push(w.r, w.g, w.b);
      }
    for (let d = 0; d < i; d++) {
      const m = d & 1 ? s : o, v = e - e / i * d;
      for (let _ = 0; _ < r; _++) {
        let w = _ / r * (Math.PI * 2), M = Math.sin(w) * v, g = Math.cos(w) * v;
        l.push(M, 0, g), c.push(m.r, m.g, m.b), w = (_ + 1) / r * (Math.PI * 2), M = Math.sin(w) * v, g = Math.cos(w) * v, l.push(M, 0, g), c.push(m.r, m.g, m.b);
      }
    }
    const f = new wt();
    f.setAttribute("position", new Ye(l, 3)), f.setAttribute("color", new Ye(c, 3));
    const h = new ci({ vertexColors: !0, toneMapped: !1 });
    super(f, h), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const rw = /* @__PURE__ */ new D(), ed = /* @__PURE__ */ new D(), sw = /* @__PURE__ */ new D();
class mk extends It {
  constructor(e, t, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let r = new wt();
    r.setAttribute("position", new Ye([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const s = new ci({ fog: !1, toneMapped: !1 });
    this.lightPlane = new fo(r, s), this.add(this.lightPlane), r = new wt(), r.setAttribute("position", new Ye([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new fo(r, s), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), rw.setFromMatrixPosition(this.light.matrixWorld), ed.setFromMatrixPosition(this.light.target.matrixWorld), sw.subVectors(ed, rw), this.lightPlane.lookAt(ed), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(ed), this.targetLine.scale.z = sw.length();
  }
}
const td = /* @__PURE__ */ new D(), an = /* @__PURE__ */ new Yc();
class gk extends Yr {
  constructor(e) {
    const t = new wt(), i = new ci({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], s = [], o = {};
    l("n1", "n2"), l("n2", "n4"), l("n4", "n3"), l("n3", "n1"), l("f1", "f2"), l("f2", "f4"), l("f4", "f3"), l("f3", "f1"), l("n1", "f1"), l("n2", "f2"), l("n3", "f3"), l("n4", "f4"), l("p", "n1"), l("p", "n2"), l("p", "n3"), l("p", "n4"), l("u1", "u2"), l("u2", "u3"), l("u3", "u1"), l("c", "t"), l("p", "c"), l("cn1", "cn2"), l("cn3", "cn4"), l("cf1", "cf2"), l("cf3", "cf4");
    function l(_, w) {
      c(_), c(w);
    }
    function c(_) {
      r.push(0, 0, 0), s.push(0, 0, 0), o[_] === void 0 && (o[_] = []), o[_].push(r.length / 3 - 1);
    }
    t.setAttribute("position", new Ye(r, 3)), t.setAttribute("color", new Ye(s, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
    const f = new ze(16755200), h = new ze(16711680), d = new ze(43775), m = new ze(16777215), v = new ze(3355443);
    this.setColors(f, h, d, m, v);
  }
  setColors(e, t, i, r, s) {
    const l = this.geometry.getAttribute("color");
    l.setXYZ(0, e.r, e.g, e.b), l.setXYZ(1, e.r, e.g, e.b), l.setXYZ(2, e.r, e.g, e.b), l.setXYZ(3, e.r, e.g, e.b), l.setXYZ(4, e.r, e.g, e.b), l.setXYZ(5, e.r, e.g, e.b), l.setXYZ(6, e.r, e.g, e.b), l.setXYZ(7, e.r, e.g, e.b), l.setXYZ(8, e.r, e.g, e.b), l.setXYZ(9, e.r, e.g, e.b), l.setXYZ(10, e.r, e.g, e.b), l.setXYZ(11, e.r, e.g, e.b), l.setXYZ(12, e.r, e.g, e.b), l.setXYZ(13, e.r, e.g, e.b), l.setXYZ(14, e.r, e.g, e.b), l.setXYZ(15, e.r, e.g, e.b), l.setXYZ(16, e.r, e.g, e.b), l.setXYZ(17, e.r, e.g, e.b), l.setXYZ(18, e.r, e.g, e.b), l.setXYZ(19, e.r, e.g, e.b), l.setXYZ(20, e.r, e.g, e.b), l.setXYZ(21, e.r, e.g, e.b), l.setXYZ(22, e.r, e.g, e.b), l.setXYZ(23, e.r, e.g, e.b), l.setXYZ(24, t.r, t.g, t.b), l.setXYZ(25, t.r, t.g, t.b), l.setXYZ(26, t.r, t.g, t.b), l.setXYZ(27, t.r, t.g, t.b), l.setXYZ(28, t.r, t.g, t.b), l.setXYZ(29, t.r, t.g, t.b), l.setXYZ(30, t.r, t.g, t.b), l.setXYZ(31, t.r, t.g, t.b), l.setXYZ(32, i.r, i.g, i.b), l.setXYZ(33, i.r, i.g, i.b), l.setXYZ(34, i.r, i.g, i.b), l.setXYZ(35, i.r, i.g, i.b), l.setXYZ(36, i.r, i.g, i.b), l.setXYZ(37, i.r, i.g, i.b), l.setXYZ(38, r.r, r.g, r.b), l.setXYZ(39, r.r, r.g, r.b), l.setXYZ(40, s.r, s.g, s.b), l.setXYZ(41, s.r, s.g, s.b), l.setXYZ(42, s.r, s.g, s.b), l.setXYZ(43, s.r, s.g, s.b), l.setXYZ(44, s.r, s.g, s.b), l.setXYZ(45, s.r, s.g, s.b), l.setXYZ(46, s.r, s.g, s.b), l.setXYZ(47, s.r, s.g, s.b), l.setXYZ(48, s.r, s.g, s.b), l.setXYZ(49, s.r, s.g, s.b), l.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, i = 1, r = 1;
    an.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), fn("c", t, e, an, 0, 0, -1), fn("t", t, e, an, 0, 0, 1), fn("n1", t, e, an, -i, -r, -1), fn("n2", t, e, an, i, -r, -1), fn("n3", t, e, an, -i, r, -1), fn("n4", t, e, an, i, r, -1), fn("f1", t, e, an, -i, -r, 1), fn("f2", t, e, an, i, -r, 1), fn("f3", t, e, an, -i, r, 1), fn("f4", t, e, an, i, r, 1), fn("u1", t, e, an, i * 0.7, r * 1.1, -1), fn("u2", t, e, an, -i * 0.7, r * 1.1, -1), fn("u3", t, e, an, 0, r * 2, -1), fn("cf1", t, e, an, -i, 0, 1), fn("cf2", t, e, an, i, 0, 1), fn("cf3", t, e, an, 0, -r, 1), fn("cf4", t, e, an, 0, r, 1), fn("cn1", t, e, an, -i, 0, -1), fn("cn2", t, e, an, i, 0, -1), fn("cn3", t, e, an, 0, -r, -1), fn("cn4", t, e, an, 0, r, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function fn(n, e, t, i, r, s, o) {
  td.set(r, s, o).unproject(i);
  const l = e[n];
  if (l !== void 0) {
    const c = t.getAttribute("position");
    for (let f = 0, h = l.length; f < h; f++)
      c.setXYZ(l[f], td.x, td.y, td.z);
  }
}
const nd = /* @__PURE__ */ new jr();
class vk extends Yr {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(8 * 3), s = new wt();
    s.setIndex(new Ht(i, 1)), s.setAttribute("position", new Ht(r, 3)), super(s, new ci({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && nd.setFromObject(this.object), nd.isEmpty())
      return;
    const t = nd.min, i = nd.max, r = this.geometry.attributes.position, s = r.array;
    s[0] = i.x, s[1] = i.y, s[2] = i.z, s[3] = t.x, s[4] = i.y, s[5] = i.z, s[6] = t.x, s[7] = t.y, s[8] = i.z, s[9] = i.x, s[10] = t.y, s[11] = i.z, s[12] = i.x, s[13] = i.y, s[14] = t.z, s[15] = t.x, s[16] = i.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = i.x, s[22] = t.y, s[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class yk extends Yr {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], s = new wt();
    s.setIndex(new Ht(i, 1)), s.setAttribute("position", new Ye(r, 3)), super(s, new ci({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class _k extends fo {
  constructor(e, t = 1, i = 16776960) {
    const r = i, s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new wt();
    o.setAttribute("position", new Ye(s, 3)), o.computeBoundingSphere(), super(o, new ci({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const l = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], c = new wt();
    c.setAttribute("position", new Ye(l, 3)), c.computeBoundingSphere(), this.add(new kn(c, new vo({ color: r, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const ow = /* @__PURE__ */ new D();
let id, l0;
class xk extends It {
  // dir is assumed to be normalized
  constructor(e = new D(0, 0, 1), t = new D(0, 0, 0), i = 1, r = 16776960, s = i * 0.2, o = s * 0.2) {
    super(), this.type = "ArrowHelper", id === void 0 && (id = new wt(), id.setAttribute("position", new Ye([0, 0, 0, 0, 1, 0], 3)), l0 = new Kl(0, 0.5, 1, 5, 1), l0.translate(0, -0.5, 0)), this.position.copy(t), this.line = new fo(id, new ci({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new kn(l0, new vo({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, s, o);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      ow.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(ow, t);
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class Sk extends Yr {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], i = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], r = new wt();
    r.setAttribute("position", new Ye(t, 3)), r.setAttribute("color", new Ye(i, 3));
    const s = new ci({ vertexColors: !0, toneMapped: !1 });
    super(r, s), this.type = "AxesHelper";
  }
  setColors(e, t, i) {
    const r = new ze(), s = this.geometry.attributes.color.array;
    return r.set(e), r.toArray(s, 0), r.toArray(s, 3), r.set(t), r.toArray(s, 6), r.toArray(s, 9), r.set(i), r.toArray(s, 12), r.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Mk {
  constructor() {
    this.type = "ShapePath", this.color = new ze(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new Ic(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    return this.currentPath.quadraticCurveTo(e, t, i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(g) {
      const x = [];
      for (let S = 0, T = g.length; S < T; S++) {
        const C = g[S], P = new ia();
        P.curves = C.curves, x.push(P);
      }
      return x;
    }
    function i(g, x) {
      const S = x.length;
      let T = !1;
      for (let C = S - 1, P = 0; P < S; C = P++) {
        let L = x[C], N = x[P], R = N.x - L.x, b = N.y - L.y;
        if (Math.abs(b) > Number.EPSILON) {
          if (b < 0 && (L = x[P], R = -R, N = x[C], b = -b), g.y < L.y || g.y > N.y)
            continue;
          if (g.y === L.y) {
            if (g.x === L.x)
              return !0;
          } else {
            const G = b * (g.x - L.x) - R * (g.y - L.y);
            if (G === 0)
              return !0;
            if (G < 0)
              continue;
            T = !T;
          }
        } else {
          if (g.y !== L.y)
            continue;
          if (N.x <= g.x && g.x <= L.x || L.x <= g.x && g.x <= N.x)
            return !0;
        }
      }
      return T;
    }
    const r = Gr.isClockWise, s = this.subPaths;
    if (s.length === 0)
      return [];
    let o, l, c;
    const f = [];
    if (s.length === 1)
      return l = s[0], c = new ia(), c.curves = l.curves, f.push(c), f;
    let h = !r(s[0].getPoints());
    h = e ? !h : h;
    const d = [], m = [];
    let v = [], _ = 0, w;
    m[_] = void 0, v[_] = [];
    for (let g = 0, x = s.length; g < x; g++)
      l = s[g], w = l.getPoints(), o = r(w), o = e ? !o : o, o ? (!h && m[_] && _++, m[_] = { s: new ia(), p: w }, m[_].s.curves = l.curves, h && _++, v[_] = []) : v[_].push({ h: l, p: w[0] });
    if (!m[0])
      return t(s);
    if (m.length > 1) {
      let g = !1, x = 0;
      for (let S = 0, T = m.length; S < T; S++)
        d[S] = [];
      for (let S = 0, T = m.length; S < T; S++) {
        const C = v[S];
        for (let P = 0; P < C.length; P++) {
          const L = C[P];
          let N = !0;
          for (let R = 0; R < m.length; R++)
            i(L.p, m[R].p) && (S !== R && x++, N ? (N = !1, d[R].push(L)) : g = !0);
          N && d[S].push(L);
        }
      }
      x > 0 && g === !1 && (v = d);
    }
    let M;
    for (let g = 0, x = m.length; g < x; g++) {
      c = m[g].s, f.push(c), M = v[g];
      for (let S = 0, T = M.length; S < T; S++)
        c.holes.push(M[S].h);
    }
    return f;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Sp
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Sp);
const wk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: e_,
  AddEquation: Go,
  AddOperation: uA,
  AdditiveAnimationBlendMode: l_,
  AdditiveBlending: pv,
  AlphaFormat: gA,
  AlwaysCompare: kA,
  AlwaysDepth: nA,
  AlwaysStencilFunc: PA,
  AmbientLight: O2,
  AmbientLightProbe: OO,
  AnimationAction: G2,
  AnimationClip: Fc,
  AnimationLoader: wO,
  AnimationMixer: ek,
  AnimationObjectGroup: QO,
  AnimationUtils: _O,
  ArcCurve: l2,
  ArrayCamera: QA,
  ArrowHelper: xk,
  Audio: H2,
  AudioAnalyser: VO,
  AudioContext: F_,
  AudioListener: zO,
  AudioLoader: DO,
  AxesHelper: Sk,
  BackSide: ai,
  BasicDepthPacking: AA,
  BasicShadowMap: VT,
  Bone: M_,
  BooleanKeyframeTrack: va,
  Box2: ok,
  Box3: jr,
  Box3Helper: yk,
  BoxGeometry: ga,
  BoxHelper: vk,
  BufferAttribute: Ht,
  BufferGeometry: wt,
  BufferGeometryLoader: B2,
  ByteType: pA,
  Cache: ha,
  Camera: Yc,
  CameraHelper: gk,
  CanvasTexture: GU,
  CapsuleGeometry: Up,
  CatmullRomCurve3: u2,
  CineonToneMapping: hA,
  CircleGeometry: Op,
  ClampToEdgeWrapping: Jn,
  Clock: z_,
  Color: ze,
  ColorKeyframeTrack: U_,
  ColorManagement: Zi,
  CompressedArrayTexture: VU,
  CompressedTexture: E_,
  CompressedTextureLoader: EO,
  ConeGeometry: kp,
  CubeCamera: WA,
  CubeReflectionMapping: lo,
  CubeRefractionMapping: uo,
  CubeTexture: qc,
  CubeTextureLoader: TO,
  CubeUVReflectionMapping: ql,
  CubicBezierCurve: A_,
  CubicBezierCurve3: c2,
  CubicInterpolant: R2,
  CullFaceBack: dv,
  CullFaceFront: HT,
  CullFaceFrontBack: kb,
  CullFaceNone: BT,
  Curve: Er,
  CurvePath: h2,
  CustomBlending: GT,
  CustomToneMapping: dA,
  CylinderGeometry: Kl,
  Cylindrical: sk,
  Data3DTexture: d_,
  DataArrayTexture: Ap,
  DataTexture: Il,
  DataTextureLoader: AO,
  DataUtils: ZL,
  DecrementStencilOp: Zb,
  DecrementWrapStencilOp: Jb,
  DefaultLoadingManager: L2,
  DepthFormat: io,
  DepthStencilFormat: ua,
  DepthTexture: $A,
  DirectionalLight: U2,
  DirectionalLightHelper: mk,
  DiscreteInterpolant: P2,
  DisplayP3ColorSpace: c_,
  DodecahedronGeometry: Fp,
  DoubleSide: gr,
  DstAlphaFactor: KT,
  DstColorFactor: QT,
  DynamicCopyUsage: hL,
  DynamicDrawUsage: oL,
  DynamicReadUsage: uL,
  EdgesGeometry: d2,
  EllipseCurve: Np,
  EqualCompare: IA,
  EqualDepth: rA,
  EqualStencilFunc: tL,
  EquirectangularReflectionMapping: Mc,
  EquirectangularRefractionMapping: wc,
  Euler: jc,
  EventDispatcher: Ts,
  ExtrudeGeometry: Bp,
  FileLoader: ws,
  Float16BufferAttribute: t3,
  Float32BufferAttribute: Ye,
  Float64BufferAttribute: n3,
  FloatType: kr,
  Fog: bp,
  FogExp2: Pp,
  FramebufferTexture: HU,
  FrontSide: Ms,
  Frustum: Cp,
  GLBufferAttribute: rk,
  GLSL1: pL,
  GLSL3: Vv,
  GreaterCompare: DA,
  GreaterDepth: oA,
  GreaterEqualCompare: OA,
  GreaterEqualDepth: sA,
  GreaterEqualStencilFunc: sL,
  GreaterStencilFunc: iL,
  GridHelper: dk,
  Group: Ml,
  HalfFloatType: Bl,
  HemisphereLight: I2,
  HemisphereLightHelper: hk,
  HemisphereLightProbe: UO,
  IcosahedronGeometry: Hp,
  ImageBitmapLoader: NO,
  ImageLoader: zc,
  ImageUtils: h_,
  IncrementStencilOp: qb,
  IncrementWrapStencilOp: Kb,
  InstancedBufferAttribute: Gl,
  InstancedBufferGeometry: z2,
  InstancedInterleavedBuffer: ik,
  InstancedMesh: s2,
  Int16BufferAttribute: $L,
  Int32BufferAttribute: e3,
  Int8BufferAttribute: KL,
  IntType: n_,
  InterleavedBuffer: Lp,
  InterleavedBufferAttribute: ca,
  Interpolant: $c,
  InterpolateDiscrete: Ac,
  InterpolateLinear: Cc,
  InterpolateSmooth: Td,
  InvertStencilOp: Qb,
  KeepStencilOp: Ad,
  KeyframeTrack: Tr,
  LOD: i2,
  LatheGeometry: Kc,
  Layers: na,
  LessCompare: LA,
  LessDepth: iA,
  LessEqualCompare: NA,
  LessEqualDepth: $d,
  LessEqualStencilFunc: nL,
  LessStencilFunc: eL,
  Light: _o,
  LightProbe: qp,
  Line: fo,
  Line3: ak,
  LineBasicMaterial: ci,
  LineCurve: Dp,
  LineCurve3: f2,
  LineDashedMaterial: A2,
  LineLoop: o2,
  LineSegments: Yr,
  LinearEncoding: u_,
  LinearFilter: pn,
  LinearInterpolant: D_,
  LinearMipMapLinearFilter: Vb,
  LinearMipMapNearestFilter: Hb,
  LinearMipmapLinearFilter: co,
  LinearMipmapNearestFilter: t_,
  LinearSRGBColorSpace: Sr,
  LinearToneMapping: cA,
  Loader: Mi,
  LoaderUtils: Kv,
  LoadingManager: O_,
  LoopOnce: wA,
  LoopPingPong: TA,
  LoopRepeat: EA,
  LuminanceAlphaFormat: yA,
  LuminanceFormat: vA,
  MOUSE: Bo,
  Material: ei,
  MaterialLoader: Zp,
  MathUtils: zA,
  Matrix3: _t,
  Matrix4: dt,
  MaxEquation: yv,
  Mesh: kn,
  MeshBasicMaterial: vo,
  MeshDepthMaterial: v_,
  MeshDistanceMaterial: y_,
  MeshLambertMaterial: E2,
  MeshMatcapMaterial: T2,
  MeshNormalMaterial: w2,
  MeshPhongMaterial: S2,
  MeshPhysicalMaterial: x2,
  MeshStandardMaterial: L_,
  MeshToonMaterial: M2,
  MinEquation: vv,
  MirroredRepeatWrapping: Tc,
  MixOperation: lA,
  MultiplyBlending: gv,
  MultiplyOperation: Xc,
  NearestFilter: hn,
  NearestMipMapLinearFilter: Bb,
  NearestMipMapNearestFilter: zb,
  NearestMipmapLinearFilter: ec,
  NearestMipmapNearestFilter: ep,
  NeverCompare: bA,
  NeverDepth: tA,
  NeverStencilFunc: $b,
  NoBlending: vs,
  NoColorSpace: so,
  NoToneMapping: _r,
  NormalAnimationBlendMode: Tp,
  NormalBlending: ea,
  NotEqualCompare: UA,
  NotEqualDepth: aA,
  NotEqualStencilFunc: rL,
  NumberKeyframeTrack: Oc,
  Object3D: It,
  ObjectLoader: LO,
  ObjectSpaceNormalMap: RA,
  OctahedronGeometry: Jc,
  OneFactor: YT,
  OneMinusDstAlphaFactor: JT,
  OneMinusDstColorFactor: $T,
  OneMinusSrcAlphaFactor: $y,
  OneMinusSrcColorFactor: ZT,
  OrthographicCamera: Vr,
  PCFShadowMap: Mp,
  PCFSoftShadowMap: $u,
  PMREMGenerator: Wv,
  Path: Ic,
  PerspectiveCamera: Qt,
  Plane: fs,
  PlaneGeometry: Zc,
  PlaneHelper: _k,
  PointLight: D2,
  PointLightHelper: ck,
  Points: a2,
  PointsMaterial: w_,
  PolarGridHelper: pk,
  PolyhedronGeometry: yo,
  PositionalAudio: HO,
  PropertyBinding: Ct,
  PropertyMixer: V2,
  QuadraticBezierCurve: C_,
  QuadraticBezierCurve3: R_,
  Quaternion: Qn,
  QuaternionKeyframeTrack: Jl,
  QuaternionLinearInterpolant: b2,
  RED_GREEN_RGTC2_Format: Bv,
  RED_RGTC1_Format: MA,
  REVISION: Sp,
  RGBADepthPacking: CA,
  RGBAFormat: vi,
  RGBAIntegerFormat: a_,
  RGBA_ASTC_10x10_Format: Ov,
  RGBA_ASTC_10x5_Format: Nv,
  RGBA_ASTC_10x6_Format: Dv,
  RGBA_ASTC_10x8_Format: Uv,
  RGBA_ASTC_12x10_Format: kv,
  RGBA_ASTC_12x12_Format: Fv,
  RGBA_ASTC_4x4_Format: Tv,
  RGBA_ASTC_5x4_Format: Av,
  RGBA_ASTC_5x5_Format: Cv,
  RGBA_ASTC_6x5_Format: Rv,
  RGBA_ASTC_6x6_Format: Pv,
  RGBA_ASTC_8x5_Format: bv,
  RGBA_ASTC_8x6_Format: Lv,
  RGBA_ASTC_8x8_Format: Iv,
  RGBA_BPTC_Format: Ed,
  RGBA_ETC2_EAC_Format: Ev,
  RGBA_PVRTC_2BPPV1_Format: Mv,
  RGBA_PVRTC_4BPPV1_Format: Sv,
  RGBA_S3TC_DXT1_Format: Sd,
  RGBA_S3TC_DXT3_Format: Md,
  RGBA_S3TC_DXT5_Format: wd,
  RGB_ETC1_Format: SA,
  RGB_ETC2_Format: wv,
  RGB_PVRTC_2BPPV1_Format: xv,
  RGB_PVRTC_4BPPV1_Format: _v,
  RGB_S3TC_DXT1_Format: xd,
  RGFormat: xA,
  RGIntegerFormat: o_,
  RawShaderMaterial: _2,
  Ray: ma,
  Raycaster: W2,
  RectAreaLight: k2,
  RedFormat: _A,
  RedIntegerFormat: s_,
  ReinhardToneMapping: fA,
  RepeatWrapping: Ec,
  ReplaceStencilOp: Yb,
  ReverseSubtractEquation: XT,
  RingGeometry: Vp,
  SIGNED_RED_GREEN_RGTC2_Format: Hv,
  SIGNED_RED_RGTC1_Format: zv,
  SRGBColorSpace: pt,
  Scene: x_,
  ShaderChunk: gt,
  ShaderLib: mr,
  ShaderMaterial: Wr,
  ShadowMaterial: y2,
  Shape: ia,
  ShapeGeometry: Gp,
  ShapePath: Mk,
  ShapeUtils: Gr,
  ShortType: mA,
  Skeleton: Ip,
  SkeletonHelper: uk,
  SkinnedMesh: r2,
  Source: Ko,
  Sphere: wr,
  SphereGeometry: Qc,
  Spherical: Qv,
  SphericalHarmonics3: F2,
  SplineCurve: P_,
  SpotLight: N2,
  SpotLightHelper: lk,
  Sprite: n2,
  SpriteMaterial: S_,
  SrcAlphaFactor: Qy,
  SrcAlphaSaturateFactor: eA,
  SrcColorFactor: qT,
  StaticCopyUsage: fL,
  StaticDrawUsage: Pc,
  StaticReadUsage: lL,
  StereoCamera: kO,
  StreamCopyUsage: dL,
  StreamDrawUsage: aL,
  StreamReadUsage: cL,
  StringKeyframeTrack: ya,
  SubtractEquation: WT,
  SubtractiveBlending: mv,
  TOUCH: Ho,
  TangentSpaceNormalMap: go,
  TetrahedronGeometry: Wp,
  Texture: mn,
  TextureLoader: CO,
  TorusGeometry: Xp,
  TorusKnotGeometry: jp,
  Triangle: gi,
  TriangleFanDrawMode: Xb,
  TriangleStripDrawMode: Wb,
  TrianglesDrawMode: Gb,
  TubeGeometry: Yp,
  TwoPassDoubleSide: Fb,
  UVMapping: wp,
  Uint16BufferAttribute: p_,
  Uint32BufferAttribute: m_,
  Uint8BufferAttribute: JL,
  Uint8ClampedBufferAttribute: QL,
  Uniform: V_,
  UniformsGroup: nk,
  UniformsLib: Le,
  UniformsUtils: GA,
  UnsignedByteType: Hr,
  UnsignedInt248Type: no,
  UnsignedIntType: ms,
  UnsignedShort4444Type: i_,
  UnsignedShort5551Type: r_,
  UnsignedShortType: Ep,
  VSMShadowMap: hr,
  Vector2: me,
  Vector3: D,
  Vector4: kt,
  VectorKeyframeTrack: kc,
  VideoTexture: BU,
  WebGL1Renderer: e2,
  WebGL3DRenderTarget: FL,
  WebGLArrayRenderTarget: kL,
  WebGLCoordinateSystem: Fr,
  WebGLCubeRenderTarget: XA,
  WebGLMultipleRenderTargets: zL,
  WebGLRenderTarget: Mr,
  WebGLRenderer: __,
  WebGLUtils: JA,
  WebGPUCoordinateSystem: bc,
  WireframeGeometry: v2,
  WrapAroundEnding: Rc,
  ZeroCurvatureEnding: qo,
  ZeroFactor: jT,
  ZeroSlopeEnding: Zo,
  ZeroStencilOp: jb,
  _SRGBAFormat: tp,
  sRGBEncoding: ro
}, Symbol.toStringTag, { value: "Module" }));
var j2 = { exports: {} }, _a = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
_a.ConcurrentRoot = 1;
_a.ContinuousEventPriority = 4;
_a.DefaultEventPriority = 16;
_a.DiscreteEventPriority = 1;
_a.IdleEventPriority = 536870912;
_a.LegacyRoot = 0;
j2.exports = _a;
var El = j2.exports;
function Ek(n) {
  let e;
  const t = /* @__PURE__ */ new Set(), i = (f, h) => {
    const d = typeof f == "function" ? f(e) : f;
    if (d !== e) {
      const m = e;
      e = h ? d : Object.assign({}, e, d), t.forEach((v) => v(e, m));
    }
  }, r = () => e, s = (f, h = r, d = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let m = h(e);
    function v() {
      const _ = h(e);
      if (!d(m, _)) {
        const w = m;
        f(m = _, w);
      }
    }
    return t.add(v), () => t.delete(v);
  }, c = { setState: i, getState: r, subscribe: (f, h, d) => h || d ? s(f, h, d) : (t.add(f), () => t.delete(f)), destroy: () => t.clear() };
  return e = n(i, r, c), c;
}
const Tk = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), aw = Tk ? xe.useEffect : xe.useLayoutEffect;
function Ak(n) {
  const e = typeof n == "function" ? Ek(n) : n, t = (i = e.getState, r = Object.is) => {
    const [, s] = xe.useReducer((M) => M + 1, 0), o = e.getState(), l = xe.useRef(o), c = xe.useRef(i), f = xe.useRef(r), h = xe.useRef(!1), d = xe.useRef();
    d.current === void 0 && (d.current = i(o));
    let m, v = !1;
    (l.current !== o || c.current !== i || f.current !== r || h.current) && (m = i(o), v = !r(d.current, m)), aw(() => {
      v && (d.current = m), l.current = o, c.current = i, f.current = r, h.current = !1;
    });
    const _ = xe.useRef(o);
    aw(() => {
      const M = () => {
        try {
          const x = e.getState(), S = c.current(x);
          f.current(d.current, S) || (l.current = x, d.current = S, s());
        } catch {
          h.current = !0, s();
        }
      }, g = e.subscribe(M);
      return e.getState() !== _.current && M(), g;
    }, []);
    const w = v ? m : d.current;
    return xe.useDebugValue(w), w;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const i = [t, e];
    return {
      next() {
        const r = i.length <= 0;
        return { value: i.shift(), done: r };
      }
    };
  }, t;
}
var Y2 = { exports: {} }, q2 = { exports: {} }, Z2 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
  function e(O, X) {
    var W = O.length;
    O.push(X);
    e:
      for (; 0 < W; ) {
        var V = W - 1 >>> 1, j = O[V];
        if (0 < r(j, X))
          O[V] = X, O[W] = j, W = V;
        else
          break e;
      }
  }
  function t(O) {
    return O.length === 0 ? null : O[0];
  }
  function i(O) {
    if (O.length === 0)
      return null;
    var X = O[0], W = O.pop();
    if (W !== X) {
      O[0] = W;
      e:
        for (var V = 0, j = O.length, de = j >>> 1; V < de; ) {
          var ye = 2 * (V + 1) - 1, Te = O[ye], Ie = ye + 1, Be = O[Ie];
          if (0 > r(Te, W))
            Ie < j && 0 > r(Be, Te) ? (O[V] = Be, O[Ie] = W, V = Ie) : (O[V] = Te, O[ye] = W, V = ye);
          else if (Ie < j && 0 > r(Be, W))
            O[V] = Be, O[Ie] = W, V = Ie;
          else
            break e;
        }
    }
    return X;
  }
  function r(O, X) {
    var W = O.sortIndex - X.sortIndex;
    return W !== 0 ? W : O.id - X.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function() {
      return s.now();
    };
  } else {
    var o = Date, l = o.now();
    n.unstable_now = function() {
      return o.now() - l;
    };
  }
  var c = [], f = [], h = 1, d = null, m = 3, v = !1, _ = !1, w = !1, M = typeof setTimeout == "function" ? setTimeout : null, g = typeof clearTimeout == "function" ? clearTimeout : null, x = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(O) {
    for (var X = t(f); X !== null; ) {
      if (X.callback === null)
        i(f);
      else if (X.startTime <= O)
        i(f), X.sortIndex = X.expirationTime, e(c, X);
      else
        break;
      X = t(f);
    }
  }
  function T(O) {
    if (w = !1, S(O), !_)
      if (t(c) !== null)
        _ = !0, oe(C);
      else {
        var X = t(f);
        X !== null && ne(T, X.startTime - O);
      }
  }
  function C(O, X) {
    _ = !1, w && (w = !1, g(N), N = -1), v = !0;
    var W = m;
    try {
      for (S(X), d = t(c); d !== null && (!(d.expirationTime > X) || O && !G()); ) {
        var V = d.callback;
        if (typeof V == "function") {
          d.callback = null, m = d.priorityLevel;
          var j = V(d.expirationTime <= X);
          X = n.unstable_now(), typeof j == "function" ? d.callback = j : d === t(c) && i(c), S(X);
        } else
          i(c);
        d = t(c);
      }
      if (d !== null)
        var de = !0;
      else {
        var ye = t(f);
        ye !== null && ne(T, ye.startTime - X), de = !1;
      }
      return de;
    } finally {
      d = null, m = W, v = !1;
    }
  }
  var P = !1, L = null, N = -1, R = 5, b = -1;
  function G() {
    return !(n.unstable_now() - b < R);
  }
  function $() {
    if (L !== null) {
      var O = n.unstable_now();
      b = O;
      var X = !0;
      try {
        X = L(!0, O);
      } finally {
        X ? Y() : (P = !1, L = null);
      }
    } else
      P = !1;
  }
  var Y;
  if (typeof x == "function")
    Y = function() {
      x($);
    };
  else if (typeof MessageChannel < "u") {
    var K = new MessageChannel(), J = K.port2;
    K.port1.onmessage = $, Y = function() {
      J.postMessage(null);
    };
  } else
    Y = function() {
      M($, 0);
    };
  function oe(O) {
    L = O, P || (P = !0, Y());
  }
  function ne(O, X) {
    N = M(function() {
      O(n.unstable_now());
    }, X);
  }
  n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(O) {
    O.callback = null;
  }, n.unstable_continueExecution = function() {
    _ || v || (_ = !0, oe(C));
  }, n.unstable_forceFrameRate = function(O) {
    0 > O || 125 < O ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : R = 0 < O ? Math.floor(1e3 / O) : 5;
  }, n.unstable_getCurrentPriorityLevel = function() {
    return m;
  }, n.unstable_getFirstCallbackNode = function() {
    return t(c);
  }, n.unstable_next = function(O) {
    switch (m) {
      case 1:
      case 2:
      case 3:
        var X = 3;
        break;
      default:
        X = m;
    }
    var W = m;
    m = X;
    try {
      return O();
    } finally {
      m = W;
    }
  }, n.unstable_pauseExecution = function() {
  }, n.unstable_requestPaint = function() {
  }, n.unstable_runWithPriority = function(O, X) {
    switch (O) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        O = 3;
    }
    var W = m;
    m = O;
    try {
      return X();
    } finally {
      m = W;
    }
  }, n.unstable_scheduleCallback = function(O, X, W) {
    var V = n.unstable_now();
    switch (typeof W == "object" && W !== null ? (W = W.delay, W = typeof W == "number" && 0 < W ? V + W : V) : W = V, O) {
      case 1:
        var j = -1;
        break;
      case 2:
        j = 250;
        break;
      case 5:
        j = 1073741823;
        break;
      case 4:
        j = 1e4;
        break;
      default:
        j = 5e3;
    }
    return j = W + j, O = { id: h++, callback: X, priorityLevel: O, startTime: W, expirationTime: j, sortIndex: -1 }, W > V ? (O.sortIndex = W, e(f, O), t(c) === null && O === t(f) && (w ? (g(N), N = -1) : w = !0, ne(T, W - V))) : (O.sortIndex = j, e(c, O), _ || v || (_ = !0, oe(C))), O;
  }, n.unstable_shouldYield = G, n.unstable_wrapCallback = function(O) {
    var X = m;
    return function() {
      var W = m;
      m = X;
      try {
        return O.apply(this, arguments);
      } finally {
        m = W;
      }
    };
  };
})(Z2);
q2.exports = Z2;
var $v = q2.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ck = function(e) {
  var t = {}, i = xe, r = $v, s = Object.assign;
  function o(a) {
    for (var u = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, p = 1; p < arguments.length; p++)
      u += "&args[]=" + encodeURIComponent(arguments[p]);
    return "Minified React error #" + a + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var l = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, c = Symbol.for("react.element"), f = Symbol.for("react.portal"), h = Symbol.for("react.fragment"), d = Symbol.for("react.strict_mode"), m = Symbol.for("react.profiler"), v = Symbol.for("react.provider"), _ = Symbol.for("react.context"), w = Symbol.for("react.forward_ref"), M = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), x = Symbol.for("react.memo"), S = Symbol.for("react.lazy"), T = Symbol.for("react.offscreen"), C = Symbol.iterator;
  function P(a) {
    return a === null || typeof a != "object" ? null : (a = C && a[C] || a["@@iterator"], typeof a == "function" ? a : null);
  }
  function L(a) {
    if (a == null)
      return null;
    if (typeof a == "function")
      return a.displayName || a.name || null;
    if (typeof a == "string")
      return a;
    switch (a) {
      case h:
        return "Fragment";
      case f:
        return "Portal";
      case m:
        return "Profiler";
      case d:
        return "StrictMode";
      case M:
        return "Suspense";
      case g:
        return "SuspenseList";
    }
    if (typeof a == "object")
      switch (a.$$typeof) {
        case _:
          return (a.displayName || "Context") + ".Consumer";
        case v:
          return (a._context.displayName || "Context") + ".Provider";
        case w:
          var u = a.render;
          return a = a.displayName, a || (a = u.displayName || u.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
        case x:
          return u = a.displayName || null, u !== null ? u : L(a.type) || "Memo";
        case S:
          u = a._payload, a = a._init;
          try {
            return L(a(u));
          } catch {
          }
      }
    return null;
  }
  function N(a) {
    var u = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (u.displayName || "Context") + ".Consumer";
      case 10:
        return (u._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = u.render, a = a.displayName || a.name || "", u.displayName || (a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return u;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return L(u);
      case 8:
        return u === d ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof u == "function")
          return u.displayName || u.name || null;
        if (typeof u == "string")
          return u;
    }
    return null;
  }
  function R(a) {
    var u = a, p = a;
    if (a.alternate)
      for (; u.return; )
        u = u.return;
    else {
      a = u;
      do
        u = a, u.flags & 4098 && (p = u.return), a = u.return;
      while (a);
    }
    return u.tag === 3 ? p : null;
  }
  function b(a) {
    if (R(a) !== a)
      throw Error(o(188));
  }
  function G(a) {
    var u = a.alternate;
    if (!u) {
      if (u = R(a), u === null)
        throw Error(o(188));
      return u !== a ? null : a;
    }
    for (var p = a, y = u; ; ) {
      var E = p.return;
      if (E === null)
        break;
      var A = E.alternate;
      if (A === null) {
        if (y = E.return, y !== null) {
          p = y;
          continue;
        }
        break;
      }
      if (E.child === A.child) {
        for (A = E.child; A; ) {
          if (A === p)
            return b(E), a;
          if (A === y)
            return b(E), u;
          A = A.sibling;
        }
        throw Error(o(188));
      }
      if (p.return !== y.return)
        p = E, y = A;
      else {
        for (var k = !1, q = E.child; q; ) {
          if (q === p) {
            k = !0, p = E, y = A;
            break;
          }
          if (q === y) {
            k = !0, y = E, p = A;
            break;
          }
          q = q.sibling;
        }
        if (!k) {
          for (q = A.child; q; ) {
            if (q === p) {
              k = !0, p = A, y = E;
              break;
            }
            if (q === y) {
              k = !0, y = A, p = E;
              break;
            }
            q = q.sibling;
          }
          if (!k)
            throw Error(o(189));
        }
      }
      if (p.alternate !== y)
        throw Error(o(190));
    }
    if (p.tag !== 3)
      throw Error(o(188));
    return p.stateNode.current === p ? a : u;
  }
  function $(a) {
    return a = G(a), a !== null ? Y(a) : null;
  }
  function Y(a) {
    if (a.tag === 5 || a.tag === 6)
      return a;
    for (a = a.child; a !== null; ) {
      var u = Y(a);
      if (u !== null)
        return u;
      a = a.sibling;
    }
    return null;
  }
  function K(a) {
    if (a.tag === 5 || a.tag === 6)
      return a;
    for (a = a.child; a !== null; ) {
      if (a.tag !== 4) {
        var u = K(a);
        if (u !== null)
          return u;
      }
      a = a.sibling;
    }
    return null;
  }
  var J = Array.isArray, oe = e.getPublicInstance, ne = e.getRootHostContext, O = e.getChildHostContext, X = e.prepareForCommit, W = e.resetAfterCommit, V = e.createInstance, j = e.appendInitialChild, de = e.finalizeInitialChildren, ye = e.prepareUpdate, Te = e.shouldSetTextContent, Ie = e.createTextInstance, Be = e.scheduleTimeout, je = e.cancelTimeout, vt = e.noTimeout, lt = e.isPrimaryRenderer, Re = e.supportsMutation, z = e.supportsPersistence, ge = e.supportsHydration, fe = e.getInstanceFromNode, Se = e.preparePortalMount, ve = e.getCurrentEventPriority, He = e.detachDeletedInstance, Oe = e.supportsMicrotasks, Fe = e.scheduleMicrotask, Je = e.supportsTestSelectors, mt = e.findFiberRoot, Ut = e.getBoundingRect, F = e.getTextContent, I = e.isHiddenSubtree, ae = e.matchAccessibilityRole, we = e.setFocusIfFocusable, _e = e.setupIntersectionObserver, Pe = e.appendChild, qe = e.appendChildToContainer, be = e.commitTextUpdate, ue = e.commitMount, Qe = e.commitUpdate, $e = e.insertBefore, et = e.insertInContainerBefore, Ve = e.removeChild, B = e.removeChildFromContainer, pe = e.resetTextContent, Ne = e.hideInstance, H = e.hideTextInstance, Me = e.unhideInstance, ie = e.unhideTextInstance, Ae = e.clearContainer, De = e.cloneInstance, Et = e.createContainerChildSet, At = e.appendChildToContainerChildSet, Dt = e.finalizeContainerChildren, Sn = e.replaceContainerChildren, Nt = e.cloneHiddenInstance, Mn = e.cloneHiddenTextInstance, nn = e.canHydrateInstance, nf = e.canHydrateTextInstance, rf = e.canHydrateSuspenseInstance, sf = e.isSuspenseInstancePending, As = e.isSuspenseInstanceFallback, of = e.registerSuspenseInstanceRetry, Ar = e.getNextHydratableSibling, af = e.getFirstHydratableChild, Jp = e.getFirstHydratableChildWithinContainer, Qp = e.getFirstHydratableChildWithinSuspenseInstance, $p = e.hydrateInstance, U = e.hydrateTextInstance, te = e.hydrateSuspenseInstance, ce = e.getNextHydratableInstanceAfterSuspenseInstance, Q = e.commitHydratedContainer, he = e.commitHydratedSuspenseInstance, We = e.clearSuspenseBoundary, tt = e.clearSuspenseBoundaryFromContainer, rt = e.shouldDeleteUnhydratedTailInstances, st = e.didNotMatchHydratedContainerTextInstance, St = e.didNotMatchHydratedTextInstance, ot;
  function at(a) {
    if (ot === void 0)
      try {
        throw Error();
      } catch (p) {
        var u = p.stack.trim().match(/\n( *(at )?)/);
        ot = u && u[1] || "";
      }
    return `
` + ot + a;
  }
  var Vt = !1;
  function Wt(a, u) {
    if (!a || Vt)
      return "";
    Vt = !0;
    var p = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (u)
        if (u = function() {
          throw Error();
        }, Object.defineProperty(u.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(u, []);
          } catch (Ce) {
            var y = Ce;
          }
          Reflect.construct(a, [], u);
        } else {
          try {
            u.call();
          } catch (Ce) {
            y = Ce;
          }
          a.call(u.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Ce) {
          y = Ce;
        }
        a();
      }
    } catch (Ce) {
      if (Ce && y && typeof Ce.stack == "string") {
        for (var E = Ce.stack.split(`
`), A = y.stack.split(`
`), k = E.length - 1, q = A.length - 1; 1 <= k && 0 <= q && E[k] !== A[q]; )
          q--;
        for (; 1 <= k && 0 <= q; k--, q--)
          if (E[k] !== A[q]) {
            if (k !== 1 || q !== 1)
              do
                if (k--, q--, 0 > q || E[k] !== A[q]) {
                  var le = `
` + E[k].replace(" at new ", " at ");
                  return a.displayName && le.includes("<anonymous>") && (le = le.replace("<anonymous>", a.displayName)), le;
                }
              while (1 <= k && 0 <= q);
            break;
          }
      }
    } finally {
      Vt = !1, Error.prepareStackTrace = p;
    }
    return (a = a ? a.displayName || a.name : "") ? at(a) : "";
  }
  var wi = Object.prototype.hasOwnProperty, Ei = [], zt = -1;
  function ct(a) {
    return { current: a };
  }
  function Ot(a) {
    0 > zt || (a.current = Ei[zt], Ei[zt] = null, zt--);
  }
  function ut(a, u) {
    zt++, Ei[zt] = a.current, a.current = u;
  }
  var Bn = {}, wn = ct(Bn), gn = ct(!1), ir = Bn;
  function rn(a, u) {
    var p = a.type.contextTypes;
    if (!p)
      return Bn;
    var y = a.stateNode;
    if (y && y.__reactInternalMemoizedUnmaskedChildContext === u)
      return y.__reactInternalMemoizedMaskedChildContext;
    var E = {}, A;
    for (A in p)
      E[A] = u[A];
    return y && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = u, a.__reactInternalMemoizedMaskedChildContext = E), E;
  }
  function sn(a) {
    return a = a.childContextTypes, a != null;
  }
  function Cs() {
    Ot(gn), Ot(wn);
  }
  function Hn(a, u, p) {
    if (wn.current !== Bn)
      throw Error(o(168));
    ut(wn, u), ut(gn, p);
  }
  function xa(a, u, p) {
    var y = a.stateNode;
    if (u = u.childContextTypes, typeof y.getChildContext != "function")
      return p;
    y = y.getChildContext();
    for (var E in y)
      if (!(E in u))
        throw Error(o(108, N(a) || "Unknown", E));
    return s({}, p, y);
  }
  function Sa(a) {
    return a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Bn, ir = wn.current, ut(wn, a), ut(gn, gn.current), !0;
  }
  function Ql(a, u, p) {
    var y = a.stateNode;
    if (!y)
      throw Error(o(169));
    p ? (a = xa(a, u, ir), y.__reactInternalMemoizedMergedChildContext = a, Ot(gn), Ot(wn), ut(wn, a)) : Ot(gn), ut(gn, p);
  }
  var rr = Math.clz32 ? Math.clz32 : mC, dC = Math.log, pC = Math.LN2;
  function mC(a) {
    return a >>>= 0, a === 0 ? 32 : 31 - (dC(a) / pC | 0) | 0;
  }
  var lf = 64, uf = 4194304;
  function $l(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function cf(a, u) {
    var p = a.pendingLanes;
    if (p === 0)
      return 0;
    var y = 0, E = a.suspendedLanes, A = a.pingedLanes, k = p & 268435455;
    if (k !== 0) {
      var q = k & ~E;
      q !== 0 ? y = $l(q) : (A &= k, A !== 0 && (y = $l(A)));
    } else
      k = p & ~E, k !== 0 ? y = $l(k) : A !== 0 && (y = $l(A));
    if (y === 0)
      return 0;
    if (u !== 0 && u !== y && !(u & E) && (E = y & -y, A = u & -u, E >= A || E === 16 && (A & 4194240) !== 0))
      return u;
    if (y & 4 && (y |= p & 16), u = a.entangledLanes, u !== 0)
      for (a = a.entanglements, u &= y; 0 < u; )
        p = 31 - rr(u), E = 1 << p, y |= a[p], u &= ~E;
    return y;
  }
  function gC(a, u) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return u + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return u + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function vC(a, u) {
    for (var p = a.suspendedLanes, y = a.pingedLanes, E = a.expirationTimes, A = a.pendingLanes; 0 < A; ) {
      var k = 31 - rr(A), q = 1 << k, le = E[k];
      le === -1 ? (!(q & p) || q & y) && (E[k] = gC(q, u)) : le <= u && (a.expiredLanes |= q), A &= ~q;
    }
  }
  function em(a) {
    return a = a.pendingLanes & -1073741825, a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function tm(a) {
    for (var u = [], p = 0; 31 > p; p++)
      u.push(a);
    return u;
  }
  function eu(a, u, p) {
    a.pendingLanes |= u, u !== 536870912 && (a.suspendedLanes = 0, a.pingedLanes = 0), a = a.eventTimes, u = 31 - rr(u), a[u] = p;
  }
  function yC(a, u) {
    var p = a.pendingLanes & ~u;
    a.pendingLanes = u, a.suspendedLanes = 0, a.pingedLanes = 0, a.expiredLanes &= u, a.mutableReadLanes &= u, a.entangledLanes &= u, u = a.entanglements;
    var y = a.eventTimes;
    for (a = a.expirationTimes; 0 < p; ) {
      var E = 31 - rr(p), A = 1 << E;
      u[E] = 0, y[E] = -1, a[E] = -1, p &= ~A;
    }
  }
  function nm(a, u) {
    var p = a.entangledLanes |= u;
    for (a = a.entanglements; p; ) {
      var y = 31 - rr(p), E = 1 << y;
      E & u | a[y] & u && (a[y] |= u), p &= ~E;
    }
  }
  var Pt = 0;
  function j_(a) {
    return a &= -a, 1 < a ? 4 < a ? a & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var im = r.unstable_scheduleCallback, Y_ = r.unstable_cancelCallback, _C = r.unstable_shouldYield, xC = r.unstable_requestPaint, Pn = r.unstable_now, rm = r.unstable_ImmediatePriority, SC = r.unstable_UserBlockingPriority, sm = r.unstable_NormalPriority, MC = r.unstable_IdlePriority, ff = null, Cr = null;
  function wC(a) {
    if (Cr && typeof Cr.onCommitFiberRoot == "function")
      try {
        Cr.onCommitFiberRoot(ff, a, void 0, (a.current.flags & 128) === 128);
      } catch {
      }
  }
  function EC(a, u) {
    return a === u && (a !== 0 || 1 / a === 1 / u) || a !== a && u !== u;
  }
  var Rr = typeof Object.is == "function" ? Object.is : EC, qr = null, hf = !1, om = !1;
  function q_(a) {
    qr === null ? qr = [a] : qr.push(a);
  }
  function TC(a) {
    hf = !0, q_(a);
  }
  function Pr() {
    if (!om && qr !== null) {
      om = !0;
      var a = 0, u = Pt;
      try {
        var p = qr;
        for (Pt = 1; a < p.length; a++) {
          var y = p[a];
          do
            y = y(!0);
          while (y !== null);
        }
        qr = null, hf = !1;
      } catch (E) {
        throw qr !== null && (qr = qr.slice(a + 1)), im(rm, Pr), E;
      } finally {
        Pt = u, om = !1;
      }
    }
    return null;
  }
  var AC = l.ReactCurrentBatchConfig;
  function df(a, u) {
    if (Rr(a, u))
      return !0;
    if (typeof a != "object" || a === null || typeof u != "object" || u === null)
      return !1;
    var p = Object.keys(a), y = Object.keys(u);
    if (p.length !== y.length)
      return !1;
    for (y = 0; y < p.length; y++) {
      var E = p[y];
      if (!wi.call(u, E) || !Rr(a[E], u[E]))
        return !1;
    }
    return !0;
  }
  function CC(a) {
    switch (a.tag) {
      case 5:
        return at(a.type);
      case 16:
        return at("Lazy");
      case 13:
        return at("Suspense");
      case 19:
        return at("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = Wt(a.type, !1), a;
      case 11:
        return a = Wt(a.type.render, !1), a;
      case 1:
        return a = Wt(a.type, !0), a;
      default:
        return "";
    }
  }
  function sr(a, u) {
    if (a && a.defaultProps) {
      u = s({}, u), a = a.defaultProps;
      for (var p in a)
        u[p] === void 0 && (u[p] = a[p]);
      return u;
    }
    return u;
  }
  var pf = ct(null), mf = null, Ma = null, am = null;
  function lm() {
    am = Ma = mf = null;
  }
  function Z_(a, u, p) {
    lt ? (ut(pf, u._currentValue), u._currentValue = p) : (ut(pf, u._currentValue2), u._currentValue2 = p);
  }
  function um(a) {
    var u = pf.current;
    Ot(pf), lt ? a._currentValue = u : a._currentValue2 = u;
  }
  function cm(a, u, p) {
    for (; a !== null; ) {
      var y = a.alternate;
      if ((a.childLanes & u) !== u ? (a.childLanes |= u, y !== null && (y.childLanes |= u)) : y !== null && (y.childLanes & u) !== u && (y.childLanes |= u), a === p)
        break;
      a = a.return;
    }
  }
  function wa(a, u) {
    mf = a, am = Ma = null, a = a.dependencies, a !== null && a.firstContext !== null && (a.lanes & u && (Ci = !0), a.firstContext = null);
  }
  function Bi(a) {
    var u = lt ? a._currentValue : a._currentValue2;
    if (am !== a)
      if (a = { context: a, memoizedValue: u, next: null }, Ma === null) {
        if (mf === null)
          throw Error(o(308));
        Ma = a, mf.dependencies = { lanes: 0, firstContext: a };
      } else
        Ma = Ma.next = a;
    return u;
  }
  var br = null, Rs = !1;
  function fm(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function K_(a, u) {
    a = a.updateQueue, u.updateQueue === a && (u.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function Zr(a, u) {
    return { eventTime: a, lane: u, tag: 0, payload: null, callback: null, next: null };
  }
  function Ps(a, u) {
    var p = a.updateQueue;
    p !== null && (p = p.shared, vn !== null && a.mode & 1 && !(Mt & 2) ? (a = p.interleaved, a === null ? (u.next = u, br === null ? br = [p] : br.push(p)) : (u.next = a.next, a.next = u), p.interleaved = u) : (a = p.pending, a === null ? u.next = u : (u.next = a.next, a.next = u), p.pending = u));
  }
  function gf(a, u, p) {
    if (u = u.updateQueue, u !== null && (u = u.shared, (p & 4194240) !== 0)) {
      var y = u.lanes;
      y &= a.pendingLanes, p |= y, u.lanes = p, nm(a, p);
    }
  }
  function J_(a, u) {
    var p = a.updateQueue, y = a.alternate;
    if (y !== null && (y = y.updateQueue, p === y)) {
      var E = null, A = null;
      if (p = p.firstBaseUpdate, p !== null) {
        do {
          var k = { eventTime: p.eventTime, lane: p.lane, tag: p.tag, payload: p.payload, callback: p.callback, next: null };
          A === null ? E = A = k : A = A.next = k, p = p.next;
        } while (p !== null);
        A === null ? E = A = u : A = A.next = u;
      } else
        E = A = u;
      p = { baseState: y.baseState, firstBaseUpdate: E, lastBaseUpdate: A, shared: y.shared, effects: y.effects }, a.updateQueue = p;
      return;
    }
    a = p.lastBaseUpdate, a === null ? p.firstBaseUpdate = u : a.next = u, p.lastBaseUpdate = u;
  }
  function vf(a, u, p, y) {
    var E = a.updateQueue;
    Rs = !1;
    var A = E.firstBaseUpdate, k = E.lastBaseUpdate, q = E.shared.pending;
    if (q !== null) {
      E.shared.pending = null;
      var le = q, Ce = le.next;
      le.next = null, k === null ? A = Ce : k.next = Ce, k = le;
      var Xe = a.alternate;
      Xe !== null && (Xe = Xe.updateQueue, q = Xe.lastBaseUpdate, q !== k && (q === null ? Xe.firstBaseUpdate = Ce : q.next = Ce, Xe.lastBaseUpdate = le));
    }
    if (A !== null) {
      var ft = E.baseState;
      k = 0, Xe = Ce = le = null, q = A;
      do {
        var nt = q.lane, Bt = q.eventTime;
        if ((y & nt) === nt) {
          Xe !== null && (Xe = Xe.next = {
            eventTime: Bt,
            lane: 0,
            tag: q.tag,
            payload: q.payload,
            callback: q.callback,
            next: null
          });
          e: {
            var Ke = a, Xn = q;
            switch (nt = u, Bt = p, Xn.tag) {
              case 1:
                if (Ke = Xn.payload, typeof Ke == "function") {
                  ft = Ke.call(Bt, ft, nt);
                  break e;
                }
                ft = Ke;
                break e;
              case 3:
                Ke.flags = Ke.flags & -65537 | 128;
              case 0:
                if (Ke = Xn.payload, nt = typeof Ke == "function" ? Ke.call(Bt, ft, nt) : Ke, nt == null)
                  break e;
                ft = s({}, ft, nt);
                break e;
              case 2:
                Rs = !0;
            }
          }
          q.callback !== null && q.lane !== 0 && (a.flags |= 64, nt = E.effects, nt === null ? E.effects = [q] : nt.push(q));
        } else
          Bt = { eventTime: Bt, lane: nt, tag: q.tag, payload: q.payload, callback: q.callback, next: null }, Xe === null ? (Ce = Xe = Bt, le = ft) : Xe = Xe.next = Bt, k |= nt;
        if (q = q.next, q === null) {
          if (q = E.shared.pending, q === null)
            break;
          nt = q, q = nt.next, nt.next = null, E.lastBaseUpdate = nt, E.shared.pending = null;
        }
      } while (1);
      if (Xe === null && (le = ft), E.baseState = le, E.firstBaseUpdate = Ce, E.lastBaseUpdate = Xe, u = E.shared.interleaved, u !== null) {
        E = u;
        do
          k |= E.lane, E = E.next;
        while (E !== u);
      } else
        A === null && (E.shared.lanes = 0);
      Ia |= k, a.lanes = k, a.memoizedState = ft;
    }
  }
  function Q_(a, u, p) {
    if (a = u.effects, u.effects = null, a !== null)
      for (u = 0; u < a.length; u++) {
        var y = a[u], E = y.callback;
        if (E !== null) {
          if (y.callback = null, y = p, typeof E != "function")
            throw Error(o(191, E));
          E.call(y);
        }
      }
  }
  var $_ = new i.Component().refs;
  function hm(a, u, p, y) {
    u = a.memoizedState, p = p(y, u), p = p == null ? u : s({}, u, p), a.memoizedState = p, a.lanes === 0 && (a.updateQueue.baseState = p);
  }
  var yf = { isMounted: function(a) {
    return (a = a._reactInternals) ? R(a) === a : !1;
  }, enqueueSetState: function(a, u, p) {
    a = a._reactInternals;
    var y = ni(), E = Is(a), A = Zr(y, E);
    A.payload = u, p != null && (A.callback = p), Ps(a, A), u = Xi(a, E, y), u !== null && gf(u, a, E);
  }, enqueueReplaceState: function(a, u, p) {
    a = a._reactInternals;
    var y = ni(), E = Is(a), A = Zr(y, E);
    A.tag = 1, A.payload = u, p != null && (A.callback = p), Ps(a, A), u = Xi(a, E, y), u !== null && gf(u, a, E);
  }, enqueueForceUpdate: function(a, u) {
    a = a._reactInternals;
    var p = ni(), y = Is(a), E = Zr(
      p,
      y
    );
    E.tag = 2, u != null && (E.callback = u), Ps(a, E), u = Xi(a, y, p), u !== null && gf(u, a, y);
  } };
  function ex(a, u, p, y, E, A, k) {
    return a = a.stateNode, typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(y, A, k) : u.prototype && u.prototype.isPureReactComponent ? !df(p, y) || !df(E, A) : !0;
  }
  function tx(a, u, p) {
    var y = !1, E = Bn, A = u.contextType;
    return typeof A == "object" && A !== null ? A = Bi(A) : (E = sn(u) ? ir : wn.current, y = u.contextTypes, A = (y = y != null) ? rn(a, E) : Bn), u = new u(p, A), a.memoizedState = u.state !== null && u.state !== void 0 ? u.state : null, u.updater = yf, a.stateNode = u, u._reactInternals = a, y && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = E, a.__reactInternalMemoizedMaskedChildContext = A), u;
  }
  function nx(a, u, p, y) {
    a = u.state, typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps(p, y), typeof u.UNSAFE_componentWillReceiveProps == "function" && u.UNSAFE_componentWillReceiveProps(p, y), u.state !== a && yf.enqueueReplaceState(u, u.state, null);
  }
  function dm(a, u, p, y) {
    var E = a.stateNode;
    E.props = p, E.state = a.memoizedState, E.refs = $_, fm(a);
    var A = u.contextType;
    typeof A == "object" && A !== null ? E.context = Bi(A) : (A = sn(u) ? ir : wn.current, E.context = rn(a, A)), E.state = a.memoizedState, A = u.getDerivedStateFromProps, typeof A == "function" && (hm(a, u, A, p), E.state = a.memoizedState), typeof u.getDerivedStateFromProps == "function" || typeof E.getSnapshotBeforeUpdate == "function" || typeof E.UNSAFE_componentWillMount != "function" && typeof E.componentWillMount != "function" || (u = E.state, typeof E.componentWillMount == "function" && E.componentWillMount(), typeof E.UNSAFE_componentWillMount == "function" && E.UNSAFE_componentWillMount(), u !== E.state && yf.enqueueReplaceState(E, E.state, null), vf(a, p, E, y), E.state = a.memoizedState), typeof E.componentDidMount == "function" && (a.flags |= 4194308);
  }
  var Ea = [], Ta = 0, _f = null, xf = 0, Hi = [], Vi = 0, xo = null, Kr = 1, Jr = "";
  function So(a, u) {
    Ea[Ta++] = xf, Ea[Ta++] = _f, _f = a, xf = u;
  }
  function ix(a, u, p) {
    Hi[Vi++] = Kr, Hi[Vi++] = Jr, Hi[Vi++] = xo, xo = a;
    var y = Kr;
    a = Jr;
    var E = 32 - rr(y) - 1;
    y &= ~(1 << E), p += 1;
    var A = 32 - rr(u) + E;
    if (30 < A) {
      var k = E - E % 5;
      A = (y & (1 << k) - 1).toString(32), y >>= k, E -= k, Kr = 1 << 32 - rr(u) + E | p << E | y, Jr = A + a;
    } else
      Kr = 1 << A | p << E | y, Jr = a;
  }
  function pm(a) {
    a.return !== null && (So(a, 1), ix(a, 1, 0));
  }
  function mm(a) {
    for (; a === _f; )
      _f = Ea[--Ta], Ea[Ta] = null, xf = Ea[--Ta], Ea[Ta] = null;
    for (; a === xo; )
      xo = Hi[--Vi], Hi[Vi] = null, Jr = Hi[--Vi], Hi[Vi] = null, Kr = Hi[--Vi], Hi[Vi] = null;
  }
  var Ti = null, Ai = null, qt = !1, tu = !1, or = null;
  function rx(a, u) {
    var p = ji(5, null, null, 0);
    p.elementType = "DELETED", p.stateNode = u, p.return = a, u = a.deletions, u === null ? (a.deletions = [p], a.flags |= 16) : u.push(p);
  }
  function sx(a, u) {
    switch (a.tag) {
      case 5:
        return u = nn(u, a.type, a.pendingProps), u !== null ? (a.stateNode = u, Ti = a, Ai = af(u), !0) : !1;
      case 6:
        return u = nf(u, a.pendingProps), u !== null ? (a.stateNode = u, Ti = a, Ai = null, !0) : !1;
      case 13:
        if (u = rf(u), u !== null) {
          var p = xo !== null ? { id: Kr, overflow: Jr } : null;
          return a.memoizedState = { dehydrated: u, treeContext: p, retryLane: 1073741824 }, p = ji(18, null, null, 0), p.stateNode = u, p.return = a, a.child = p, Ti = a, Ai = null, !0;
        }
        return !1;
      default:
        return !1;
    }
  }
  function gm(a) {
    return (a.mode & 1) !== 0 && (a.flags & 128) === 0;
  }
  function vm(a) {
    if (qt) {
      var u = Ai;
      if (u) {
        var p = u;
        if (!sx(a, u)) {
          if (gm(a))
            throw Error(o(418));
          u = Ar(p);
          var y = Ti;
          u && sx(a, u) ? rx(y, p) : (a.flags = a.flags & -4097 | 2, qt = !1, Ti = a);
        }
      } else {
        if (gm(a))
          throw Error(o(418));
        a.flags = a.flags & -4097 | 2, qt = !1, Ti = a;
      }
    }
  }
  function ox(a) {
    for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
      a = a.return;
    Ti = a;
  }
  function nu(a) {
    if (!ge || a !== Ti)
      return !1;
    if (!qt)
      return ox(a), qt = !0, !1;
    if (a.tag !== 3 && (a.tag !== 5 || rt(a.type) && !Te(a.type, a.memoizedProps))) {
      var u = Ai;
      if (u) {
        if (gm(a)) {
          for (a = Ai; a; )
            a = Ar(a);
          throw Error(o(418));
        }
        for (; u; )
          rx(a, u), u = Ar(u);
      }
    }
    if (ox(a), a.tag === 13) {
      if (!ge)
        throw Error(o(316));
      if (a = a.memoizedState, a = a !== null ? a.dehydrated : null, !a)
        throw Error(o(317));
      Ai = ce(a);
    } else
      Ai = Ti ? Ar(a.stateNode) : null;
    return !0;
  }
  function Aa() {
    ge && (Ai = Ti = null, tu = qt = !1);
  }
  function ym(a) {
    or === null ? or = [a] : or.push(a);
  }
  function iu(a, u, p) {
    if (a = p.ref, a !== null && typeof a != "function" && typeof a != "object") {
      if (p._owner) {
        if (p = p._owner, p) {
          if (p.tag !== 1)
            throw Error(o(309));
          var y = p.stateNode;
        }
        if (!y)
          throw Error(o(147, a));
        var E = y, A = "" + a;
        return u !== null && u.ref !== null && typeof u.ref == "function" && u.ref._stringRef === A ? u.ref : (u = function(k) {
          var q = E.refs;
          q === $_ && (q = E.refs = {}), k === null ? delete q[A] : q[A] = k;
        }, u._stringRef = A, u);
      }
      if (typeof a != "string")
        throw Error(o(284));
      if (!p._owner)
        throw Error(o(290, a));
    }
    return a;
  }
  function Sf(a, u) {
    throw a = Object.prototype.toString.call(u), Error(o(31, a === "[object Object]" ? "object with keys {" + Object.keys(u).join(", ") + "}" : a));
  }
  function ax(a) {
    var u = a._init;
    return u(a._payload);
  }
  function lx(a) {
    function u(ee, Z) {
      if (a) {
        var re = ee.deletions;
        re === null ? (ee.deletions = [Z], ee.flags |= 16) : re.push(Z);
      }
    }
    function p(ee, Z) {
      if (!a)
        return null;
      for (; Z !== null; )
        u(ee, Z), Z = Z.sibling;
      return null;
    }
    function y(ee, Z) {
      for (ee = /* @__PURE__ */ new Map(); Z !== null; )
        Z.key !== null ? ee.set(Z.key, Z) : ee.set(Z.index, Z), Z = Z.sibling;
      return ee;
    }
    function E(ee, Z) {
      return ee = Ds(ee, Z), ee.index = 0, ee.sibling = null, ee;
    }
    function A(ee, Z, re) {
      return ee.index = re, a ? (re = ee.alternate, re !== null ? (re = re.index, re < Z ? (ee.flags |= 2, Z) : re) : (ee.flags |= 2, Z)) : (ee.flags |= 1048576, Z);
    }
    function k(ee) {
      return a && ee.alternate === null && (ee.flags |= 2), ee;
    }
    function q(ee, Z, re, ke) {
      return Z === null || Z.tag !== 6 ? (Z = tg(re, ee.mode, ke), Z.return = ee, Z) : (Z = E(Z, re), Z.return = ee, Z);
    }
    function le(ee, Z, re, ke) {
      var Ze = re.type;
      return Ze === h ? Xe(ee, Z, re.props.children, ke, re.key) : Z !== null && (Z.elementType === Ze || typeof Ze == "object" && Ze !== null && Ze.$$typeof === S && ax(Ze) === Z.type) ? (ke = E(Z, re.props), ke.ref = iu(ee, Z, re), ke.return = ee, ke) : (ke = Qf(re.type, re.key, re.props, null, ee.mode, ke), ke.ref = iu(ee, Z, re), ke.return = ee, ke);
    }
    function Ce(ee, Z, re, ke) {
      return Z === null || Z.tag !== 4 || Z.stateNode.containerInfo !== re.containerInfo || Z.stateNode.implementation !== re.implementation ? (Z = ng(re, ee.mode, ke), Z.return = ee, Z) : (Z = E(Z, re.children || []), Z.return = ee, Z);
    }
    function Xe(ee, Z, re, ke, Ze) {
      return Z === null || Z.tag !== 7 ? (Z = Ro(re, ee.mode, ke, Ze), Z.return = ee, Z) : (Z = E(Z, re), Z.return = ee, Z);
    }
    function ft(ee, Z, re) {
      if (typeof Z == "string" && Z !== "" || typeof Z == "number")
        return Z = tg("" + Z, ee.mode, re), Z.return = ee, Z;
      if (typeof Z == "object" && Z !== null) {
        switch (Z.$$typeof) {
          case c:
            return re = Qf(Z.type, Z.key, Z.props, null, ee.mode, re), re.ref = iu(ee, null, Z), re.return = ee, re;
          case f:
            return Z = ng(Z, ee.mode, re), Z.return = ee, Z;
          case S:
            var ke = Z._init;
            return ft(ee, ke(Z._payload), re);
        }
        if (J(Z) || P(Z))
          return Z = Ro(Z, ee.mode, re, null), Z.return = ee, Z;
        Sf(ee, Z);
      }
      return null;
    }
    function nt(ee, Z, re, ke) {
      var Ze = Z !== null ? Z.key : null;
      if (typeof re == "string" && re !== "" || typeof re == "number")
        return Ze !== null ? null : q(ee, Z, "" + re, ke);
      if (typeof re == "object" && re !== null) {
        switch (re.$$typeof) {
          case c:
            return re.key === Ze ? le(ee, Z, re, ke) : null;
          case f:
            return re.key === Ze ? Ce(ee, Z, re, ke) : null;
          case S:
            return Ze = re._init, nt(
              ee,
              Z,
              Ze(re._payload),
              ke
            );
        }
        if (J(re) || P(re))
          return Ze !== null ? null : Xe(ee, Z, re, ke, null);
        Sf(ee, re);
      }
      return null;
    }
    function Bt(ee, Z, re, ke, Ze) {
      if (typeof ke == "string" && ke !== "" || typeof ke == "number")
        return ee = ee.get(re) || null, q(Z, ee, "" + ke, Ze);
      if (typeof ke == "object" && ke !== null) {
        switch (ke.$$typeof) {
          case c:
            return ee = ee.get(ke.key === null ? re : ke.key) || null, le(Z, ee, ke, Ze);
          case f:
            return ee = ee.get(ke.key === null ? re : ke.key) || null, Ce(Z, ee, ke, Ze);
          case S:
            var yt = ke._init;
            return Bt(ee, Z, re, yt(ke._payload), Ze);
        }
        if (J(ke) || P(ke))
          return ee = ee.get(re) || null, Xe(Z, ee, ke, Ze, null);
        Sf(Z, ke);
      }
      return null;
    }
    function Ke(ee, Z, re, ke) {
      for (var Ze = null, yt = null, ht = Z, bt = Z = 0, Ln = null; ht !== null && bt < re.length; bt++) {
        ht.index > bt ? (Ln = ht, ht = null) : Ln = ht.sibling;
        var Lt = nt(ee, ht, re[bt], ke);
        if (Lt === null) {
          ht === null && (ht = Ln);
          break;
        }
        a && ht && Lt.alternate === null && u(ee, ht), Z = A(Lt, Z, bt), yt === null ? Ze = Lt : yt.sibling = Lt, yt = Lt, ht = Ln;
      }
      if (bt === re.length)
        return p(ee, ht), qt && So(ee, bt), Ze;
      if (ht === null) {
        for (; bt < re.length; bt++)
          ht = ft(ee, re[bt], ke), ht !== null && (Z = A(ht, Z, bt), yt === null ? Ze = ht : yt.sibling = ht, yt = ht);
        return qt && So(ee, bt), Ze;
      }
      for (ht = y(ee, ht); bt < re.length; bt++)
        Ln = Bt(ht, ee, bt, re[bt], ke), Ln !== null && (a && Ln.alternate !== null && ht.delete(Ln.key === null ? bt : Ln.key), Z = A(Ln, Z, bt), yt === null ? Ze = Ln : yt.sibling = Ln, yt = Ln);
      return a && ht.forEach(function(Us) {
        return u(ee, Us);
      }), qt && So(ee, bt), Ze;
    }
    function Xn(ee, Z, re, ke) {
      var Ze = P(re);
      if (typeof Ze != "function")
        throw Error(o(150));
      if (re = Ze.call(re), re == null)
        throw Error(o(151));
      for (var yt = Ze = null, ht = Z, bt = Z = 0, Ln = null, Lt = re.next(); ht !== null && !Lt.done; bt++, Lt = re.next()) {
        ht.index > bt ? (Ln = ht, ht = null) : Ln = ht.sibling;
        var Us = nt(ee, ht, Lt.value, ke);
        if (Us === null) {
          ht === null && (ht = Ln);
          break;
        }
        a && ht && Us.alternate === null && u(ee, ht), Z = A(Us, Z, bt), yt === null ? Ze = Us : yt.sibling = Us, yt = Us, ht = Ln;
      }
      if (Lt.done)
        return p(
          ee,
          ht
        ), qt && So(ee, bt), Ze;
      if (ht === null) {
        for (; !Lt.done; bt++, Lt = re.next())
          Lt = ft(ee, Lt.value, ke), Lt !== null && (Z = A(Lt, Z, bt), yt === null ? Ze = Lt : yt.sibling = Lt, yt = Lt);
        return qt && So(ee, bt), Ze;
      }
      for (ht = y(ee, ht); !Lt.done; bt++, Lt = re.next())
        Lt = Bt(ht, ee, bt, Lt.value, ke), Lt !== null && (a && Lt.alternate !== null && ht.delete(Lt.key === null ? bt : Lt.key), Z = A(Lt, Z, bt), yt === null ? Ze = Lt : yt.sibling = Lt, yt = Lt);
      return a && ht.forEach(function(iR) {
        return u(ee, iR);
      }), qt && So(ee, bt), Ze;
    }
    function Yi(ee, Z, re, ke) {
      if (typeof re == "object" && re !== null && re.type === h && re.key === null && (re = re.props.children), typeof re == "object" && re !== null) {
        switch (re.$$typeof) {
          case c:
            e: {
              for (var Ze = re.key, yt = Z; yt !== null; ) {
                if (yt.key === Ze) {
                  if (Ze = re.type, Ze === h) {
                    if (yt.tag === 7) {
                      p(ee, yt.sibling), Z = E(yt, re.props.children), Z.return = ee, ee = Z;
                      break e;
                    }
                  } else if (yt.elementType === Ze || typeof Ze == "object" && Ze !== null && Ze.$$typeof === S && ax(Ze) === yt.type) {
                    p(ee, yt.sibling), Z = E(yt, re.props), Z.ref = iu(ee, yt, re), Z.return = ee, ee = Z;
                    break e;
                  }
                  p(ee, yt);
                  break;
                } else
                  u(ee, yt);
                yt = yt.sibling;
              }
              re.type === h ? (Z = Ro(re.props.children, ee.mode, ke, re.key), Z.return = ee, ee = Z) : (ke = Qf(re.type, re.key, re.props, null, ee.mode, ke), ke.ref = iu(ee, Z, re), ke.return = ee, ee = ke);
            }
            return k(ee);
          case f:
            e: {
              for (yt = re.key; Z !== null; ) {
                if (Z.key === yt)
                  if (Z.tag === 4 && Z.stateNode.containerInfo === re.containerInfo && Z.stateNode.implementation === re.implementation) {
                    p(ee, Z.sibling), Z = E(Z, re.children || []), Z.return = ee, ee = Z;
                    break e;
                  } else {
                    p(ee, Z);
                    break;
                  }
                else
                  u(ee, Z);
                Z = Z.sibling;
              }
              Z = ng(re, ee.mode, ke), Z.return = ee, ee = Z;
            }
            return k(ee);
          case S:
            return yt = re._init, Yi(ee, Z, yt(re._payload), ke);
        }
        if (J(re))
          return Ke(ee, Z, re, ke);
        if (P(re))
          return Xn(ee, Z, re, ke);
        Sf(ee, re);
      }
      return typeof re == "string" && re !== "" || typeof re == "number" ? (re = "" + re, Z !== null && Z.tag === 6 ? (p(ee, Z.sibling), Z = E(Z, re), Z.return = ee, ee = Z) : (p(ee, Z), Z = tg(re, ee.mode, ke), Z.return = ee, ee = Z), k(ee)) : p(ee, Z);
    }
    return Yi;
  }
  var Ca = lx(!0), ux = lx(!1), ru = {}, Gi = ct(ru), su = ct(ru), Ra = ct(ru);
  function Lr(a) {
    if (a === ru)
      throw Error(o(174));
    return a;
  }
  function _m(a, u) {
    ut(Ra, u), ut(su, a), ut(Gi, ru), a = ne(u), Ot(Gi), ut(Gi, a);
  }
  function Pa() {
    Ot(Gi), Ot(su), Ot(Ra);
  }
  function cx(a) {
    var u = Lr(Ra.current), p = Lr(Gi.current);
    u = O(p, a.type, u), p !== u && (ut(su, a), ut(Gi, u));
  }
  function xm(a) {
    su.current === a && (Ot(Gi), Ot(su));
  }
  var Kt = ct(0);
  function Mf(a) {
    for (var u = a; u !== null; ) {
      if (u.tag === 13) {
        var p = u.memoizedState;
        if (p !== null && (p = p.dehydrated, p === null || sf(p) || As(p)))
          return u;
      } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
        if (u.flags & 128)
          return u;
      } else if (u.child !== null) {
        u.child.return = u, u = u.child;
        continue;
      }
      if (u === a)
        break;
      for (; u.sibling === null; ) {
        if (u.return === null || u.return === a)
          return null;
        u = u.return;
      }
      u.sibling.return = u.return, u = u.sibling;
    }
    return null;
  }
  var Sm = [];
  function Mm() {
    for (var a = 0; a < Sm.length; a++) {
      var u = Sm[a];
      lt ? u._workInProgressVersionPrimary = null : u._workInProgressVersionSecondary = null;
    }
    Sm.length = 0;
  }
  var wf = l.ReactCurrentDispatcher, Wi = l.ReactCurrentBatchConfig, ba = 0, on = null, Vn = null, bn = null, Ef = !1, ou = !1, au = 0, RC = 0;
  function Gn() {
    throw Error(o(321));
  }
  function wm(a, u) {
    if (u === null)
      return !1;
    for (var p = 0; p < u.length && p < a.length; p++)
      if (!Rr(a[p], u[p]))
        return !1;
    return !0;
  }
  function Em(a, u, p, y, E, A) {
    if (ba = A, on = u, u.memoizedState = null, u.updateQueue = null, u.lanes = 0, wf.current = a === null || a.memoizedState === null ? IC : NC, a = p(y, E), ou) {
      A = 0;
      do {
        if (ou = !1, au = 0, 25 <= A)
          throw Error(o(301));
        A += 1, bn = Vn = null, u.updateQueue = null, wf.current = DC, a = p(y, E);
      } while (ou);
    }
    if (wf.current = Pf, u = Vn !== null && Vn.next !== null, ba = 0, bn = Vn = on = null, Ef = !1, u)
      throw Error(o(300));
    return a;
  }
  function Tm() {
    var a = au !== 0;
    return au = 0, a;
  }
  function Qr() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return bn === null ? on.memoizedState = bn = a : bn = bn.next = a, bn;
  }
  function Ir() {
    if (Vn === null) {
      var a = on.alternate;
      a = a !== null ? a.memoizedState : null;
    } else
      a = Vn.next;
    var u = bn === null ? on.memoizedState : bn.next;
    if (u !== null)
      bn = u, Vn = a;
    else {
      if (a === null)
        throw Error(o(310));
      Vn = a, a = { memoizedState: Vn.memoizedState, baseState: Vn.baseState, baseQueue: Vn.baseQueue, queue: Vn.queue, next: null }, bn === null ? on.memoizedState = bn = a : bn = bn.next = a;
    }
    return bn;
  }
  function Mo(a, u) {
    return typeof u == "function" ? u(a) : u;
  }
  function Tf(a) {
    var u = Ir(), p = u.queue;
    if (p === null)
      throw Error(o(311));
    p.lastRenderedReducer = a;
    var y = Vn, E = y.baseQueue, A = p.pending;
    if (A !== null) {
      if (E !== null) {
        var k = E.next;
        E.next = A.next, A.next = k;
      }
      y.baseQueue = E = A, p.pending = null;
    }
    if (E !== null) {
      A = E.next, y = y.baseState;
      var q = k = null, le = null, Ce = A;
      do {
        var Xe = Ce.lane;
        if ((ba & Xe) === Xe)
          le !== null && (le = le.next = { lane: 0, action: Ce.action, hasEagerState: Ce.hasEagerState, eagerState: Ce.eagerState, next: null }), y = Ce.hasEagerState ? Ce.eagerState : a(y, Ce.action);
        else {
          var ft = {
            lane: Xe,
            action: Ce.action,
            hasEagerState: Ce.hasEagerState,
            eagerState: Ce.eagerState,
            next: null
          };
          le === null ? (q = le = ft, k = y) : le = le.next = ft, on.lanes |= Xe, Ia |= Xe;
        }
        Ce = Ce.next;
      } while (Ce !== null && Ce !== A);
      le === null ? k = y : le.next = q, Rr(y, u.memoizedState) || (Ci = !0), u.memoizedState = y, u.baseState = k, u.baseQueue = le, p.lastRenderedState = y;
    }
    if (a = p.interleaved, a !== null) {
      E = a;
      do
        A = E.lane, on.lanes |= A, Ia |= A, E = E.next;
      while (E !== a);
    } else
      E === null && (p.lanes = 0);
    return [u.memoizedState, p.dispatch];
  }
  function Af(a) {
    var u = Ir(), p = u.queue;
    if (p === null)
      throw Error(o(311));
    p.lastRenderedReducer = a;
    var y = p.dispatch, E = p.pending, A = u.memoizedState;
    if (E !== null) {
      p.pending = null;
      var k = E = E.next;
      do
        A = a(A, k.action), k = k.next;
      while (k !== E);
      Rr(A, u.memoizedState) || (Ci = !0), u.memoizedState = A, u.baseQueue === null && (u.baseState = A), p.lastRenderedState = A;
    }
    return [A, y];
  }
  function fx() {
  }
  function hx(a, u) {
    var p = on, y = Ir(), E = u(), A = !Rr(y.memoizedState, E);
    if (A && (y.memoizedState = E, Ci = !0), y = y.queue, uu(mx.bind(null, p, y, a), [a]), y.getSnapshot !== u || A || bn !== null && bn.memoizedState.tag & 1) {
      if (p.flags |= 2048, lu(9, px.bind(null, p, y, E, u), void 0, null), vn === null)
        throw Error(o(349));
      ba & 30 || dx(p, u, E);
    }
    return E;
  }
  function dx(a, u, p) {
    a.flags |= 16384, a = { getSnapshot: u, value: p }, u = on.updateQueue, u === null ? (u = { lastEffect: null, stores: null }, on.updateQueue = u, u.stores = [a]) : (p = u.stores, p === null ? u.stores = [a] : p.push(a));
  }
  function px(a, u, p, y) {
    u.value = p, u.getSnapshot = y, gx(u) && Xi(a, 1, -1);
  }
  function mx(a, u, p) {
    return p(function() {
      gx(u) && Xi(a, 1, -1);
    });
  }
  function gx(a) {
    var u = a.getSnapshot;
    a = a.value;
    try {
      var p = u();
      return !Rr(a, p);
    } catch {
      return !0;
    }
  }
  function Am(a) {
    var u = Qr();
    return typeof a == "function" && (a = a()), u.memoizedState = u.baseState = a, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Mo, lastRenderedState: a }, u.queue = a, a = a.dispatch = LC.bind(null, on, a), [u.memoizedState, a];
  }
  function lu(a, u, p, y) {
    return a = { tag: a, create: u, destroy: p, deps: y, next: null }, u = on.updateQueue, u === null ? (u = { lastEffect: null, stores: null }, on.updateQueue = u, u.lastEffect = a.next = a) : (p = u.lastEffect, p === null ? u.lastEffect = a.next = a : (y = p.next, p.next = a, a.next = y, u.lastEffect = a)), a;
  }
  function vx() {
    return Ir().memoizedState;
  }
  function Cf(a, u, p, y) {
    var E = Qr();
    on.flags |= a, E.memoizedState = lu(1 | u, p, void 0, y === void 0 ? null : y);
  }
  function Rf(a, u, p, y) {
    var E = Ir();
    y = y === void 0 ? null : y;
    var A = void 0;
    if (Vn !== null) {
      var k = Vn.memoizedState;
      if (A = k.destroy, y !== null && wm(y, k.deps)) {
        E.memoizedState = lu(u, p, A, y);
        return;
      }
    }
    on.flags |= a, E.memoizedState = lu(1 | u, p, A, y);
  }
  function Cm(a, u) {
    return Cf(8390656, 8, a, u);
  }
  function uu(a, u) {
    return Rf(2048, 8, a, u);
  }
  function yx(a, u) {
    return Rf(4, 2, a, u);
  }
  function _x(a, u) {
    return Rf(4, 4, a, u);
  }
  function xx(a, u) {
    if (typeof u == "function")
      return a = a(), u(a), function() {
        u(null);
      };
    if (u != null)
      return a = a(), u.current = a, function() {
        u.current = null;
      };
  }
  function Sx(a, u, p) {
    return p = p != null ? p.concat([a]) : null, Rf(4, 4, xx.bind(null, u, a), p);
  }
  function Rm() {
  }
  function Mx(a, u) {
    var p = Ir();
    u = u === void 0 ? null : u;
    var y = p.memoizedState;
    return y !== null && u !== null && wm(u, y[1]) ? y[0] : (p.memoizedState = [a, u], a);
  }
  function wx(a, u) {
    var p = Ir();
    u = u === void 0 ? null : u;
    var y = p.memoizedState;
    return y !== null && u !== null && wm(u, y[1]) ? y[0] : (a = a(), p.memoizedState = [a, u], a);
  }
  function PC(a, u) {
    var p = Pt;
    Pt = p !== 0 && 4 > p ? p : 4, a(!0);
    var y = Wi.transition;
    Wi.transition = {};
    try {
      a(!1), u();
    } finally {
      Pt = p, Wi.transition = y;
    }
  }
  function Ex() {
    return Ir().memoizedState;
  }
  function bC(a, u, p) {
    var y = Is(a);
    p = { lane: y, action: p, hasEagerState: !1, eagerState: null, next: null }, Tx(a) ? Ax(u, p) : (Cx(a, u, p), p = ni(), a = Xi(a, y, p), a !== null && Rx(a, u, y));
  }
  function LC(a, u, p) {
    var y = Is(a), E = { lane: y, action: p, hasEagerState: !1, eagerState: null, next: null };
    if (Tx(a))
      Ax(u, E);
    else {
      Cx(a, u, E);
      var A = a.alternate;
      if (a.lanes === 0 && (A === null || A.lanes === 0) && (A = u.lastRenderedReducer, A !== null))
        try {
          var k = u.lastRenderedState, q = A(k, p);
          if (E.hasEagerState = !0, E.eagerState = q, Rr(q, k))
            return;
        } catch {
        } finally {
        }
      p = ni(), a = Xi(a, y, p), a !== null && Rx(a, u, y);
    }
  }
  function Tx(a) {
    var u = a.alternate;
    return a === on || u !== null && u === on;
  }
  function Ax(a, u) {
    ou = Ef = !0;
    var p = a.pending;
    p === null ? u.next = u : (u.next = p.next, p.next = u), a.pending = u;
  }
  function Cx(a, u, p) {
    vn !== null && a.mode & 1 && !(Mt & 2) ? (a = u.interleaved, a === null ? (p.next = p, br === null ? br = [u] : br.push(u)) : (p.next = a.next, a.next = p), u.interleaved = p) : (a = u.pending, a === null ? p.next = p : (p.next = a.next, a.next = p), u.pending = p);
  }
  function Rx(a, u, p) {
    if (p & 4194240) {
      var y = u.lanes;
      y &= a.pendingLanes, p |= y, u.lanes = p, nm(a, p);
    }
  }
  var Pf = { readContext: Bi, useCallback: Gn, useContext: Gn, useEffect: Gn, useImperativeHandle: Gn, useInsertionEffect: Gn, useLayoutEffect: Gn, useMemo: Gn, useReducer: Gn, useRef: Gn, useState: Gn, useDebugValue: Gn, useDeferredValue: Gn, useTransition: Gn, useMutableSource: Gn, useSyncExternalStore: Gn, useId: Gn, unstable_isNewReconciler: !1 }, IC = { readContext: Bi, useCallback: function(a, u) {
    return Qr().memoizedState = [a, u === void 0 ? null : u], a;
  }, useContext: Bi, useEffect: Cm, useImperativeHandle: function(a, u, p) {
    return p = p != null ? p.concat([a]) : null, Cf(
      4194308,
      4,
      xx.bind(null, u, a),
      p
    );
  }, useLayoutEffect: function(a, u) {
    return Cf(4194308, 4, a, u);
  }, useInsertionEffect: function(a, u) {
    return Cf(4, 2, a, u);
  }, useMemo: function(a, u) {
    var p = Qr();
    return u = u === void 0 ? null : u, a = a(), p.memoizedState = [a, u], a;
  }, useReducer: function(a, u, p) {
    var y = Qr();
    return u = p !== void 0 ? p(u) : u, y.memoizedState = y.baseState = u, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: u }, y.queue = a, a = a.dispatch = bC.bind(null, on, a), [y.memoizedState, a];
  }, useRef: function(a) {
    var u = Qr();
    return a = { current: a }, u.memoizedState = a;
  }, useState: Am, useDebugValue: Rm, useDeferredValue: function(a) {
    var u = Am(a), p = u[0], y = u[1];
    return Cm(function() {
      var E = Wi.transition;
      Wi.transition = {};
      try {
        y(a);
      } finally {
        Wi.transition = E;
      }
    }, [a]), p;
  }, useTransition: function() {
    var a = Am(!1), u = a[0];
    return a = PC.bind(null, a[1]), Qr().memoizedState = a, [u, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, u, p) {
    var y = on, E = Qr();
    if (qt) {
      if (p === void 0)
        throw Error(o(407));
      p = p();
    } else {
      if (p = u(), vn === null)
        throw Error(o(349));
      ba & 30 || dx(y, u, p);
    }
    E.memoizedState = p;
    var A = { value: p, getSnapshot: u };
    return E.queue = A, Cm(mx.bind(null, y, A, a), [a]), y.flags |= 2048, lu(9, px.bind(null, y, A, p, u), void 0, null), p;
  }, useId: function() {
    var a = Qr(), u = vn.identifierPrefix;
    if (qt) {
      var p = Jr, y = Kr;
      p = (y & ~(1 << 32 - rr(y) - 1)).toString(32) + p, u = ":" + u + "R" + p, p = au++, 0 < p && (u += "H" + p.toString(32)), u += ":";
    } else
      p = RC++, u = ":" + u + "r" + p.toString(32) + ":";
    return a.memoizedState = u;
  }, unstable_isNewReconciler: !1 }, NC = {
    readContext: Bi,
    useCallback: Mx,
    useContext: Bi,
    useEffect: uu,
    useImperativeHandle: Sx,
    useInsertionEffect: yx,
    useLayoutEffect: _x,
    useMemo: wx,
    useReducer: Tf,
    useRef: vx,
    useState: function() {
      return Tf(Mo);
    },
    useDebugValue: Rm,
    useDeferredValue: function(a) {
      var u = Tf(Mo), p = u[0], y = u[1];
      return uu(function() {
        var E = Wi.transition;
        Wi.transition = {};
        try {
          y(a);
        } finally {
          Wi.transition = E;
        }
      }, [a]), p;
    },
    useTransition: function() {
      var a = Tf(Mo)[0], u = Ir().memoizedState;
      return [a, u];
    },
    useMutableSource: fx,
    useSyncExternalStore: hx,
    useId: Ex,
    unstable_isNewReconciler: !1
  }, DC = {
    readContext: Bi,
    useCallback: Mx,
    useContext: Bi,
    useEffect: uu,
    useImperativeHandle: Sx,
    useInsertionEffect: yx,
    useLayoutEffect: _x,
    useMemo: wx,
    useReducer: Af,
    useRef: vx,
    useState: function() {
      return Af(Mo);
    },
    useDebugValue: Rm,
    useDeferredValue: function(a) {
      var u = Af(Mo), p = u[0], y = u[1];
      return uu(function() {
        var E = Wi.transition;
        Wi.transition = {};
        try {
          y(a);
        } finally {
          Wi.transition = E;
        }
      }, [a]), p;
    },
    useTransition: function() {
      var a = Af(Mo)[0], u = Ir().memoizedState;
      return [a, u];
    },
    useMutableSource: fx,
    useSyncExternalStore: hx,
    useId: Ex,
    unstable_isNewReconciler: !1
  };
  function Pm(a, u) {
    try {
      var p = "", y = u;
      do
        p += CC(y), y = y.return;
      while (y);
      var E = p;
    } catch (A) {
      E = `
Error generating stack: ` + A.message + `
` + A.stack;
    }
    return { value: a, source: u, stack: E };
  }
  function bm(a, u) {
    try {
      console.error(u.value);
    } catch (p) {
      setTimeout(function() {
        throw p;
      });
    }
  }
  var UC = typeof WeakMap == "function" ? WeakMap : Map;
  function Px(a, u, p) {
    p = Zr(-1, p), p.tag = 3, p.payload = { element: null };
    var y = u.value;
    return p.callback = function() {
      Xf || (Xf = !0, qm = y), bm(a, u);
    }, p;
  }
  function bx(a, u, p) {
    p = Zr(-1, p), p.tag = 3;
    var y = a.type.getDerivedStateFromError;
    if (typeof y == "function") {
      var E = u.value;
      p.payload = function() {
        return y(E);
      }, p.callback = function() {
        bm(a, u);
      };
    }
    var A = a.stateNode;
    return A !== null && typeof A.componentDidCatch == "function" && (p.callback = function() {
      bm(a, u), typeof y != "function" && (bs === null ? bs = /* @__PURE__ */ new Set([this]) : bs.add(this));
      var k = u.stack;
      this.componentDidCatch(u.value, { componentStack: k !== null ? k : "" });
    }), p;
  }
  function Lx(a, u, p) {
    var y = a.pingCache;
    if (y === null) {
      y = a.pingCache = new UC();
      var E = /* @__PURE__ */ new Set();
      y.set(u, E);
    } else
      E = y.get(u), E === void 0 && (E = /* @__PURE__ */ new Set(), y.set(u, E));
    E.has(p) || (E.add(p), a = ZC.bind(null, a, u, p), u.then(a, a));
  }
  function Ix(a) {
    do {
      var u;
      if ((u = a.tag === 13) && (u = a.memoizedState, u = u !== null ? u.dehydrated !== null : !0), u)
        return a;
      a = a.return;
    } while (a !== null);
    return null;
  }
  function Nx(a, u, p, y, E) {
    return a.mode & 1 ? (a.flags |= 65536, a.lanes = E, a) : (a === u ? a.flags |= 65536 : (a.flags |= 128, p.flags |= 131072, p.flags &= -52805, p.tag === 1 && (p.alternate === null ? p.tag = 17 : (u = Zr(-1, 1), u.tag = 2, Ps(p, u))), p.lanes |= 1), a);
  }
  function Nr(a) {
    a.flags |= 4;
  }
  function Dx(a, u) {
    if (a !== null && a.child === u.child)
      return !0;
    if (u.flags & 16)
      return !1;
    for (a = u.child; a !== null; ) {
      if (a.flags & 12854 || a.subtreeFlags & 12854)
        return !1;
      a = a.sibling;
    }
    return !0;
  }
  var cu, fu, bf, Lf;
  if (Re)
    cu = function(a, u) {
      for (var p = u.child; p !== null; ) {
        if (p.tag === 5 || p.tag === 6)
          j(a, p.stateNode);
        else if (p.tag !== 4 && p.child !== null) {
          p.child.return = p, p = p.child;
          continue;
        }
        if (p === u)
          break;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === u)
            return;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
    }, fu = function() {
    }, bf = function(a, u, p, y, E) {
      if (a = a.memoizedProps, a !== y) {
        var A = u.stateNode, k = Lr(Gi.current);
        p = ye(A, p, a, y, E, k), (u.updateQueue = p) && Nr(u);
      }
    }, Lf = function(a, u, p, y) {
      p !== y && Nr(u);
    };
  else if (z) {
    cu = function(a, u, p, y) {
      for (var E = u.child; E !== null; ) {
        if (E.tag === 5) {
          var A = E.stateNode;
          p && y && (A = Nt(A, E.type, E.memoizedProps, E)), j(a, A);
        } else if (E.tag === 6)
          A = E.stateNode, p && y && (A = Mn(A, E.memoizedProps, E)), j(a, A);
        else if (E.tag !== 4) {
          if (E.tag === 22 && E.memoizedState !== null)
            A = E.child, A !== null && (A.return = E), cu(a, E, !0, !0);
          else if (E.child !== null) {
            E.child.return = E, E = E.child;
            continue;
          }
        }
        if (E === u)
          break;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === u)
            return;
          E = E.return;
        }
        E.sibling.return = E.return, E = E.sibling;
      }
    };
    var Ux = function(a, u, p, y) {
      for (var E = u.child; E !== null; ) {
        if (E.tag === 5) {
          var A = E.stateNode;
          p && y && (A = Nt(A, E.type, E.memoizedProps, E)), At(a, A);
        } else if (E.tag === 6)
          A = E.stateNode, p && y && (A = Mn(A, E.memoizedProps, E)), At(a, A);
        else if (E.tag !== 4) {
          if (E.tag === 22 && E.memoizedState !== null)
            A = E.child, A !== null && (A.return = E), Ux(a, E, !0, !0);
          else if (E.child !== null) {
            E.child.return = E, E = E.child;
            continue;
          }
        }
        if (E === u)
          break;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === u)
            return;
          E = E.return;
        }
        E.sibling.return = E.return, E = E.sibling;
      }
    };
    fu = function(a, u) {
      var p = u.stateNode;
      if (!Dx(a, u)) {
        a = p.containerInfo;
        var y = Et(a);
        Ux(y, u, !1, !1), p.pendingChildren = y, Nr(u), Dt(a, y);
      }
    }, bf = function(a, u, p, y, E) {
      var A = a.stateNode, k = a.memoizedProps;
      if ((a = Dx(a, u)) && k === y)
        u.stateNode = A;
      else {
        var q = u.stateNode, le = Lr(Gi.current), Ce = null;
        k !== y && (Ce = ye(q, p, k, y, E, le)), a && Ce === null ? u.stateNode = A : (A = De(A, Ce, p, k, y, u, a, q), de(A, p, y, E, le) && Nr(u), u.stateNode = A, a ? Nr(u) : cu(A, u, !1, !1));
      }
    }, Lf = function(a, u, p, y) {
      p !== y ? (a = Lr(Ra.current), p = Lr(Gi.current), u.stateNode = Ie(y, a, p, u), Nr(u)) : u.stateNode = a.stateNode;
    };
  } else
    fu = function() {
    }, bf = function() {
    }, Lf = function() {
    };
  function hu(a, u) {
    if (!qt)
      switch (a.tailMode) {
        case "hidden":
          u = a.tail;
          for (var p = null; u !== null; )
            u.alternate !== null && (p = u), u = u.sibling;
          p === null ? a.tail = null : p.sibling = null;
          break;
        case "collapsed":
          p = a.tail;
          for (var y = null; p !== null; )
            p.alternate !== null && (y = p), p = p.sibling;
          y === null ? u || a.tail === null ? a.tail = null : a.tail.sibling = null : y.sibling = null;
      }
  }
  function Wn(a) {
    var u = a.alternate !== null && a.alternate.child === a.child, p = 0, y = 0;
    if (u)
      for (var E = a.child; E !== null; )
        p |= E.lanes | E.childLanes, y |= E.subtreeFlags & 14680064, y |= E.flags & 14680064, E.return = a, E = E.sibling;
    else
      for (E = a.child; E !== null; )
        p |= E.lanes | E.childLanes, y |= E.subtreeFlags, y |= E.flags, E.return = a, E = E.sibling;
    return a.subtreeFlags |= y, a.childLanes = p, u;
  }
  function OC(a, u, p) {
    var y = u.pendingProps;
    switch (mm(u), u.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Wn(u), null;
      case 1:
        return sn(u.type) && Cs(), Wn(u), null;
      case 3:
        return y = u.stateNode, Pa(), Ot(gn), Ot(wn), Mm(), y.pendingContext && (y.context = y.pendingContext, y.pendingContext = null), (a === null || a.child === null) && (nu(u) ? Nr(u) : a === null || a.memoizedState.isDehydrated && !(u.flags & 256) || (u.flags |= 1024, or !== null && (Jm(or), or = null))), fu(a, u), Wn(u), null;
      case 5:
        xm(u), p = Lr(Ra.current);
        var E = u.type;
        if (a !== null && u.stateNode != null)
          bf(a, u, E, y, p), a.ref !== u.ref && (u.flags |= 512, u.flags |= 2097152);
        else {
          if (!y) {
            if (u.stateNode === null)
              throw Error(o(166));
            return Wn(u), null;
          }
          if (a = Lr(Gi.current), nu(u)) {
            if (!ge)
              throw Error(o(175));
            a = $p(u.stateNode, u.type, u.memoizedProps, p, a, u, !tu), u.updateQueue = a, a !== null && Nr(u);
          } else {
            var A = V(E, y, p, a, u);
            cu(A, u, !1, !1), u.stateNode = A, de(A, E, y, p, a) && Nr(u);
          }
          u.ref !== null && (u.flags |= 512, u.flags |= 2097152);
        }
        return Wn(u), null;
      case 6:
        if (a && u.stateNode != null)
          Lf(a, u, a.memoizedProps, y);
        else {
          if (typeof y != "string" && u.stateNode === null)
            throw Error(o(166));
          if (a = Lr(Ra.current), p = Lr(Gi.current), nu(u)) {
            if (!ge)
              throw Error(o(176));
            if (a = u.stateNode, y = u.memoizedProps, (p = U(a, y, u, !tu)) && (E = Ti, E !== null))
              switch (A = (E.mode & 1) !== 0, E.tag) {
                case 3:
                  st(E.stateNode.containerInfo, a, y, A);
                  break;
                case 5:
                  St(E.type, E.memoizedProps, E.stateNode, a, y, A);
              }
            p && Nr(u);
          } else
            u.stateNode = Ie(y, a, p, u);
        }
        return Wn(u), null;
      case 13:
        if (Ot(Kt), y = u.memoizedState, qt && Ai !== null && u.mode & 1 && !(u.flags & 128)) {
          for (a = Ai; a; )
            a = Ar(a);
          return Aa(), u.flags |= 98560, u;
        }
        if (y !== null && y.dehydrated !== null) {
          if (y = nu(u), a === null) {
            if (!y)
              throw Error(o(318));
            if (!ge)
              throw Error(o(344));
            if (a = u.memoizedState, a = a !== null ? a.dehydrated : null, !a)
              throw Error(o(317));
            te(a, u);
          } else
            Aa(), !(u.flags & 128) && (u.memoizedState = null), u.flags |= 4;
          return Wn(u), null;
        }
        return or !== null && (Jm(or), or = null), u.flags & 128 ? (u.lanes = p, u) : (y = y !== null, p = !1, a === null ? nu(u) : p = a.memoizedState !== null, y && !p && (u.child.flags |= 8192, u.mode & 1 && (a === null || Kt.current & 1 ? En === 0 && (En = 3) : $m())), u.updateQueue !== null && (u.flags |= 4), Wn(u), null);
      case 4:
        return Pa(), fu(a, u), a === null && Se(u.stateNode.containerInfo), Wn(u), null;
      case 10:
        return um(u.type._context), Wn(u), null;
      case 17:
        return sn(u.type) && Cs(), Wn(u), null;
      case 19:
        if (Ot(Kt), E = u.memoizedState, E === null)
          return Wn(u), null;
        if (y = (u.flags & 128) !== 0, A = E.rendering, A === null)
          if (y)
            hu(E, !1);
          else {
            if (En !== 0 || a !== null && a.flags & 128)
              for (a = u.child; a !== null; ) {
                if (A = Mf(a), A !== null) {
                  for (u.flags |= 128, hu(E, !1), a = A.updateQueue, a !== null && (u.updateQueue = a, u.flags |= 4), u.subtreeFlags = 0, a = p, y = u.child; y !== null; )
                    p = y, E = a, p.flags &= 14680066, A = p.alternate, A === null ? (p.childLanes = 0, p.lanes = E, p.child = null, p.subtreeFlags = 0, p.memoizedProps = null, p.memoizedState = null, p.updateQueue = null, p.dependencies = null, p.stateNode = null) : (p.childLanes = A.childLanes, p.lanes = A.lanes, p.child = A.child, p.subtreeFlags = 0, p.deletions = null, p.memoizedProps = A.memoizedProps, p.memoizedState = A.memoizedState, p.updateQueue = A.updateQueue, p.type = A.type, E = A.dependencies, p.dependencies = E === null ? null : { lanes: E.lanes, firstContext: E.firstContext }), y = y.sibling;
                  return ut(Kt, Kt.current & 1 | 2), u.child;
                }
                a = a.sibling;
              }
            E.tail !== null && Pn() > Ym && (u.flags |= 128, y = !0, hu(E, !1), u.lanes = 4194304);
          }
        else {
          if (!y)
            if (a = Mf(A), a !== null) {
              if (u.flags |= 128, y = !0, a = a.updateQueue, a !== null && (u.updateQueue = a, u.flags |= 4), hu(E, !0), E.tail === null && E.tailMode === "hidden" && !A.alternate && !qt)
                return Wn(u), null;
            } else
              2 * Pn() - E.renderingStartTime > Ym && p !== 1073741824 && (u.flags |= 128, y = !0, hu(E, !1), u.lanes = 4194304);
          E.isBackwards ? (A.sibling = u.child, u.child = A) : (a = E.last, a !== null ? a.sibling = A : u.child = A, E.last = A);
        }
        return E.tail !== null ? (u = E.tail, E.rendering = u, E.tail = u.sibling, E.renderingStartTime = Pn(), u.sibling = null, a = Kt.current, ut(Kt, y ? a & 1 | 2 : a & 1), u) : (Wn(u), null);
      case 22:
      case 23:
        return Qm(), y = u.memoizedState !== null, a !== null && a.memoizedState !== null !== y && (u.flags |= 8192), y && u.mode & 1 ? Ri & 1073741824 && (Wn(u), Re && u.subtreeFlags & 6 && (u.flags |= 8192)) : Wn(u), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(o(156, u.tag));
  }
  var kC = l.ReactCurrentOwner, Ci = !1;
  function ti(a, u, p, y) {
    u.child = a === null ? ux(u, null, p, y) : Ca(u, a.child, p, y);
  }
  function Ox(a, u, p, y, E) {
    p = p.render;
    var A = u.ref;
    return wa(u, E), y = Em(a, u, p, y, A, E), p = Tm(), a !== null && !Ci ? (u.updateQueue = a.updateQueue, u.flags &= -2053, a.lanes &= ~E, $r(a, u, E)) : (qt && p && pm(u), u.flags |= 1, ti(a, u, y, E), u.child);
  }
  function kx(a, u, p, y, E) {
    if (a === null) {
      var A = p.type;
      return typeof A == "function" && !eg(A) && A.defaultProps === void 0 && p.compare === null && p.defaultProps === void 0 ? (u.tag = 15, u.type = A, Fx(a, u, A, y, E)) : (a = Qf(p.type, null, y, u, u.mode, E), a.ref = u.ref, a.return = u, u.child = a);
    }
    if (A = a.child, !(a.lanes & E)) {
      var k = A.memoizedProps;
      if (p = p.compare, p = p !== null ? p : df, p(k, y) && a.ref === u.ref)
        return $r(a, u, E);
    }
    return u.flags |= 1, a = Ds(A, y), a.ref = u.ref, a.return = u, u.child = a;
  }
  function Fx(a, u, p, y, E) {
    if (a !== null && df(a.memoizedProps, y) && a.ref === u.ref)
      if (Ci = !1, (a.lanes & E) !== 0)
        a.flags & 131072 && (Ci = !0);
      else
        return u.lanes = a.lanes, $r(a, u, E);
    return Lm(a, u, p, y, E);
  }
  function zx(a, u, p) {
    var y = u.pendingProps, E = y.children, A = a !== null ? a.memoizedState : null;
    if (y.mode === "hidden")
      if (!(u.mode & 1))
        u.memoizedState = { baseLanes: 0, cachePool: null }, ut(La, Ri), Ri |= p;
      else if (p & 1073741824)
        u.memoizedState = { baseLanes: 0, cachePool: null }, y = A !== null ? A.baseLanes : p, ut(La, Ri), Ri |= y;
      else
        return a = A !== null ? A.baseLanes | p : p, u.lanes = u.childLanes = 1073741824, u.memoizedState = { baseLanes: a, cachePool: null }, u.updateQueue = null, ut(La, Ri), Ri |= a, null;
    else
      A !== null ? (y = A.baseLanes | p, u.memoizedState = null) : y = p, ut(La, Ri), Ri |= y;
    return ti(a, u, E, p), u.child;
  }
  function Bx(a, u) {
    var p = u.ref;
    (a === null && p !== null || a !== null && a.ref !== p) && (u.flags |= 512, u.flags |= 2097152);
  }
  function Lm(a, u, p, y, E) {
    var A = sn(p) ? ir : wn.current;
    return A = rn(u, A), wa(u, E), p = Em(a, u, p, y, A, E), y = Tm(), a !== null && !Ci ? (u.updateQueue = a.updateQueue, u.flags &= -2053, a.lanes &= ~E, $r(a, u, E)) : (qt && y && pm(u), u.flags |= 1, ti(a, u, p, E), u.child);
  }
  function Hx(a, u, p, y, E) {
    if (sn(p)) {
      var A = !0;
      Sa(u);
    } else
      A = !1;
    if (wa(u, E), u.stateNode === null)
      a !== null && (a.alternate = null, u.alternate = null, u.flags |= 2), tx(u, p, y), dm(u, p, y, E), y = !0;
    else if (a === null) {
      var k = u.stateNode, q = u.memoizedProps;
      k.props = q;
      var le = k.context, Ce = p.contextType;
      typeof Ce == "object" && Ce !== null ? Ce = Bi(Ce) : (Ce = sn(p) ? ir : wn.current, Ce = rn(u, Ce));
      var Xe = p.getDerivedStateFromProps, ft = typeof Xe == "function" || typeof k.getSnapshotBeforeUpdate == "function";
      ft || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (q !== y || le !== Ce) && nx(u, k, y, Ce), Rs = !1;
      var nt = u.memoizedState;
      k.state = nt, vf(u, y, k, E), le = u.memoizedState, q !== y || nt !== le || gn.current || Rs ? (typeof Xe == "function" && (hm(u, p, Xe, y), le = u.memoizedState), (q = Rs || ex(u, p, q, y, nt, le, Ce)) ? (ft || typeof k.UNSAFE_componentWillMount != "function" && typeof k.componentWillMount != "function" || (typeof k.componentWillMount == "function" && k.componentWillMount(), typeof k.UNSAFE_componentWillMount == "function" && k.UNSAFE_componentWillMount()), typeof k.componentDidMount == "function" && (u.flags |= 4194308)) : (typeof k.componentDidMount == "function" && (u.flags |= 4194308), u.memoizedProps = y, u.memoizedState = le), k.props = y, k.state = le, k.context = Ce, y = q) : (typeof k.componentDidMount == "function" && (u.flags |= 4194308), y = !1);
    } else {
      k = u.stateNode, K_(a, u), q = u.memoizedProps, Ce = u.type === u.elementType ? q : sr(u.type, q), k.props = Ce, ft = u.pendingProps, nt = k.context, le = p.contextType, typeof le == "object" && le !== null ? le = Bi(le) : (le = sn(p) ? ir : wn.current, le = rn(u, le));
      var Bt = p.getDerivedStateFromProps;
      (Xe = typeof Bt == "function" || typeof k.getSnapshotBeforeUpdate == "function") || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (q !== ft || nt !== le) && nx(u, k, y, le), Rs = !1, nt = u.memoizedState, k.state = nt, vf(u, y, k, E);
      var Ke = u.memoizedState;
      q !== ft || nt !== Ke || gn.current || Rs ? (typeof Bt == "function" && (hm(u, p, Bt, y), Ke = u.memoizedState), (Ce = Rs || ex(u, p, Ce, y, nt, Ke, le) || !1) ? (Xe || typeof k.UNSAFE_componentWillUpdate != "function" && typeof k.componentWillUpdate != "function" || (typeof k.componentWillUpdate == "function" && k.componentWillUpdate(
        y,
        Ke,
        le
      ), typeof k.UNSAFE_componentWillUpdate == "function" && k.UNSAFE_componentWillUpdate(y, Ke, le)), typeof k.componentDidUpdate == "function" && (u.flags |= 4), typeof k.getSnapshotBeforeUpdate == "function" && (u.flags |= 1024)) : (typeof k.componentDidUpdate != "function" || q === a.memoizedProps && nt === a.memoizedState || (u.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || q === a.memoizedProps && nt === a.memoizedState || (u.flags |= 1024), u.memoizedProps = y, u.memoizedState = Ke), k.props = y, k.state = Ke, k.context = le, y = Ce) : (typeof k.componentDidUpdate != "function" || q === a.memoizedProps && nt === a.memoizedState || (u.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || q === a.memoizedProps && nt === a.memoizedState || (u.flags |= 1024), y = !1);
    }
    return Im(a, u, p, y, A, E);
  }
  function Im(a, u, p, y, E, A) {
    Bx(a, u);
    var k = (u.flags & 128) !== 0;
    if (!y && !k)
      return E && Ql(u, p, !1), $r(a, u, A);
    y = u.stateNode, kC.current = u;
    var q = k && typeof p.getDerivedStateFromError != "function" ? null : y.render();
    return u.flags |= 1, a !== null && k ? (u.child = Ca(u, a.child, null, A), u.child = Ca(u, null, q, A)) : ti(a, u, q, A), u.memoizedState = y.state, E && Ql(u, p, !0), u.child;
  }
  function Vx(a) {
    var u = a.stateNode;
    u.pendingContext ? Hn(a, u.pendingContext, u.pendingContext !== u.context) : u.context && Hn(a, u.context, !1), _m(a, u.containerInfo);
  }
  function Gx(a, u, p, y, E) {
    return Aa(), ym(E), u.flags |= 256, ti(a, u, p, y), u.child;
  }
  var If = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Nf(a) {
    return { baseLanes: a, cachePool: null };
  }
  function Wx(a, u, p) {
    var y = u.pendingProps, E = Kt.current, A = !1, k = (u.flags & 128) !== 0, q;
    if ((q = k) || (q = a !== null && a.memoizedState === null ? !1 : (E & 2) !== 0), q ? (A = !0, u.flags &= -129) : (a === null || a.memoizedState !== null) && (E |= 1), ut(Kt, E & 1), a === null)
      return vm(u), a = u.memoizedState, a !== null && (a = a.dehydrated, a !== null) ? (u.mode & 1 ? As(a) ? u.lanes = 8 : u.lanes = 1073741824 : u.lanes = 1, null) : (E = y.children, a = y.fallback, A ? (y = u.mode, A = u.child, E = { mode: "hidden", children: E }, !(y & 1) && A !== null ? (A.childLanes = 0, A.pendingProps = E) : A = $f(E, y, 0, null), a = Ro(a, y, p, null), A.return = u, a.return = u, A.sibling = a, u.child = A, u.child.memoizedState = Nf(p), u.memoizedState = If, a) : Nm(u, E));
    if (E = a.memoizedState, E !== null) {
      if (q = E.dehydrated, q !== null) {
        if (k)
          return u.flags & 256 ? (u.flags &= -257, Df(a, u, p, Error(o(422)))) : u.memoizedState !== null ? (u.child = a.child, u.flags |= 128, null) : (A = y.fallback, E = u.mode, y = $f({ mode: "visible", children: y.children }, E, 0, null), A = Ro(A, E, p, null), A.flags |= 2, y.return = u, A.return = u, y.sibling = A, u.child = y, u.mode & 1 && Ca(
            u,
            a.child,
            null,
            p
          ), u.child.memoizedState = Nf(p), u.memoizedState = If, A);
        if (!(u.mode & 1))
          u = Df(a, u, p, null);
        else if (As(q))
          u = Df(a, u, p, Error(o(419)));
        else if (y = (p & a.childLanes) !== 0, Ci || y) {
          if (y = vn, y !== null) {
            switch (p & -p) {
              case 4:
                A = 2;
                break;
              case 16:
                A = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                A = 32;
                break;
              case 536870912:
                A = 268435456;
                break;
              default:
                A = 0;
            }
            y = A & (y.suspendedLanes | p) ? 0 : A, y !== 0 && y !== E.retryLane && (E.retryLane = y, Xi(a, y, -1));
          }
          $m(), u = Df(a, u, p, Error(o(421)));
        } else
          sf(q) ? (u.flags |= 128, u.child = a.child, u = KC.bind(null, a), of(q, u), u = null) : (p = E.treeContext, ge && (Ai = Qp(q), Ti = u, qt = !0, or = null, tu = !1, p !== null && (Hi[Vi++] = Kr, Hi[Vi++] = Jr, Hi[Vi++] = xo, Kr = p.id, Jr = p.overflow, xo = u)), u = Nm(u, u.pendingProps.children), u.flags |= 4096);
        return u;
      }
      return A ? (y = jx(a, u, y.children, y.fallback, p), A = u.child, E = a.child.memoizedState, A.memoizedState = E === null ? Nf(p) : { baseLanes: E.baseLanes | p, cachePool: null }, A.childLanes = a.childLanes & ~p, u.memoizedState = If, y) : (p = Xx(a, u, y.children, p), u.memoizedState = null, p);
    }
    return A ? (y = jx(a, u, y.children, y.fallback, p), A = u.child, E = a.child.memoizedState, A.memoizedState = E === null ? Nf(p) : { baseLanes: E.baseLanes | p, cachePool: null }, A.childLanes = a.childLanes & ~p, u.memoizedState = If, y) : (p = Xx(a, u, y.children, p), u.memoizedState = null, p);
  }
  function Nm(a, u) {
    return u = $f({ mode: "visible", children: u }, a.mode, 0, null), u.return = a, a.child = u;
  }
  function Xx(a, u, p, y) {
    var E = a.child;
    return a = E.sibling, p = Ds(E, { mode: "visible", children: p }), !(u.mode & 1) && (p.lanes = y), p.return = u, p.sibling = null, a !== null && (y = u.deletions, y === null ? (u.deletions = [a], u.flags |= 16) : y.push(a)), u.child = p;
  }
  function jx(a, u, p, y, E) {
    var A = u.mode;
    a = a.child;
    var k = a.sibling, q = { mode: "hidden", children: p };
    return !(A & 1) && u.child !== a ? (p = u.child, p.childLanes = 0, p.pendingProps = q, u.deletions = null) : (p = Ds(a, q), p.subtreeFlags = a.subtreeFlags & 14680064), k !== null ? y = Ds(k, y) : (y = Ro(y, A, E, null), y.flags |= 2), y.return = u, p.return = u, p.sibling = y, u.child = p, y;
  }
  function Df(a, u, p, y) {
    return y !== null && ym(y), Ca(u, a.child, null, p), a = Nm(u, u.pendingProps.children), a.flags |= 2, u.memoizedState = null, a;
  }
  function Yx(a, u, p) {
    a.lanes |= u;
    var y = a.alternate;
    y !== null && (y.lanes |= u), cm(a.return, u, p);
  }
  function Dm(a, u, p, y, E) {
    var A = a.memoizedState;
    A === null ? a.memoizedState = { isBackwards: u, rendering: null, renderingStartTime: 0, last: y, tail: p, tailMode: E } : (A.isBackwards = u, A.rendering = null, A.renderingStartTime = 0, A.last = y, A.tail = p, A.tailMode = E);
  }
  function qx(a, u, p) {
    var y = u.pendingProps, E = y.revealOrder, A = y.tail;
    if (ti(a, u, y.children, p), y = Kt.current, y & 2)
      y = y & 1 | 2, u.flags |= 128;
    else {
      if (a !== null && a.flags & 128)
        e:
          for (a = u.child; a !== null; ) {
            if (a.tag === 13)
              a.memoizedState !== null && Yx(a, p, u);
            else if (a.tag === 19)
              Yx(a, p, u);
            else if (a.child !== null) {
              a.child.return = a, a = a.child;
              continue;
            }
            if (a === u)
              break e;
            for (; a.sibling === null; ) {
              if (a.return === null || a.return === u)
                break e;
              a = a.return;
            }
            a.sibling.return = a.return, a = a.sibling;
          }
      y &= 1;
    }
    if (ut(Kt, y), !(u.mode & 1))
      u.memoizedState = null;
    else
      switch (E) {
        case "forwards":
          for (p = u.child, E = null; p !== null; )
            a = p.alternate, a !== null && Mf(a) === null && (E = p), p = p.sibling;
          p = E, p === null ? (E = u.child, u.child = null) : (E = p.sibling, p.sibling = null), Dm(u, !1, E, p, A);
          break;
        case "backwards":
          for (p = null, E = u.child, u.child = null; E !== null; ) {
            if (a = E.alternate, a !== null && Mf(a) === null) {
              u.child = E;
              break;
            }
            a = E.sibling, E.sibling = p, p = E, E = a;
          }
          Dm(u, !0, p, null, A);
          break;
        case "together":
          Dm(u, !1, null, null, void 0);
          break;
        default:
          u.memoizedState = null;
      }
    return u.child;
  }
  function $r(a, u, p) {
    if (a !== null && (u.dependencies = a.dependencies), Ia |= u.lanes, !(p & u.childLanes))
      return null;
    if (a !== null && u.child !== a.child)
      throw Error(o(153));
    if (u.child !== null) {
      for (a = u.child, p = Ds(a, a.pendingProps), u.child = p, p.return = u; a.sibling !== null; )
        a = a.sibling, p = p.sibling = Ds(a, a.pendingProps), p.return = u;
      p.sibling = null;
    }
    return u.child;
  }
  function FC(a, u, p) {
    switch (u.tag) {
      case 3:
        Vx(u), Aa();
        break;
      case 5:
        cx(u);
        break;
      case 1:
        sn(u.type) && Sa(u);
        break;
      case 4:
        _m(u, u.stateNode.containerInfo);
        break;
      case 10:
        Z_(u, u.type._context, u.memoizedProps.value);
        break;
      case 13:
        var y = u.memoizedState;
        if (y !== null)
          return y.dehydrated !== null ? (ut(Kt, Kt.current & 1), u.flags |= 128, null) : p & u.child.childLanes ? Wx(a, u, p) : (ut(Kt, Kt.current & 1), a = $r(a, u, p), a !== null ? a.sibling : null);
        ut(Kt, Kt.current & 1);
        break;
      case 19:
        if (y = (p & u.childLanes) !== 0, a.flags & 128) {
          if (y)
            return qx(
              a,
              u,
              p
            );
          u.flags |= 128;
        }
        var E = u.memoizedState;
        if (E !== null && (E.rendering = null, E.tail = null, E.lastEffect = null), ut(Kt, Kt.current), y)
          break;
        return null;
      case 22:
      case 23:
        return u.lanes = 0, zx(a, u, p);
    }
    return $r(a, u, p);
  }
  function zC(a, u) {
    switch (mm(u), u.tag) {
      case 1:
        return sn(u.type) && Cs(), a = u.flags, a & 65536 ? (u.flags = a & -65537 | 128, u) : null;
      case 3:
        return Pa(), Ot(gn), Ot(wn), Mm(), a = u.flags, a & 65536 && !(a & 128) ? (u.flags = a & -65537 | 128, u) : null;
      case 5:
        return xm(u), null;
      case 13:
        if (Ot(Kt), a = u.memoizedState, a !== null && a.dehydrated !== null) {
          if (u.alternate === null)
            throw Error(o(340));
          Aa();
        }
        return a = u.flags, a & 65536 ? (u.flags = a & -65537 | 128, u) : null;
      case 19:
        return Ot(Kt), null;
      case 4:
        return Pa(), null;
      case 10:
        return um(u.type._context), null;
      case 22:
      case 23:
        return Qm(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Uf = !1, wo = !1, BC = typeof WeakSet == "function" ? WeakSet : Set, Ue = null;
  function Of(a, u) {
    var p = a.ref;
    if (p !== null)
      if (typeof p == "function")
        try {
          p(null);
        } catch (y) {
          di(a, u, y);
        }
      else
        p.current = null;
  }
  function Um(a, u, p) {
    try {
      p();
    } catch (y) {
      di(a, u, y);
    }
  }
  var Zx = !1;
  function HC(a, u) {
    for (X(a.containerInfo), Ue = u; Ue !== null; )
      if (a = Ue, u = a.child, (a.subtreeFlags & 1028) !== 0 && u !== null)
        u.return = a, Ue = u;
      else
        for (; Ue !== null; ) {
          a = Ue;
          try {
            var p = a.alternate;
            if (a.flags & 1024)
              switch (a.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (p !== null) {
                    var y = p.memoizedProps, E = p.memoizedState, A = a.stateNode, k = A.getSnapshotBeforeUpdate(a.elementType === a.type ? y : sr(a.type, y), E);
                    A.__reactInternalSnapshotBeforeUpdate = k;
                  }
                  break;
                case 3:
                  Re && Ae(a.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(o(163));
              }
          } catch (q) {
            di(a, a.return, q);
          }
          if (u = a.sibling, u !== null) {
            u.return = a.return, Ue = u;
            break;
          }
          Ue = a.return;
        }
    return p = Zx, Zx = !1, p;
  }
  function Eo(a, u, p) {
    var y = u.updateQueue;
    if (y = y !== null ? y.lastEffect : null, y !== null) {
      var E = y = y.next;
      do {
        if ((E.tag & a) === a) {
          var A = E.destroy;
          E.destroy = void 0, A !== void 0 && Um(u, p, A);
        }
        E = E.next;
      } while (E !== y);
    }
  }
  function du(a, u) {
    if (u = u.updateQueue, u = u !== null ? u.lastEffect : null, u !== null) {
      var p = u = u.next;
      do {
        if ((p.tag & a) === a) {
          var y = p.create;
          p.destroy = y();
        }
        p = p.next;
      } while (p !== u);
    }
  }
  function Om(a) {
    var u = a.ref;
    if (u !== null) {
      var p = a.stateNode;
      switch (a.tag) {
        case 5:
          a = oe(p);
          break;
        default:
          a = p;
      }
      typeof u == "function" ? u(a) : u.current = a;
    }
  }
  function Kx(a, u, p) {
    if (Cr && typeof Cr.onCommitFiberUnmount == "function")
      try {
        Cr.onCommitFiberUnmount(ff, u);
      } catch {
      }
    switch (u.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (a = u.updateQueue, a !== null && (a = a.lastEffect, a !== null)) {
          var y = a = a.next;
          do {
            var E = y, A = E.destroy;
            E = E.tag, A !== void 0 && (E & 2 || E & 4) && Um(u, p, A), y = y.next;
          } while (y !== a);
        }
        break;
      case 1:
        if (Of(u, p), a = u.stateNode, typeof a.componentWillUnmount == "function")
          try {
            a.props = u.memoizedProps, a.state = u.memoizedState, a.componentWillUnmount();
          } catch (k) {
            di(
              u,
              p,
              k
            );
          }
        break;
      case 5:
        Of(u, p);
        break;
      case 4:
        Re ? n1(a, u, p) : z && z && (u = u.stateNode.containerInfo, p = Et(u), Sn(u, p));
    }
  }
  function Jx(a, u, p) {
    for (var y = u; ; )
      if (Kx(a, y, p), y.child === null || Re && y.tag === 4) {
        if (y === u)
          break;
        for (; y.sibling === null; ) {
          if (y.return === null || y.return === u)
            return;
          y = y.return;
        }
        y.sibling.return = y.return, y = y.sibling;
      } else
        y.child.return = y, y = y.child;
  }
  function Qx(a) {
    var u = a.alternate;
    u !== null && (a.alternate = null, Qx(u)), a.child = null, a.deletions = null, a.sibling = null, a.tag === 5 && (u = a.stateNode, u !== null && He(u)), a.stateNode = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
  }
  function $x(a) {
    return a.tag === 5 || a.tag === 3 || a.tag === 4;
  }
  function e1(a) {
    e:
      for (; ; ) {
        for (; a.sibling === null; ) {
          if (a.return === null || $x(a.return))
            return null;
          a = a.return;
        }
        for (a.sibling.return = a.return, a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
          if (a.flags & 2 || a.child === null || a.tag === 4)
            continue e;
          a.child.return = a, a = a.child;
        }
        if (!(a.flags & 2))
          return a.stateNode;
      }
  }
  function t1(a) {
    if (Re) {
      e: {
        for (var u = a.return; u !== null; ) {
          if ($x(u))
            break e;
          u = u.return;
        }
        throw Error(o(160));
      }
      var p = u;
      switch (p.tag) {
        case 5:
          u = p.stateNode, p.flags & 32 && (pe(u), p.flags &= -33), p = e1(a), Fm(a, p, u);
          break;
        case 3:
        case 4:
          u = p.stateNode.containerInfo, p = e1(a), km(a, p, u);
          break;
        default:
          throw Error(o(161));
      }
    }
  }
  function km(a, u, p) {
    var y = a.tag;
    if (y === 5 || y === 6)
      a = a.stateNode, u ? et(p, a, u) : qe(p, a);
    else if (y !== 4 && (a = a.child, a !== null))
      for (km(a, u, p), a = a.sibling; a !== null; )
        km(a, u, p), a = a.sibling;
  }
  function Fm(a, u, p) {
    var y = a.tag;
    if (y === 5 || y === 6)
      a = a.stateNode, u ? $e(p, a, u) : Pe(p, a);
    else if (y !== 4 && (a = a.child, a !== null))
      for (Fm(a, u, p), a = a.sibling; a !== null; )
        Fm(a, u, p), a = a.sibling;
  }
  function n1(a, u, p) {
    for (var y = u, E = !1, A, k; ; ) {
      if (!E) {
        E = y.return;
        e:
          for (; ; ) {
            if (E === null)
              throw Error(o(160));
            switch (A = E.stateNode, E.tag) {
              case 5:
                k = !1;
                break e;
              case 3:
                A = A.containerInfo, k = !0;
                break e;
              case 4:
                A = A.containerInfo, k = !0;
                break e;
            }
            E = E.return;
          }
        E = !0;
      }
      if (y.tag === 5 || y.tag === 6)
        Jx(a, y, p), k ? B(A, y.stateNode) : Ve(A, y.stateNode);
      else if (y.tag === 18)
        k ? tt(A, y.stateNode) : We(A, y.stateNode);
      else if (y.tag === 4) {
        if (y.child !== null) {
          A = y.stateNode.containerInfo, k = !0, y.child.return = y, y = y.child;
          continue;
        }
      } else if (Kx(a, y, p), y.child !== null) {
        y.child.return = y, y = y.child;
        continue;
      }
      if (y === u)
        break;
      for (; y.sibling === null; ) {
        if (y.return === null || y.return === u)
          return;
        y = y.return, y.tag === 4 && (E = !1);
      }
      y.sibling.return = y.return, y = y.sibling;
    }
  }
  function zm(a, u) {
    if (Re) {
      switch (u.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Eo(3, u, u.return), du(3, u), Eo(5, u, u.return);
          return;
        case 1:
          return;
        case 5:
          var p = u.stateNode;
          if (p != null) {
            var y = u.memoizedProps;
            a = a !== null ? a.memoizedProps : y;
            var E = u.type, A = u.updateQueue;
            u.updateQueue = null, A !== null && Qe(p, A, E, a, y, u);
          }
          return;
        case 6:
          if (u.stateNode === null)
            throw Error(o(162));
          p = u.memoizedProps, be(u.stateNode, a !== null ? a.memoizedProps : p, p);
          return;
        case 3:
          ge && a !== null && a.memoizedState.isDehydrated && Q(u.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          kf(u);
          return;
        case 19:
          kf(u);
          return;
        case 17:
          return;
      }
      throw Error(o(163));
    }
    switch (u.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Eo(3, u, u.return), du(3, u), Eo(5, u, u.return);
        return;
      case 12:
        return;
      case 13:
        kf(u);
        return;
      case 19:
        kf(u);
        return;
      case 3:
        ge && a !== null && a.memoizedState.isDehydrated && Q(u.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e:
      if (z) {
        switch (u.tag) {
          case 1:
          case 5:
          case 6:
            break e;
          case 3:
          case 4:
            u = u.stateNode, Sn(u.containerInfo, u.pendingChildren);
            break e;
        }
        throw Error(o(163));
      }
  }
  function kf(a) {
    var u = a.updateQueue;
    if (u !== null) {
      a.updateQueue = null;
      var p = a.stateNode;
      p === null && (p = a.stateNode = new BC()), u.forEach(function(y) {
        var E = JC.bind(null, a, y);
        p.has(y) || (p.add(y), y.then(E, E));
      });
    }
  }
  function VC(a, u) {
    for (Ue = u; Ue !== null; ) {
      u = Ue;
      var p = u.deletions;
      if (p !== null)
        for (var y = 0; y < p.length; y++) {
          var E = p[y];
          try {
            var A = a;
            Re ? n1(A, E, u) : Jx(A, E, u);
            var k = E.alternate;
            k !== null && (k.return = null), E.return = null;
          } catch (Ze) {
            di(E, u, Ze);
          }
        }
      if (p = u.child, u.subtreeFlags & 12854 && p !== null)
        p.return = u, Ue = p;
      else
        for (; Ue !== null; ) {
          u = Ue;
          try {
            var q = u.flags;
            if (q & 32 && Re && pe(u.stateNode), q & 512) {
              var le = u.alternate;
              if (le !== null) {
                var Ce = le.ref;
                Ce !== null && (typeof Ce == "function" ? Ce(null) : Ce.current = null);
              }
            }
            if (q & 8192)
              switch (u.tag) {
                case 13:
                  if (u.memoizedState !== null) {
                    var Xe = u.alternate;
                    (Xe === null || Xe.memoizedState === null) && (jm = Pn());
                  }
                  break;
                case 22:
                  var ft = u.memoizedState !== null, nt = u.alternate, Bt = nt !== null && nt.memoizedState !== null;
                  if (p = u, Re) {
                    e:
                      if (y = p, E = ft, A = null, Re)
                        for (var Ke = y; ; ) {
                          if (Ke.tag === 5) {
                            if (A === null) {
                              A = Ke;
                              var Xn = Ke.stateNode;
                              E ? Ne(Xn) : Me(Ke.stateNode, Ke.memoizedProps);
                            }
                          } else if (Ke.tag === 6) {
                            if (A === null) {
                              var Yi = Ke.stateNode;
                              E ? H(Yi) : ie(Yi, Ke.memoizedProps);
                            }
                          } else if ((Ke.tag !== 22 && Ke.tag !== 23 || Ke.memoizedState === null || Ke === y) && Ke.child !== null) {
                            Ke.child.return = Ke, Ke = Ke.child;
                            continue;
                          }
                          if (Ke === y)
                            break;
                          for (; Ke.sibling === null; ) {
                            if (Ke.return === null || Ke.return === y)
                              break e;
                            A === Ke && (A = null), Ke = Ke.return;
                          }
                          A === Ke && (A = null), Ke.sibling.return = Ke.return, Ke = Ke.sibling;
                        }
                  }
                  if (ft && !Bt && p.mode & 1) {
                    Ue = p;
                    for (var ee = p.child; ee !== null; ) {
                      for (p = Ue = ee; Ue !== null; ) {
                        y = Ue;
                        var Z = y.child;
                        switch (y.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            Eo(4, y, y.return);
                            break;
                          case 1:
                            Of(y, y.return);
                            var re = y.stateNode;
                            if (typeof re.componentWillUnmount == "function") {
                              var ke = y.return;
                              try {
                                re.props = y.memoizedProps, re.state = y.memoizedState, re.componentWillUnmount();
                              } catch (Ze) {
                                di(
                                  y,
                                  ke,
                                  Ze
                                );
                              }
                            }
                            break;
                          case 5:
                            Of(y, y.return);
                            break;
                          case 22:
                            if (y.memoizedState !== null) {
                              s1(p);
                              continue;
                            }
                        }
                        Z !== null ? (Z.return = y, Ue = Z) : s1(p);
                      }
                      ee = ee.sibling;
                    }
                  }
              }
            switch (q & 4102) {
              case 2:
                t1(u), u.flags &= -3;
                break;
              case 6:
                t1(u), u.flags &= -3, zm(u.alternate, u);
                break;
              case 4096:
                u.flags &= -4097;
                break;
              case 4100:
                u.flags &= -4097, zm(u.alternate, u);
                break;
              case 4:
                zm(u.alternate, u);
            }
          } catch (Ze) {
            di(u, u.return, Ze);
          }
          if (p = u.sibling, p !== null) {
            p.return = u.return, Ue = p;
            break;
          }
          Ue = u.return;
        }
    }
  }
  function GC(a, u, p) {
    Ue = a, i1(a);
  }
  function i1(a, u, p) {
    for (var y = (a.mode & 1) !== 0; Ue !== null; ) {
      var E = Ue, A = E.child;
      if (E.tag === 22 && y) {
        var k = E.memoizedState !== null || Uf;
        if (!k) {
          var q = E.alternate, le = q !== null && q.memoizedState !== null || wo;
          q = Uf;
          var Ce = wo;
          if (Uf = k, (wo = le) && !Ce)
            for (Ue = E; Ue !== null; )
              k = Ue, le = k.child, k.tag === 22 && k.memoizedState !== null ? o1(E) : le !== null ? (le.return = k, Ue = le) : o1(E);
          for (; A !== null; )
            Ue = A, i1(A), A = A.sibling;
          Ue = E, Uf = q, wo = Ce;
        }
        r1(a);
      } else
        E.subtreeFlags & 8772 && A !== null ? (A.return = E, Ue = A) : r1(a);
    }
  }
  function r1(a) {
    for (; Ue !== null; ) {
      var u = Ue;
      if (u.flags & 8772) {
        var p = u.alternate;
        try {
          if (u.flags & 8772)
            switch (u.tag) {
              case 0:
              case 11:
              case 15:
                wo || du(5, u);
                break;
              case 1:
                var y = u.stateNode;
                if (u.flags & 4 && !wo)
                  if (p === null)
                    y.componentDidMount();
                  else {
                    var E = u.elementType === u.type ? p.memoizedProps : sr(u.type, p.memoizedProps);
                    y.componentDidUpdate(E, p.memoizedState, y.__reactInternalSnapshotBeforeUpdate);
                  }
                var A = u.updateQueue;
                A !== null && Q_(u, A, y);
                break;
              case 3:
                var k = u.updateQueue;
                if (k !== null) {
                  if (p = null, u.child !== null)
                    switch (u.child.tag) {
                      case 5:
                        p = oe(u.child.stateNode);
                        break;
                      case 1:
                        p = u.child.stateNode;
                    }
                  Q_(u, k, p);
                }
                break;
              case 5:
                var q = u.stateNode;
                p === null && u.flags & 4 && ue(q, u.type, u.memoizedProps, u);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (ge && u.memoizedState === null) {
                  var le = u.alternate;
                  if (le !== null) {
                    var Ce = le.memoizedState;
                    if (Ce !== null) {
                      var Xe = Ce.dehydrated;
                      Xe !== null && he(Xe);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
          wo || u.flags & 512 && Om(u);
        } catch (ft) {
          di(u, u.return, ft);
        }
      }
      if (u === a) {
        Ue = null;
        break;
      }
      if (p = u.sibling, p !== null) {
        p.return = u.return, Ue = p;
        break;
      }
      Ue = u.return;
    }
  }
  function s1(a) {
    for (; Ue !== null; ) {
      var u = Ue;
      if (u === a) {
        Ue = null;
        break;
      }
      var p = u.sibling;
      if (p !== null) {
        p.return = u.return, Ue = p;
        break;
      }
      Ue = u.return;
    }
  }
  function o1(a) {
    for (; Ue !== null; ) {
      var u = Ue;
      try {
        switch (u.tag) {
          case 0:
          case 11:
          case 15:
            var p = u.return;
            try {
              du(4, u);
            } catch (le) {
              di(u, p, le);
            }
            break;
          case 1:
            var y = u.stateNode;
            if (typeof y.componentDidMount == "function") {
              var E = u.return;
              try {
                y.componentDidMount();
              } catch (le) {
                di(u, E, le);
              }
            }
            var A = u.return;
            try {
              Om(u);
            } catch (le) {
              di(u, A, le);
            }
            break;
          case 5:
            var k = u.return;
            try {
              Om(u);
            } catch (le) {
              di(u, k, le);
            }
        }
      } catch (le) {
        di(u, u.return, le);
      }
      if (u === a) {
        Ue = null;
        break;
      }
      var q = u.sibling;
      if (q !== null) {
        q.return = u.return, Ue = q;
        break;
      }
      Ue = u.return;
    }
  }
  var Ff = 0, zf = 1, Bf = 2, Hf = 3, Vf = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var pu = Symbol.for;
    Ff = pu("selector.component"), zf = pu("selector.has_pseudo_class"), Bf = pu("selector.role"), Hf = pu("selector.test_id"), Vf = pu("selector.text");
  }
  function Bm(a) {
    var u = fe(a);
    if (u != null) {
      if (typeof u.memoizedProps["data-testname"] != "string")
        throw Error(o(364));
      return u;
    }
    if (a = mt(a), a === null)
      throw Error(o(362));
    return a.stateNode.current;
  }
  function Hm(a, u) {
    switch (u.$$typeof) {
      case Ff:
        if (a.type === u.value)
          return !0;
        break;
      case zf:
        e: {
          u = u.value, a = [a, 0];
          for (var p = 0; p < a.length; ) {
            var y = a[p++], E = a[p++], A = u[E];
            if (y.tag !== 5 || !I(y)) {
              for (; A != null && Hm(y, A); )
                E++, A = u[E];
              if (E === u.length) {
                u = !0;
                break e;
              } else
                for (y = y.child; y !== null; )
                  a.push(y, E), y = y.sibling;
            }
          }
          u = !1;
        }
        return u;
      case Bf:
        if (a.tag === 5 && ae(a.stateNode, u.value))
          return !0;
        break;
      case Vf:
        if ((a.tag === 5 || a.tag === 6) && (a = F(a), a !== null && 0 <= a.indexOf(u.value)))
          return !0;
        break;
      case Hf:
        if (a.tag === 5 && (a = a.memoizedProps["data-testname"], typeof a == "string" && a.toLowerCase() === u.value.toLowerCase()))
          return !0;
        break;
      default:
        throw Error(o(365));
    }
    return !1;
  }
  function Vm(a) {
    switch (a.$$typeof) {
      case Ff:
        return "<" + (L(a.value) || "Unknown") + ">";
      case zf:
        return ":has(" + (Vm(a) || "") + ")";
      case Bf:
        return '[role="' + a.value + '"]';
      case Vf:
        return '"' + a.value + '"';
      case Hf:
        return '[data-testname="' + a.value + '"]';
      default:
        throw Error(o(365));
    }
  }
  function a1(a, u) {
    var p = [];
    a = [a, 0];
    for (var y = 0; y < a.length; ) {
      var E = a[y++], A = a[y++], k = u[A];
      if (E.tag !== 5 || !I(E)) {
        for (; k != null && Hm(E, k); )
          A++, k = u[A];
        if (A === u.length)
          p.push(E);
        else
          for (E = E.child; E !== null; )
            a.push(E, A), E = E.sibling;
      }
    }
    return p;
  }
  function Gm(a, u) {
    if (!Je)
      throw Error(o(363));
    a = Bm(a), a = a1(a, u), u = [], a = Array.from(a);
    for (var p = 0; p < a.length; ) {
      var y = a[p++];
      if (y.tag === 5)
        I(y) || u.push(y.stateNode);
      else
        for (y = y.child; y !== null; )
          a.push(y), y = y.sibling;
    }
    return u;
  }
  var WC = Math.ceil, Gf = l.ReactCurrentDispatcher, Wm = l.ReactCurrentOwner, cn = l.ReactCurrentBatchConfig, Mt = 0, vn = null, yn = null, Un = 0, Ri = 0, La = ct(0), En = 0, mu = null, Ia = 0, Wf = 0, Xm = 0, gu = null, fi = null, jm = 0, Ym = 1 / 0;
  function Na() {
    Ym = Pn() + 500;
  }
  var Xf = !1, qm = null, bs = null, jf = !1, Ls = null, Yf = 0, vu = 0, Zm = null, qf = -1, Zf = 0;
  function ni() {
    return Mt & 6 ? Pn() : qf !== -1 ? qf : qf = Pn();
  }
  function Is(a) {
    return a.mode & 1 ? Mt & 2 && Un !== 0 ? Un & -Un : AC.transition !== null ? (Zf === 0 && (a = lf, lf <<= 1, !(lf & 4194240) && (lf = 64), Zf = a), Zf) : (a = Pt, a !== 0 ? a : ve()) : 1;
  }
  function Xi(a, u, p) {
    if (50 < vu)
      throw vu = 0, Zm = null, Error(o(185));
    var y = Kf(a, u);
    return y === null ? null : (eu(y, u, p), (!(Mt & 2) || y !== vn) && (y === vn && (!(Mt & 2) && (Wf |= u), En === 4 && Ns(y, Un)), hi(y, p), u === 1 && Mt === 0 && !(a.mode & 1) && (Na(), hf && Pr())), y);
  }
  function Kf(a, u) {
    a.lanes |= u;
    var p = a.alternate;
    for (p !== null && (p.lanes |= u), p = a, a = a.return; a !== null; )
      a.childLanes |= u, p = a.alternate, p !== null && (p.childLanes |= u), p = a, a = a.return;
    return p.tag === 3 ? p.stateNode : null;
  }
  function hi(a, u) {
    var p = a.callbackNode;
    vC(a, u);
    var y = cf(a, a === vn ? Un : 0);
    if (y === 0)
      p !== null && Y_(p), a.callbackNode = null, a.callbackPriority = 0;
    else if (u = y & -y, a.callbackPriority !== u) {
      if (p != null && Y_(p), u === 1)
        a.tag === 0 ? TC(u1.bind(null, a)) : q_(u1.bind(null, a)), Oe ? Fe(function() {
          Mt === 0 && Pr();
        }) : im(rm, Pr), p = null;
      else {
        switch (j_(y)) {
          case 1:
            p = rm;
            break;
          case 4:
            p = SC;
            break;
          case 16:
            p = sm;
            break;
          case 536870912:
            p = MC;
            break;
          default:
            p = sm;
        }
        p = y1(p, l1.bind(null, a));
      }
      a.callbackPriority = u, a.callbackNode = p;
    }
  }
  function l1(a, u) {
    if (qf = -1, Zf = 0, Mt & 6)
      throw Error(o(327));
    var p = a.callbackNode;
    if (Co() && a.callbackNode !== p)
      return null;
    var y = cf(a, a === vn ? Un : 0);
    if (y === 0)
      return null;
    if (y & 30 || y & a.expiredLanes || u)
      u = Jf(a, y);
    else {
      u = y;
      var E = Mt;
      Mt |= 2;
      var A = h1();
      (vn !== a || Un !== u) && (Na(), To(a, u));
      do
        try {
          YC();
          break;
        } catch (q) {
          f1(a, q);
        }
      while (1);
      lm(), Gf.current = A, Mt = E, yn !== null ? u = 0 : (vn = null, Un = 0, u = En);
    }
    if (u !== 0) {
      if (u === 2 && (E = em(a), E !== 0 && (y = E, u = Km(a, E))), u === 1)
        throw p = mu, To(a, 0), Ns(a, y), hi(a, Pn()), p;
      if (u === 6)
        Ns(a, y);
      else {
        if (E = a.current.alternate, !(y & 30) && !XC(E) && (u = Jf(a, y), u === 2 && (A = em(a), A !== 0 && (y = A, u = Km(a, A))), u === 1))
          throw p = mu, To(a, 0), Ns(a, y), hi(a, Pn()), p;
        switch (a.finishedWork = E, a.finishedLanes = y, u) {
          case 0:
          case 1:
            throw Error(o(345));
          case 2:
            Ao(a, fi);
            break;
          case 3:
            if (Ns(a, y), (y & 130023424) === y && (u = jm + 500 - Pn(), 10 < u)) {
              if (cf(a, 0) !== 0)
                break;
              if (E = a.suspendedLanes, (E & y) !== y) {
                ni(), a.pingedLanes |= a.suspendedLanes & E;
                break;
              }
              a.timeoutHandle = Be(Ao.bind(null, a, fi), u);
              break;
            }
            Ao(a, fi);
            break;
          case 4:
            if (Ns(a, y), (y & 4194240) === y)
              break;
            for (u = a.eventTimes, E = -1; 0 < y; ) {
              var k = 31 - rr(y);
              A = 1 << k, k = u[k], k > E && (E = k), y &= ~A;
            }
            if (y = E, y = Pn() - y, y = (120 > y ? 120 : 480 > y ? 480 : 1080 > y ? 1080 : 1920 > y ? 1920 : 3e3 > y ? 3e3 : 4320 > y ? 4320 : 1960 * WC(y / 1960)) - y, 10 < y) {
              a.timeoutHandle = Be(Ao.bind(null, a, fi), y);
              break;
            }
            Ao(a, fi);
            break;
          case 5:
            Ao(a, fi);
            break;
          default:
            throw Error(o(329));
        }
      }
    }
    return hi(a, Pn()), a.callbackNode === p ? l1.bind(null, a) : null;
  }
  function Km(a, u) {
    var p = gu;
    return a.current.memoizedState.isDehydrated && (To(a, u).flags |= 256), a = Jf(a, u), a !== 2 && (u = fi, fi = p, u !== null && Jm(u)), a;
  }
  function Jm(a) {
    fi === null ? fi = a : fi.push.apply(fi, a);
  }
  function XC(a) {
    for (var u = a; ; ) {
      if (u.flags & 16384) {
        var p = u.updateQueue;
        if (p !== null && (p = p.stores, p !== null))
          for (var y = 0; y < p.length; y++) {
            var E = p[y], A = E.getSnapshot;
            E = E.value;
            try {
              if (!Rr(A(), E))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (p = u.child, u.subtreeFlags & 16384 && p !== null)
        p.return = u, u = p;
      else {
        if (u === a)
          break;
        for (; u.sibling === null; ) {
          if (u.return === null || u.return === a)
            return !0;
          u = u.return;
        }
        u.sibling.return = u.return, u = u.sibling;
      }
    }
    return !0;
  }
  function Ns(a, u) {
    for (u &= ~Xm, u &= ~Wf, a.suspendedLanes |= u, a.pingedLanes &= ~u, a = a.expirationTimes; 0 < u; ) {
      var p = 31 - rr(u), y = 1 << p;
      a[p] = -1, u &= ~y;
    }
  }
  function u1(a) {
    if (Mt & 6)
      throw Error(o(327));
    Co();
    var u = cf(a, 0);
    if (!(u & 1))
      return hi(a, Pn()), null;
    var p = Jf(a, u);
    if (a.tag !== 0 && p === 2) {
      var y = em(a);
      y !== 0 && (u = y, p = Km(a, y));
    }
    if (p === 1)
      throw p = mu, To(a, 0), Ns(a, u), hi(a, Pn()), p;
    if (p === 6)
      throw Error(o(345));
    return a.finishedWork = a.current.alternate, a.finishedLanes = u, Ao(a, fi), hi(a, Pn()), null;
  }
  function c1(a) {
    Ls !== null && Ls.tag === 0 && !(Mt & 6) && Co();
    var u = Mt;
    Mt |= 1;
    var p = cn.transition, y = Pt;
    try {
      if (cn.transition = null, Pt = 1, a)
        return a();
    } finally {
      Pt = y, cn.transition = p, Mt = u, !(Mt & 6) && Pr();
    }
  }
  function Qm() {
    Ri = La.current, Ot(La);
  }
  function To(a, u) {
    a.finishedWork = null, a.finishedLanes = 0;
    var p = a.timeoutHandle;
    if (p !== vt && (a.timeoutHandle = vt, je(p)), yn !== null)
      for (p = yn.return; p !== null; ) {
        var y = p;
        switch (mm(y), y.tag) {
          case 1:
            y = y.type.childContextTypes, y != null && Cs();
            break;
          case 3:
            Pa(), Ot(gn), Ot(wn), Mm();
            break;
          case 5:
            xm(y);
            break;
          case 4:
            Pa();
            break;
          case 13:
            Ot(Kt);
            break;
          case 19:
            Ot(Kt);
            break;
          case 10:
            um(y.type._context);
            break;
          case 22:
          case 23:
            Qm();
        }
        p = p.return;
      }
    if (vn = a, yn = a = Ds(a.current, null), Un = Ri = u, En = 0, mu = null, Xm = Wf = Ia = 0, fi = gu = null, br !== null) {
      for (u = 0; u < br.length; u++)
        if (p = br[u], y = p.interleaved, y !== null) {
          p.interleaved = null;
          var E = y.next, A = p.pending;
          if (A !== null) {
            var k = A.next;
            A.next = E, y.next = k;
          }
          p.pending = y;
        }
      br = null;
    }
    return a;
  }
  function f1(a, u) {
    do {
      var p = yn;
      try {
        if (lm(), wf.current = Pf, Ef) {
          for (var y = on.memoizedState; y !== null; ) {
            var E = y.queue;
            E !== null && (E.pending = null), y = y.next;
          }
          Ef = !1;
        }
        if (ba = 0, bn = Vn = on = null, ou = !1, au = 0, Wm.current = null, p === null || p.return === null) {
          En = 1, mu = u, yn = null;
          break;
        }
        e: {
          var A = a, k = p.return, q = p, le = u;
          if (u = Un, q.flags |= 32768, le !== null && typeof le == "object" && typeof le.then == "function") {
            var Ce = le, Xe = q, ft = Xe.tag;
            if (!(Xe.mode & 1) && (ft === 0 || ft === 11 || ft === 15)) {
              var nt = Xe.alternate;
              nt ? (Xe.updateQueue = nt.updateQueue, Xe.memoizedState = nt.memoizedState, Xe.lanes = nt.lanes) : (Xe.updateQueue = null, Xe.memoizedState = null);
            }
            var Bt = Ix(k);
            if (Bt !== null) {
              Bt.flags &= -257, Nx(Bt, k, q, A, u), Bt.mode & 1 && Lx(A, Ce, u), u = Bt, le = Ce;
              var Ke = u.updateQueue;
              if (Ke === null) {
                var Xn = /* @__PURE__ */ new Set();
                Xn.add(le), u.updateQueue = Xn;
              } else
                Ke.add(le);
              break e;
            } else {
              if (!(u & 1)) {
                Lx(A, Ce, u), $m();
                break e;
              }
              le = Error(o(426));
            }
          } else if (qt && q.mode & 1) {
            var Yi = Ix(k);
            if (Yi !== null) {
              !(Yi.flags & 65536) && (Yi.flags |= 256), Nx(Yi, k, q, A, u), ym(le);
              break e;
            }
          }
          A = le, En !== 4 && (En = 2), gu === null ? gu = [A] : gu.push(A), le = Pm(le, q), q = k;
          do {
            switch (q.tag) {
              case 3:
                q.flags |= 65536, u &= -u, q.lanes |= u;
                var ee = Px(q, le, u);
                J_(q, ee);
                break e;
              case 1:
                A = le;
                var Z = q.type, re = q.stateNode;
                if (!(q.flags & 128) && (typeof Z.getDerivedStateFromError == "function" || re !== null && typeof re.componentDidCatch == "function" && (bs === null || !bs.has(re)))) {
                  q.flags |= 65536, u &= -u, q.lanes |= u;
                  var ke = bx(q, A, u);
                  J_(q, ke);
                  break e;
                }
            }
            q = q.return;
          } while (q !== null);
        }
        p1(p);
      } catch (Ze) {
        u = Ze, yn === p && p !== null && (yn = p = p.return);
        continue;
      }
      break;
    } while (1);
  }
  function h1() {
    var a = Gf.current;
    return Gf.current = Pf, a === null ? Pf : a;
  }
  function $m() {
    (En === 0 || En === 3 || En === 2) && (En = 4), vn === null || !(Ia & 268435455) && !(Wf & 268435455) || Ns(vn, Un);
  }
  function Jf(a, u) {
    var p = Mt;
    Mt |= 2;
    var y = h1();
    vn === a && Un === u || To(a, u);
    do
      try {
        jC();
        break;
      } catch (E) {
        f1(a, E);
      }
    while (1);
    if (lm(), Mt = p, Gf.current = y, yn !== null)
      throw Error(o(261));
    return vn = null, Un = 0, En;
  }
  function jC() {
    for (; yn !== null; )
      d1(yn);
  }
  function YC() {
    for (; yn !== null && !_C(); )
      d1(yn);
  }
  function d1(a) {
    var u = v1(a.alternate, a, Ri);
    a.memoizedProps = a.pendingProps, u === null ? p1(a) : yn = u, Wm.current = null;
  }
  function p1(a) {
    var u = a;
    do {
      var p = u.alternate;
      if (a = u.return, u.flags & 32768) {
        if (p = zC(p, u), p !== null) {
          p.flags &= 32767, yn = p;
          return;
        }
        if (a !== null)
          a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          En = 6, yn = null;
          return;
        }
      } else if (p = OC(p, u, Ri), p !== null) {
        yn = p;
        return;
      }
      if (u = u.sibling, u !== null) {
        yn = u;
        return;
      }
      yn = u = a;
    } while (u !== null);
    En === 0 && (En = 5);
  }
  function Ao(a, u) {
    var p = Pt, y = cn.transition;
    try {
      cn.transition = null, Pt = 1, qC(a, u, p);
    } finally {
      cn.transition = y, Pt = p;
    }
    return null;
  }
  function qC(a, u, p) {
    do
      Co();
    while (Ls !== null);
    if (Mt & 6)
      throw Error(o(327));
    var y = a.finishedWork, E = a.finishedLanes;
    if (y === null)
      return null;
    if (a.finishedWork = null, a.finishedLanes = 0, y === a.current)
      throw Error(o(177));
    a.callbackNode = null, a.callbackPriority = 0;
    var A = y.lanes | y.childLanes;
    if (yC(a, A), a === vn && (yn = vn = null, Un = 0), !(y.subtreeFlags & 2064) && !(y.flags & 2064) || jf || (jf = !0, y1(sm, function() {
      return Co(), null;
    })), A = (y.flags & 15990) !== 0, y.subtreeFlags & 15990 || A) {
      A = cn.transition, cn.transition = null;
      var k = Pt;
      Pt = 1;
      var q = Mt;
      Mt |= 4, Wm.current = null, HC(a, y), VC(a, y), W(a.containerInfo), a.current = y, GC(y), xC(), Mt = q, Pt = k, cn.transition = A;
    } else
      a.current = y;
    if (jf && (jf = !1, Ls = a, Yf = E), A = a.pendingLanes, A === 0 && (bs = null), wC(y.stateNode), hi(a, Pn()), u !== null)
      for (p = a.onRecoverableError, y = 0; y < u.length; y++)
        p(u[y]);
    if (Xf)
      throw Xf = !1, a = qm, qm = null, a;
    return Yf & 1 && a.tag !== 0 && Co(), A = a.pendingLanes, A & 1 ? a === Zm ? vu++ : (vu = 0, Zm = a) : vu = 0, Pr(), null;
  }
  function Co() {
    if (Ls !== null) {
      var a = j_(Yf), u = cn.transition, p = Pt;
      try {
        if (cn.transition = null, Pt = 16 > a ? 16 : a, Ls === null)
          var y = !1;
        else {
          if (a = Ls, Ls = null, Yf = 0, Mt & 6)
            throw Error(o(331));
          var E = Mt;
          for (Mt |= 4, Ue = a.current; Ue !== null; ) {
            var A = Ue, k = A.child;
            if (Ue.flags & 16) {
              var q = A.deletions;
              if (q !== null) {
                for (var le = 0; le < q.length; le++) {
                  var Ce = q[le];
                  for (Ue = Ce; Ue !== null; ) {
                    var Xe = Ue;
                    switch (Xe.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Eo(8, Xe, A);
                    }
                    var ft = Xe.child;
                    if (ft !== null)
                      ft.return = Xe, Ue = ft;
                    else
                      for (; Ue !== null; ) {
                        Xe = Ue;
                        var nt = Xe.sibling, Bt = Xe.return;
                        if (Qx(Xe), Xe === Ce) {
                          Ue = null;
                          break;
                        }
                        if (nt !== null) {
                          nt.return = Bt, Ue = nt;
                          break;
                        }
                        Ue = Bt;
                      }
                  }
                }
                var Ke = A.alternate;
                if (Ke !== null) {
                  var Xn = Ke.child;
                  if (Xn !== null) {
                    Ke.child = null;
                    do {
                      var Yi = Xn.sibling;
                      Xn.sibling = null, Xn = Yi;
                    } while (Xn !== null);
                  }
                }
                Ue = A;
              }
            }
            if (A.subtreeFlags & 2064 && k !== null)
              k.return = A, Ue = k;
            else
              e:
                for (; Ue !== null; ) {
                  if (A = Ue, A.flags & 2048)
                    switch (A.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Eo(9, A, A.return);
                    }
                  var ee = A.sibling;
                  if (ee !== null) {
                    ee.return = A.return, Ue = ee;
                    break e;
                  }
                  Ue = A.return;
                }
          }
          var Z = a.current;
          for (Ue = Z; Ue !== null; ) {
            k = Ue;
            var re = k.child;
            if (k.subtreeFlags & 2064 && re !== null)
              re.return = k, Ue = re;
            else
              e:
                for (k = Z; Ue !== null; ) {
                  if (q = Ue, q.flags & 2048)
                    try {
                      switch (q.tag) {
                        case 0:
                        case 11:
                        case 15:
                          du(9, q);
                      }
                    } catch (Ze) {
                      di(q, q.return, Ze);
                    }
                  if (q === k) {
                    Ue = null;
                    break e;
                  }
                  var ke = q.sibling;
                  if (ke !== null) {
                    ke.return = q.return, Ue = ke;
                    break e;
                  }
                  Ue = q.return;
                }
          }
          if (Mt = E, Pr(), Cr && typeof Cr.onPostCommitFiberRoot == "function")
            try {
              Cr.onPostCommitFiberRoot(ff, a);
            } catch {
            }
          y = !0;
        }
        return y;
      } finally {
        Pt = p, cn.transition = u;
      }
    }
    return !1;
  }
  function m1(a, u, p) {
    u = Pm(p, u), u = Px(a, u, 1), Ps(a, u), u = ni(), a = Kf(a, 1), a !== null && (eu(a, 1, u), hi(a, u));
  }
  function di(a, u, p) {
    if (a.tag === 3)
      m1(a, a, p);
    else
      for (; u !== null; ) {
        if (u.tag === 3) {
          m1(u, a, p);
          break;
        } else if (u.tag === 1) {
          var y = u.stateNode;
          if (typeof u.type.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && (bs === null || !bs.has(y))) {
            a = Pm(p, a), a = bx(u, a, 1), Ps(u, a), a = ni(), u = Kf(u, 1), u !== null && (eu(u, 1, a), hi(u, a));
            break;
          }
        }
        u = u.return;
      }
  }
  function ZC(a, u, p) {
    var y = a.pingCache;
    y !== null && y.delete(u), u = ni(), a.pingedLanes |= a.suspendedLanes & p, vn === a && (Un & p) === p && (En === 4 || En === 3 && (Un & 130023424) === Un && 500 > Pn() - jm ? To(a, 0) : Xm |= p), hi(a, u);
  }
  function g1(a, u) {
    u === 0 && (a.mode & 1 ? (u = uf, uf <<= 1, !(uf & 130023424) && (uf = 4194304)) : u = 1);
    var p = ni();
    a = Kf(a, u), a !== null && (eu(a, u, p), hi(a, p));
  }
  function KC(a) {
    var u = a.memoizedState, p = 0;
    u !== null && (p = u.retryLane), g1(a, p);
  }
  function JC(a, u) {
    var p = 0;
    switch (a.tag) {
      case 13:
        var y = a.stateNode, E = a.memoizedState;
        E !== null && (p = E.retryLane);
        break;
      case 19:
        y = a.stateNode;
        break;
      default:
        throw Error(o(314));
    }
    y !== null && y.delete(u), g1(a, p);
  }
  var v1;
  v1 = function(a, u, p) {
    if (a !== null)
      if (a.memoizedProps !== u.pendingProps || gn.current)
        Ci = !0;
      else {
        if (!(a.lanes & p) && !(u.flags & 128))
          return Ci = !1, FC(a, u, p);
        Ci = !!(a.flags & 131072);
      }
    else
      Ci = !1, qt && u.flags & 1048576 && ix(u, xf, u.index);
    switch (u.lanes = 0, u.tag) {
      case 2:
        var y = u.type;
        a !== null && (a.alternate = null, u.alternate = null, u.flags |= 2), a = u.pendingProps;
        var E = rn(u, wn.current);
        wa(u, p), E = Em(null, u, y, a, E, p);
        var A = Tm();
        return u.flags |= 1, typeof E == "object" && E !== null && typeof E.render == "function" && E.$$typeof === void 0 ? (u.tag = 1, u.memoizedState = null, u.updateQueue = null, sn(y) ? (A = !0, Sa(u)) : A = !1, u.memoizedState = E.state !== null && E.state !== void 0 ? E.state : null, fm(u), E.updater = yf, u.stateNode = E, E._reactInternals = u, dm(u, y, a, p), u = Im(null, u, y, !0, A, p)) : (u.tag = 0, qt && A && pm(u), ti(null, u, E, p), u = u.child), u;
      case 16:
        y = u.elementType;
        e: {
          switch (a !== null && (a.alternate = null, u.alternate = null, u.flags |= 2), a = u.pendingProps, E = y._init, y = E(y._payload), u.type = y, E = u.tag = $C(y), a = sr(y, a), E) {
            case 0:
              u = Lm(null, u, y, a, p);
              break e;
            case 1:
              u = Hx(
                null,
                u,
                y,
                a,
                p
              );
              break e;
            case 11:
              u = Ox(null, u, y, a, p);
              break e;
            case 14:
              u = kx(null, u, y, sr(y.type, a), p);
              break e;
          }
          throw Error(o(306, y, ""));
        }
        return u;
      case 0:
        return y = u.type, E = u.pendingProps, E = u.elementType === y ? E : sr(y, E), Lm(a, u, y, E, p);
      case 1:
        return y = u.type, E = u.pendingProps, E = u.elementType === y ? E : sr(y, E), Hx(a, u, y, E, p);
      case 3:
        e: {
          if (Vx(u), a === null)
            throw Error(o(387));
          y = u.pendingProps, A = u.memoizedState, E = A.element, K_(a, u), vf(u, y, null, p);
          var k = u.memoizedState;
          if (y = k.element, ge && A.isDehydrated)
            if (A = {
              element: y,
              isDehydrated: !1,
              cache: k.cache,
              transitions: k.transitions
            }, u.updateQueue.baseState = A, u.memoizedState = A, u.flags & 256) {
              E = Error(o(423)), u = Gx(a, u, y, p, E);
              break e;
            } else if (y !== E) {
              E = Error(o(424)), u = Gx(a, u, y, p, E);
              break e;
            } else
              for (ge && (Ai = Jp(u.stateNode.containerInfo), Ti = u, qt = !0, or = null, tu = !1), p = ux(u, null, y, p), u.child = p; p; )
                p.flags = p.flags & -3 | 4096, p = p.sibling;
          else {
            if (Aa(), y === E) {
              u = $r(a, u, p);
              break e;
            }
            ti(a, u, y, p);
          }
          u = u.child;
        }
        return u;
      case 5:
        return cx(u), a === null && vm(u), y = u.type, E = u.pendingProps, A = a !== null ? a.memoizedProps : null, k = E.children, Te(y, E) ? k = null : A !== null && Te(y, A) && (u.flags |= 32), Bx(a, u), ti(a, u, k, p), u.child;
      case 6:
        return a === null && vm(u), null;
      case 13:
        return Wx(a, u, p);
      case 4:
        return _m(u, u.stateNode.containerInfo), y = u.pendingProps, a === null ? u.child = Ca(u, null, y, p) : ti(a, u, y, p), u.child;
      case 11:
        return y = u.type, E = u.pendingProps, E = u.elementType === y ? E : sr(y, E), Ox(a, u, y, E, p);
      case 7:
        return ti(a, u, u.pendingProps, p), u.child;
      case 8:
        return ti(a, u, u.pendingProps.children, p), u.child;
      case 12:
        return ti(a, u, u.pendingProps.children, p), u.child;
      case 10:
        e: {
          if (y = u.type._context, E = u.pendingProps, A = u.memoizedProps, k = E.value, Z_(u, y, k), A !== null)
            if (Rr(A.value, k)) {
              if (A.children === E.children && !gn.current) {
                u = $r(a, u, p);
                break e;
              }
            } else
              for (A = u.child, A !== null && (A.return = u); A !== null; ) {
                var q = A.dependencies;
                if (q !== null) {
                  k = A.child;
                  for (var le = q.firstContext; le !== null; ) {
                    if (le.context === y) {
                      if (A.tag === 1) {
                        le = Zr(-1, p & -p), le.tag = 2;
                        var Ce = A.updateQueue;
                        if (Ce !== null) {
                          Ce = Ce.shared;
                          var Xe = Ce.pending;
                          Xe === null ? le.next = le : (le.next = Xe.next, Xe.next = le), Ce.pending = le;
                        }
                      }
                      A.lanes |= p, le = A.alternate, le !== null && (le.lanes |= p), cm(A.return, p, u), q.lanes |= p;
                      break;
                    }
                    le = le.next;
                  }
                } else if (A.tag === 10)
                  k = A.type === u.type ? null : A.child;
                else if (A.tag === 18) {
                  if (k = A.return, k === null)
                    throw Error(o(341));
                  k.lanes |= p, q = k.alternate, q !== null && (q.lanes |= p), cm(k, p, u), k = A.sibling;
                } else
                  k = A.child;
                if (k !== null)
                  k.return = A;
                else
                  for (k = A; k !== null; ) {
                    if (k === u) {
                      k = null;
                      break;
                    }
                    if (A = k.sibling, A !== null) {
                      A.return = k.return, k = A;
                      break;
                    }
                    k = k.return;
                  }
                A = k;
              }
          ti(a, u, E.children, p), u = u.child;
        }
        return u;
      case 9:
        return E = u.type, y = u.pendingProps.children, wa(u, p), E = Bi(E), y = y(E), u.flags |= 1, ti(a, u, y, p), u.child;
      case 14:
        return y = u.type, E = sr(y, u.pendingProps), E = sr(y.type, E), kx(a, u, y, E, p);
      case 15:
        return Fx(a, u, u.type, u.pendingProps, p);
      case 17:
        return y = u.type, E = u.pendingProps, E = u.elementType === y ? E : sr(y, E), a !== null && (a.alternate = null, u.alternate = null, u.flags |= 2), u.tag = 1, sn(y) ? (a = !0, Sa(u)) : a = !1, wa(u, p), tx(u, y, E), dm(u, y, E, p), Im(null, u, y, !0, a, p);
      case 19:
        return qx(a, u, p);
      case 22:
        return zx(a, u, p);
    }
    throw Error(o(156, u.tag));
  };
  function y1(a, u) {
    return im(a, u);
  }
  function QC(a, u, p, y) {
    this.tag = a, this.key = p, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = u, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = y, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function ji(a, u, p, y) {
    return new QC(a, u, p, y);
  }
  function eg(a) {
    return a = a.prototype, !(!a || !a.isReactComponent);
  }
  function $C(a) {
    if (typeof a == "function")
      return eg(a) ? 1 : 0;
    if (a != null) {
      if (a = a.$$typeof, a === w)
        return 11;
      if (a === x)
        return 14;
    }
    return 2;
  }
  function Ds(a, u) {
    var p = a.alternate;
    return p === null ? (p = ji(a.tag, u, a.key, a.mode), p.elementType = a.elementType, p.type = a.type, p.stateNode = a.stateNode, p.alternate = a, a.alternate = p) : (p.pendingProps = u, p.type = a.type, p.flags = 0, p.subtreeFlags = 0, p.deletions = null), p.flags = a.flags & 14680064, p.childLanes = a.childLanes, p.lanes = a.lanes, p.child = a.child, p.memoizedProps = a.memoizedProps, p.memoizedState = a.memoizedState, p.updateQueue = a.updateQueue, u = a.dependencies, p.dependencies = u === null ? null : { lanes: u.lanes, firstContext: u.firstContext }, p.sibling = a.sibling, p.index = a.index, p.ref = a.ref, p;
  }
  function Qf(a, u, p, y, E, A) {
    var k = 2;
    if (y = a, typeof a == "function")
      eg(a) && (k = 1);
    else if (typeof a == "string")
      k = 5;
    else
      e:
        switch (a) {
          case h:
            return Ro(p.children, E, A, u);
          case d:
            k = 8, E |= 8;
            break;
          case m:
            return a = ji(12, p, u, E | 2), a.elementType = m, a.lanes = A, a;
          case M:
            return a = ji(13, p, u, E), a.elementType = M, a.lanes = A, a;
          case g:
            return a = ji(19, p, u, E), a.elementType = g, a.lanes = A, a;
          case T:
            return $f(p, E, A, u);
          default:
            if (typeof a == "object" && a !== null)
              switch (a.$$typeof) {
                case v:
                  k = 10;
                  break e;
                case _:
                  k = 9;
                  break e;
                case w:
                  k = 11;
                  break e;
                case x:
                  k = 14;
                  break e;
                case S:
                  k = 16, y = null;
                  break e;
              }
            throw Error(o(130, a == null ? a : typeof a, ""));
        }
    return u = ji(k, p, u, E), u.elementType = a, u.type = y, u.lanes = A, u;
  }
  function Ro(a, u, p, y) {
    return a = ji(7, a, y, u), a.lanes = p, a;
  }
  function $f(a, u, p, y) {
    return a = ji(22, a, y, u), a.elementType = T, a.lanes = p, a.stateNode = {}, a;
  }
  function tg(a, u, p) {
    return a = ji(6, a, null, u), a.lanes = p, a;
  }
  function ng(a, u, p) {
    return u = ji(4, a.children !== null ? a.children : [], a.key, u), u.lanes = p, u.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation }, u;
  }
  function eR(a, u, p, y, E) {
    this.tag = u, this.containerInfo = a, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = vt, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = tm(0), this.expirationTimes = tm(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = tm(0), this.identifierPrefix = y, this.onRecoverableError = E, ge && (this.mutableSourceEagerHydrationData = null);
  }
  function _1(a, u, p, y, E, A, k, q, le) {
    return a = new eR(a, u, p, q, le), u === 1 ? (u = 1, A === !0 && (u |= 8)) : u = 0, A = ji(3, null, null, u), a.current = A, A.stateNode = a, A.memoizedState = { element: y, isDehydrated: p, cache: null, transitions: null }, fm(A), a;
  }
  function x1(a) {
    if (!a)
      return Bn;
    a = a._reactInternals;
    e: {
      if (R(a) !== a || a.tag !== 1)
        throw Error(o(170));
      var u = a;
      do {
        switch (u.tag) {
          case 3:
            u = u.stateNode.context;
            break e;
          case 1:
            if (sn(u.type)) {
              u = u.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        u = u.return;
      } while (u !== null);
      throw Error(o(171));
    }
    if (a.tag === 1) {
      var p = a.type;
      if (sn(p))
        return xa(a, p, u);
    }
    return u;
  }
  function S1(a) {
    var u = a._reactInternals;
    if (u === void 0)
      throw typeof a.render == "function" ? Error(o(188)) : (a = Object.keys(a).join(","), Error(o(268, a)));
    return a = $(u), a === null ? null : a.stateNode;
  }
  function M1(a, u) {
    if (a = a.memoizedState, a !== null && a.dehydrated !== null) {
      var p = a.retryLane;
      a.retryLane = p !== 0 && p < u ? p : u;
    }
  }
  function ig(a, u) {
    M1(a, u), (a = a.alternate) && M1(a, u);
  }
  function tR(a) {
    return a = $(a), a === null ? null : a.stateNode;
  }
  function nR() {
    return null;
  }
  return t.attemptContinuousHydration = function(a) {
    if (a.tag === 13) {
      var u = ni();
      Xi(a, 134217728, u), ig(a, 134217728);
    }
  }, t.attemptHydrationAtCurrentPriority = function(a) {
    if (a.tag === 13) {
      var u = ni(), p = Is(a);
      Xi(a, p, u), ig(a, p);
    }
  }, t.attemptSynchronousHydration = function(a) {
    switch (a.tag) {
      case 3:
        var u = a.stateNode;
        if (u.current.memoizedState.isDehydrated) {
          var p = $l(u.pendingLanes);
          p !== 0 && (nm(u, p | 1), hi(u, Pn()), !(Mt & 6) && (Na(), Pr()));
        }
        break;
      case 13:
        var y = ni();
        c1(function() {
          return Xi(a, 1, y);
        }), ig(a, 1);
    }
  }, t.batchedUpdates = function(a, u) {
    var p = Mt;
    Mt |= 1;
    try {
      return a(u);
    } finally {
      Mt = p, Mt === 0 && (Na(), hf && Pr());
    }
  }, t.createComponentSelector = function(a) {
    return { $$typeof: Ff, value: a };
  }, t.createContainer = function(a, u, p, y, E, A, k) {
    return _1(a, u, !1, null, p, y, E, A, k);
  }, t.createHasPseudoClassSelector = function(a) {
    return { $$typeof: zf, value: a };
  }, t.createHydrationContainer = function(a, u, p, y, E, A, k, q, le) {
    return a = _1(p, y, !0, a, E, A, k, q, le), a.context = x1(null), p = a.current, y = ni(), E = Is(p), A = Zr(y, E), A.callback = u ?? null, Ps(p, A), a.current.lanes = E, eu(a, E, y), hi(a, y), a;
  }, t.createPortal = function(a, u, p) {
    var y = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: f, key: y == null ? null : "" + y, children: a, containerInfo: u, implementation: p };
  }, t.createRoleSelector = function(a) {
    return { $$typeof: Bf, value: a };
  }, t.createTestNameSelector = function(a) {
    return { $$typeof: Hf, value: a };
  }, t.createTextSelector = function(a) {
    return { $$typeof: Vf, value: a };
  }, t.deferredUpdates = function(a) {
    var u = Pt, p = cn.transition;
    try {
      return cn.transition = null, Pt = 16, a();
    } finally {
      Pt = u, cn.transition = p;
    }
  }, t.discreteUpdates = function(a, u, p, y, E) {
    var A = Pt, k = cn.transition;
    try {
      return cn.transition = null, Pt = 1, a(u, p, y, E);
    } finally {
      Pt = A, cn.transition = k, Mt === 0 && Na();
    }
  }, t.findAllNodes = Gm, t.findBoundingRects = function(a, u) {
    if (!Je)
      throw Error(o(363));
    u = Gm(a, u), a = [];
    for (var p = 0; p < u.length; p++)
      a.push(Ut(u[p]));
    for (u = a.length - 1; 0 < u; u--) {
      p = a[u];
      for (var y = p.x, E = y + p.width, A = p.y, k = A + p.height, q = u - 1; 0 <= q; q--)
        if (u !== q) {
          var le = a[q], Ce = le.x, Xe = Ce + le.width, ft = le.y, nt = ft + le.height;
          if (y >= Ce && A >= ft && E <= Xe && k <= nt) {
            a.splice(u, 1);
            break;
          } else if (y !== Ce || p.width !== le.width || nt < A || ft > k) {
            if (!(A !== ft || p.height !== le.height || Xe < y || Ce > E)) {
              Ce > y && (le.width += Ce - y, le.x = y), Xe < E && (le.width = E - Ce), a.splice(u, 1);
              break;
            }
          } else {
            ft > A && (le.height += ft - A, le.y = A), nt < k && (le.height = k - ft), a.splice(u, 1);
            break;
          }
        }
    }
    return a;
  }, t.findHostInstance = S1, t.findHostInstanceWithNoPortals = function(a) {
    return a = G(a), a = a !== null ? K(a) : null, a === null ? null : a.stateNode;
  }, t.findHostInstanceWithWarning = function(a) {
    return S1(a);
  }, t.flushControlled = function(a) {
    var u = Mt;
    Mt |= 1;
    var p = cn.transition, y = Pt;
    try {
      cn.transition = null, Pt = 1, a();
    } finally {
      Pt = y, cn.transition = p, Mt = u, Mt === 0 && (Na(), Pr());
    }
  }, t.flushPassiveEffects = Co, t.flushSync = c1, t.focusWithin = function(a, u) {
    if (!Je)
      throw Error(o(363));
    for (a = Bm(a), u = a1(a, u), u = Array.from(u), a = 0; a < u.length; ) {
      var p = u[a++];
      if (!I(p)) {
        if (p.tag === 5 && we(p.stateNode))
          return !0;
        for (p = p.child; p !== null; )
          u.push(p), p = p.sibling;
      }
    }
    return !1;
  }, t.getCurrentUpdatePriority = function() {
    return Pt;
  }, t.getFindAllNodesFailureDescription = function(a, u) {
    if (!Je)
      throw Error(o(363));
    var p = 0, y = [];
    a = [Bm(a), 0];
    for (var E = 0; E < a.length; ) {
      var A = a[E++], k = a[E++], q = u[k];
      if ((A.tag !== 5 || !I(A)) && (Hm(A, q) && (y.push(Vm(q)), k++, k > p && (p = k)), k < u.length))
        for (A = A.child; A !== null; )
          a.push(A, k), A = A.sibling;
    }
    if (p < u.length) {
      for (a = []; p < u.length; p++)
        a.push(Vm(u[p]));
      return `findAllNodes was able to match part of the selector:
  ` + (y.join(" > ") + `

No matching component was found for:
  `) + a.join(" > ");
    }
    return null;
  }, t.getPublicRootInstance = function(a) {
    if (a = a.current, !a.child)
      return null;
    switch (a.child.tag) {
      case 5:
        return oe(a.child.stateNode);
      default:
        return a.child.stateNode;
    }
  }, t.injectIntoDevTools = function(a) {
    if (a = { bundleType: a.bundleType, version: a.version, rendererPackageName: a.rendererPackageName, rendererConfig: a.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: l.ReactCurrentDispatcher, findHostInstanceByFiber: tR, findFiberByHostInstance: a.findFiberByHostInstance || nR, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      a = !1;
    else {
      var u = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (u.isDisabled || !u.supportsFiber)
        a = !0;
      else {
        try {
          ff = u.inject(a), Cr = u;
        } catch {
        }
        a = !!u.checkDCE;
      }
    }
    return a;
  }, t.isAlreadyRendering = function() {
    return !1;
  }, t.observeVisibleRects = function(a, u, p, y) {
    if (!Je)
      throw Error(o(363));
    a = Gm(a, u);
    var E = _e(a, p, y).disconnect;
    return { disconnect: function() {
      E();
    } };
  }, t.registerMutableSourceForHydration = function(a, u) {
    var p = u._getVersion;
    p = p(u._source), a.mutableSourceEagerHydrationData == null ? a.mutableSourceEagerHydrationData = [u, p] : a.mutableSourceEagerHydrationData.push(u, p);
  }, t.runWithPriority = function(a, u) {
    var p = Pt;
    try {
      return Pt = a, u();
    } finally {
      Pt = p;
    }
  }, t.shouldError = function() {
    return null;
  }, t.shouldSuspend = function() {
    return !1;
  }, t.updateContainer = function(a, u, p, y) {
    var E = u.current, A = ni(), k = Is(E);
    return p = x1(p), u.context === null ? u.context = p : u.pendingContext = p, u = Zr(A, k), u.payload = { element: a }, y = y === void 0 ? null : y, y !== null && (u.callback = y), Ps(E, u), a = Xi(E, k, A), a !== null && gf(a, E, k), k;
  }, t;
};
Y2.exports = Ck;
var Rk = Y2.exports;
const Pk = /* @__PURE__ */ Tw(Rk), G_ = {}, bk = (n) => void Object.assign(G_, n);
function Lk(n, e) {
  function t(h, {
    args: d = [],
    attach: m,
    ...v
  }, _) {
    let w = `${h[0].toUpperCase()}${h.slice(1)}`, M;
    if (h === "primitive") {
      if (v.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const g = v.object;
      M = ol(g, {
        type: h,
        root: _,
        attach: m,
        primitive: !0
      });
    } else {
      const g = G_[w];
      if (!g)
        throw new Error(`R3F: ${w} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(d))
        throw new Error("R3F: The args prop must be an array!");
      M = ol(new g(...d), {
        type: h,
        root: _,
        attach: m,
        // Save args in case we need to reconstruct later for HMR
        memoizedProps: {
          args: d
        }
      });
    }
    return M.__r3f.attach === void 0 && (M.isBufferGeometry ? M.__r3f.attach = "geometry" : M.isMaterial && (M.__r3f.attach = "material")), w !== "inject" && f0(M, v), M;
  }
  function i(h, d) {
    let m = !1;
    if (d) {
      var v, _;
      (v = d.__r3f) != null && v.attach ? c0(h, d, d.__r3f.attach) : d.isObject3D && h.isObject3D && (h.add(d), m = !0), m || (_ = h.__r3f) == null || _.objects.push(d), d.__r3f || ol(d, {}), d.__r3f.parent = h, ty(d), al(d);
    }
  }
  function r(h, d, m) {
    let v = !1;
    if (d) {
      var _, w;
      if ((_ = d.__r3f) != null && _.attach)
        c0(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        d.parent = h, d.dispatchEvent({
          type: "added"
        }), h.dispatchEvent({
          type: "childadded",
          child: d
        });
        const M = h.children.filter((x) => x !== d), g = M.indexOf(m);
        h.children = [...M.slice(0, g), d, ...M.slice(g)], v = !0;
      }
      v || (w = h.__r3f) == null || w.objects.push(d), d.__r3f || ol(d, {}), d.__r3f.parent = h, ty(d), al(d);
    }
  }
  function s(h, d, m = !1) {
    h && [...h].forEach((v) => o(d, v, m));
  }
  function o(h, d, m) {
    if (d) {
      var v, _, w;
      if (d.__r3f && (d.__r3f.parent = null), (v = h.__r3f) != null && v.objects && (h.__r3f.objects = h.__r3f.objects.filter((T) => T !== d)), (_ = d.__r3f) != null && _.attach)
        hw(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        var M;
        h.remove(d), (M = d.__r3f) != null && M.root && zk(Rd(d), d);
      }
      const x = (w = d.__r3f) == null ? void 0 : w.primitive, S = !x && (m === void 0 ? d.dispose !== null : m);
      if (!x) {
        var g;
        s((g = d.__r3f) == null ? void 0 : g.objects, d, S), s(d.children, d, S);
      }
      if (delete d.__r3f, S && d.dispose && d.type !== "Scene") {
        const T = () => {
          try {
            d.dispose();
          } catch {
          }
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u" ? $v.unstable_scheduleCallback($v.unstable_IdlePriority, T) : T();
      }
      al(h);
    }
  }
  function l(h, d, m, v) {
    var _;
    const w = (_ = h.__r3f) == null ? void 0 : _.parent;
    if (!w)
      return;
    const M = t(d, m, h.__r3f.root);
    if (h.children) {
      for (const g of h.children)
        g.__r3f && i(M, g);
      h.children = h.children.filter((g) => !g.__r3f);
    }
    h.__r3f.objects.forEach((g) => i(M, g)), h.__r3f.objects = [], h.__r3f.autoRemovedBeforeAppend || o(w, h), M.parent && (M.__r3f.autoRemovedBeforeAppend = !0), i(w, M), M.raycast && M.__r3f.eventCount && Rd(M).getState().internal.interaction.push(M), [v, v.alternate].forEach((g) => {
      g !== null && (g.stateNode = M, g.ref && (typeof g.ref == "function" ? g.ref(M) : g.ref.current = M));
    });
  }
  const c = () => {
  };
  return {
    reconciler: Pk({
      createInstance: t,
      removeChild: o,
      appendChild: i,
      appendInitialChild: i,
      insertBefore: r,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (h, d) => {
        if (!d)
          return;
        const m = h.getState().scene;
        m.__r3f && (m.__r3f.root = h, i(m, d));
      },
      removeChildFromContainer: (h, d) => {
        d && o(h.getState().scene, d);
      },
      insertInContainerBefore: (h, d, m) => {
        if (!d || !m)
          return;
        const v = h.getState().scene;
        v.__r3f && r(v, d, m);
      },
      getRootHostContext: () => null,
      getChildHostContext: (h) => h,
      finalizeInitialChildren(h) {
        var d;
        return !!((d = h == null ? void 0 : h.__r3f) != null ? d : {}).handlers;
      },
      prepareUpdate(h, d, m, v) {
        var _;
        if (((_ = h == null ? void 0 : h.__r3f) != null ? _ : {}).primitive && v.object && v.object !== h)
          return [!0];
        {
          const {
            args: M = [],
            children: g,
            ...x
          } = v, {
            args: S = [],
            children: T,
            ...C
          } = m;
          if (!Array.isArray(M))
            throw new Error("R3F: the args prop must be an array!");
          if (M.some((L, N) => L !== S[N]))
            return [!0];
          const P = nC(h, x, C, !0);
          return P.changes.length ? [!1, P] : null;
        }
      },
      commitUpdate(h, [d, m], v, _, w, M) {
        d ? l(h, v, w, M) : f0(h, m);
      },
      commitMount(h, d, m, v) {
        var _;
        const w = (_ = h.__r3f) != null ? _ : {};
        h.raycast && w.handlers && w.eventCount && Rd(h).getState().internal.interaction.push(h);
      },
      getPublicInstance: (h) => h,
      prepareForCommit: () => null,
      preparePortalMount: (h) => ol(h.getState().scene),
      resetAfterCommit: () => {
      },
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(h) {
        var d;
        const {
          attach: m,
          parent: v
        } = (d = h.__r3f) != null ? d : {};
        m && v && hw(v, h, m), h.isObject3D && (h.visible = !1), al(h);
      },
      unhideInstance(h, d) {
        var m;
        const {
          attach: v,
          parent: _
        } = (m = h.__r3f) != null ? m : {};
        v && _ && c0(_, h, v), (h.isObject3D && d.visible == null || d.visible) && (h.visible = !0), al(h);
      },
      createTextInstance: c,
      hideTextInstance: c,
      unhideTextInstance: c,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
      // @ts-expect-error
      getCurrentEventPriority: () => e ? e() : El.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {
      },
      afterActiveInstanceBlur: () => {
      },
      detachDeletedInstance: () => {
      },
      now: typeof performance < "u" && jt.fun(performance.now) ? performance.now : jt.fun(Date.now) ? Date.now : () => 0,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503
      scheduleTimeout: jt.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: jt.fun(clearTimeout) ? clearTimeout : void 0
    }),
    applyProps: f0
  };
}
var lw, uw;
const u0 = (n) => "colorSpace" in n || "outputColorSpace" in n, K2 = () => {
  var n;
  return (n = G_.ColorManagement) != null ? n : null;
}, J2 = (n) => n && n.isOrthographicCamera, Ik = (n) => n && n.hasOwnProperty("current"), ef = typeof window < "u" && ((lw = window.document) != null && lw.createElement || ((uw = window.navigator) == null ? void 0 : uw.product) === "ReactNative") ? xe.useLayoutEffect : xe.useEffect;
function Q2(n) {
  const e = xe.useRef(n);
  return ef(() => void (e.current = n), [n]), e;
}
function Nk({
  set: n
}) {
  return ef(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class $2 extends xe.Component {
  constructor(...e) {
    super(...e), this.state = {
      error: !1
    };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
$2.getDerivedStateFromError = () => ({
  error: !0
});
const eC = "__default", cw = /* @__PURE__ */ new Map(), Dk = (n) => n && !!n.memoized && !!n.changes;
function tC(n) {
  var e;
  const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const Ou = (n) => {
  var e;
  return (e = n.__r3f) == null ? void 0 : e.root.getState();
};
function Rd(n) {
  let e = n.__r3f.root;
  for (; e.getState().previousRoot; )
    e = e.getState().previousRoot;
  return e;
}
const jt = {
  obj: (n) => n === Object(n) && !jt.arr(n) && typeof n != "function",
  fun: (n) => typeof n == "function",
  str: (n) => typeof n == "string",
  num: (n) => typeof n == "number",
  boo: (n) => typeof n == "boolean",
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(n, e, {
    arrays: t = "shallow",
    objects: i = "reference",
    strict: r = !0
  } = {}) {
    if (typeof n != typeof e || !!n != !!e)
      return !1;
    if (jt.str(n) || jt.num(n) || jt.boo(n))
      return n === e;
    const s = jt.obj(n);
    if (s && i === "reference")
      return n === e;
    const o = jt.arr(n);
    if (o && t === "reference")
      return n === e;
    if ((o || s) && n === e)
      return !0;
    let l;
    for (l in n)
      if (!(l in e))
        return !1;
    if (s && t === "shallow" && i === "shallow") {
      for (l in r ? e : n)
        if (!jt.equ(n[l], e[l], {
          strict: r,
          objects: "reference"
        }))
          return !1;
    } else
      for (l in r ? e : n)
        if (n[l] !== e[l])
          return !1;
    if (jt.und(l)) {
      if (o && n.length === 0 && e.length === 0 || s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
        return !0;
      if (n !== e)
        return !1;
    }
    return !0;
  }
};
function Uk(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n)
    e.dispose == null || e.dispose(), delete n[e];
}
function ol(n, e) {
  const t = n;
  return t.__r3f = {
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null,
    ...e
  }, n;
}
function ey(n, e) {
  let t = n;
  if (e.includes("-")) {
    const i = e.split("-"), r = i.pop();
    return t = i.reduce((s, o) => s[o], n), {
      target: t,
      key: r
    };
  } else
    return {
      target: t,
      key: e
    };
}
const fw = /-\d+$/;
function c0(n, e, t) {
  if (jt.str(t)) {
    if (fw.test(t)) {
      const s = t.replace(fw, ""), {
        target: o,
        key: l
      } = ey(n, s);
      Array.isArray(o[l]) || (o[l] = []);
    }
    const {
      target: i,
      key: r
    } = ey(n, t);
    e.__r3f.previousAttach = i[r], i[r] = e;
  } else
    e.__r3f.previousAttach = t(n, e);
}
function hw(n, e, t) {
  var i, r;
  if (jt.str(t)) {
    const {
      target: s,
      key: o
    } = ey(n, t), l = e.__r3f.previousAttach;
    l === void 0 ? delete s[o] : s[o] = l;
  } else
    (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
  (r = e.__r3f) == null || delete r.previousAttach;
}
function nC(n, {
  children: e,
  key: t,
  ref: i,
  ...r
}, {
  children: s,
  key: o,
  ref: l,
  ...c
} = {}, f = !1) {
  const h = n.__r3f, d = Object.entries(r), m = [];
  if (f) {
    const _ = Object.keys(c);
    for (let w = 0; w < _.length; w++)
      r.hasOwnProperty(_[w]) || d.unshift([_[w], eC + "remove"]);
  }
  d.forEach(([_, w]) => {
    var M;
    if ((M = n.__r3f) != null && M.primitive && _ === "object" || jt.equ(w, c[_]))
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(_))
      return m.push([_, w, !0, []]);
    let g = [];
    _.includes("-") && (g = _.split("-")), m.push([_, w, !1, g]);
    for (const x in r) {
      const S = r[x];
      x.startsWith(`${_}-`) && m.push([x, S, !1, x.split("-")]);
    }
  });
  const v = {
    ...r
  };
  return h != null && h.memoizedProps && h != null && h.memoizedProps.args && (v.args = h.memoizedProps.args), h != null && h.memoizedProps && h != null && h.memoizedProps.attach && (v.attach = h.memoizedProps.attach), {
    memoized: v,
    changes: m
  };
}
const Ok = typeof process < "u" && !1;
function f0(n, e) {
  var t;
  const i = n.__r3f, r = i == null ? void 0 : i.root, s = r == null || r.getState == null ? void 0 : r.getState(), {
    memoized: o,
    changes: l
  } = Dk(e) ? e : nC(n, e), c = i == null ? void 0 : i.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = o);
  for (let m = 0; m < l.length; m++) {
    let [v, _, w, M] = l[m];
    if (u0(n)) {
      const T = "srgb", C = "srgb-linear";
      v === "encoding" ? (v = "colorSpace", _ = _ === 3001 ? T : C) : v === "outputEncoding" && (v = "outputColorSpace", _ = _ === 3001 ? T : C);
    }
    let g = n, x = g[v];
    if (M.length && (x = M.reduce((S, T) => S[T], n), !(x && x.set))) {
      const [S, ...T] = M.reverse();
      g = T.reverse().reduce((C, P) => C[P], n), v = S;
    }
    if (_ === eC + "remove")
      if (g.constructor) {
        let S = cw.get(g.constructor);
        S || (S = new g.constructor(), cw.set(g.constructor, S)), _ = S[v];
      } else
        _ = 0;
    if (w && i)
      _ ? i.handlers[v] = _ : delete i.handlers[v], i.eventCount = Object.keys(i.handlers).length;
    else if (x && x.set && (x.copy || x instanceof na)) {
      if (Array.isArray(_))
        x.fromArray ? x.fromArray(_) : x.set(..._);
      else if (x.copy && _ && _.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.
      // Loosen to unminified names, ignoring descendents.
      // https://github.com/pmndrs/react-three-fiber/issues/2856
      // TODO: fix upstream and remove in v9
      (Ok ? x.constructor.name === _.constructor.name : x.constructor === _.constructor))
        x.copy(_);
      else if (_ !== void 0) {
        var f;
        const S = (f = x) == null ? void 0 : f.isColor;
        !S && x.setScalar ? x.setScalar(_) : x instanceof na && _ instanceof na ? x.mask = _.mask : x.set(_), !K2() && s && !s.linear && S && x.convertSRGBToLinear();
      }
    } else {
      var h;
      if (g[v] = _, (h = g[v]) != null && h.isTexture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129
      g[v].format === vi && g[v].type === Hr && s) {
        const S = g[v];
        u0(S) && u0(s.gl) ? S.colorSpace = s.gl.outputColorSpace : S.encoding = s.gl.outputEncoding;
      }
    }
    al(n);
  }
  if (i && i.parent && n.raycast && c !== i.eventCount) {
    const m = Rd(n).getState().internal, v = m.interaction.indexOf(n);
    v > -1 && m.interaction.splice(v, 1), i.eventCount && m.interaction.push(n);
  }
  return !(l.length === 1 && l[0][0] === "onUpdate") && l.length && (t = n.__r3f) != null && t.parent && ty(n), n;
}
function al(n) {
  var e, t;
  const i = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  i && i.internal.frames === 0 && i.invalidate();
}
function ty(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function kk(n, e) {
  n.manual || (J2(n) ? (n.left = e.width / -2, n.right = e.width / 2, n.top = e.height / 2, n.bottom = e.height / -2) : n.aspect = e.width / e.height, n.updateProjectionMatrix(), n.updateMatrixWorld());
}
function rd(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function Fk() {
  var n;
  const e = typeof self < "u" && self || typeof window < "u" && window;
  if (!e)
    return El.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return El.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return El.ContinuousEventPriority;
    default:
      return El.DefaultEventPriority;
  }
}
function iC(n, e, t, i) {
  const r = t.get(e);
  r && (t.delete(e), t.size === 0 && (n.delete(i), r.target.releasePointerCapture(i)));
}
function zk(n, e) {
  const {
    internal: t
  } = n.getState();
  t.interaction = t.interaction.filter((i) => i !== e), t.initialHits = t.initialHits.filter((i) => i !== e), t.hovered.forEach((i, r) => {
    (i.eventObject === e || i.object === e) && t.hovered.delete(r);
  }), t.capturedMap.forEach((i, r) => {
    iC(t.capturedMap, e, i, r);
  });
}
function Bk(n) {
  function e(c) {
    const {
      internal: f
    } = n.getState(), h = c.offsetX - f.initialClick[0], d = c.offsetY - f.initialClick[1];
    return Math.round(Math.sqrt(h * h + d * d));
  }
  function t(c) {
    return c.filter((f) => ["Move", "Over", "Enter", "Out", "Leave"].some((h) => {
      var d;
      return (d = f.__r3f) == null ? void 0 : d.handlers["onPointer" + h];
    }));
  }
  function i(c, f) {
    const h = n.getState(), d = /* @__PURE__ */ new Set(), m = [], v = f ? f(h.internal.interaction) : h.internal.interaction;
    for (let g = 0; g < v.length; g++) {
      const x = Ou(v[g]);
      x && (x.raycaster.camera = void 0);
    }
    h.previousRoot || h.events.compute == null || h.events.compute(c, h);
    function _(g) {
      const x = Ou(g);
      if (!x || !x.events.enabled || x.raycaster.camera === null)
        return [];
      if (x.raycaster.camera === void 0) {
        var S;
        x.events.compute == null || x.events.compute(c, x, (S = x.previousRoot) == null ? void 0 : S.getState()), x.raycaster.camera === void 0 && (x.raycaster.camera = null);
      }
      return x.raycaster.camera ? x.raycaster.intersectObject(g, !0) : [];
    }
    let w = v.flatMap(_).sort((g, x) => {
      const S = Ou(g.object), T = Ou(x.object);
      return !S || !T ? g.distance - x.distance : T.events.priority - S.events.priority || g.distance - x.distance;
    }).filter((g) => {
      const x = rd(g);
      return d.has(x) ? !1 : (d.add(x), !0);
    });
    h.events.filter && (w = h.events.filter(w, h));
    for (const g of w) {
      let x = g.object;
      for (; x; ) {
        var M;
        (M = x.__r3f) != null && M.eventCount && m.push({
          ...g,
          eventObject: x
        }), x = x.parent;
      }
    }
    if ("pointerId" in c && h.internal.capturedMap.has(c.pointerId))
      for (let g of h.internal.capturedMap.get(c.pointerId).values())
        d.has(rd(g.intersection)) || m.push(g.intersection);
    return m;
  }
  function r(c, f, h, d) {
    const m = n.getState();
    if (c.length) {
      const v = {
        stopped: !1
      };
      for (const _ of c) {
        const w = Ou(_.object) || m, {
          raycaster: M,
          pointer: g,
          camera: x,
          internal: S
        } = w, T = new D(g.x, g.y, 0).unproject(x), C = (b) => {
          var G, $;
          return (G = ($ = S.capturedMap.get(b)) == null ? void 0 : $.has(_.eventObject)) != null ? G : !1;
        }, P = (b) => {
          const G = {
            intersection: _,
            target: f.target
          };
          S.capturedMap.has(b) ? S.capturedMap.get(b).set(_.eventObject, G) : S.capturedMap.set(b, /* @__PURE__ */ new Map([[_.eventObject, G]])), f.target.setPointerCapture(b);
        }, L = (b) => {
          const G = S.capturedMap.get(b);
          G && iC(S.capturedMap, _.eventObject, G, b);
        };
        let N = {};
        for (let b in f) {
          let G = f[b];
          typeof G != "function" && (N[b] = G);
        }
        let R = {
          ..._,
          ...N,
          pointer: g,
          intersections: c,
          stopped: v.stopped,
          delta: h,
          unprojectedPoint: T,
          ray: M.ray,
          camera: x,
          // Hijack stopPropagation, which just sets a flag
          stopPropagation() {
            const b = "pointerId" in f && S.capturedMap.get(f.pointerId);
            if (
              // ...if this pointer hasn't been captured
              (!b || // ... or if the hit object is capturing the pointer
              b.has(_.eventObject)) && (R.stopped = v.stopped = !0, S.hovered.size && Array.from(S.hovered.values()).find((G) => G.eventObject === _.eventObject))
            ) {
              const G = c.slice(0, c.indexOf(_));
              s([...G, _]);
            }
          },
          // there should be a distinction between target and currentTarget
          target: {
            hasPointerCapture: C,
            setPointerCapture: P,
            releasePointerCapture: L
          },
          currentTarget: {
            hasPointerCapture: C,
            setPointerCapture: P,
            releasePointerCapture: L
          },
          nativeEvent: f
        };
        if (d(R), v.stopped === !0)
          break;
      }
    }
    return c;
  }
  function s(c) {
    const {
      internal: f
    } = n.getState();
    for (const h of f.hovered.values())
      if (!c.length || !c.find((d) => d.object === h.object && d.index === h.index && d.instanceId === h.instanceId)) {
        const m = h.eventObject.__r3f, v = m == null ? void 0 : m.handlers;
        if (f.hovered.delete(rd(h)), m != null && m.eventCount) {
          const _ = {
            ...h,
            intersections: c
          };
          v.onPointerOut == null || v.onPointerOut(_), v.onPointerLeave == null || v.onPointerLeave(_);
        }
      }
  }
  function o(c, f) {
    for (let h = 0; h < f.length; h++) {
      const d = f[h].__r3f;
      d == null || d.handlers.onPointerMissed == null || d.handlers.onPointerMissed(c);
    }
  }
  function l(c) {
    switch (c) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (f) => {
          const {
            internal: h
          } = n.getState();
          "pointerId" in f && h.capturedMap.has(f.pointerId) && requestAnimationFrame(() => {
            h.capturedMap.has(f.pointerId) && (h.capturedMap.delete(f.pointerId), s([]));
          });
        };
    }
    return function(h) {
      const {
        onPointerMissed: d,
        internal: m
      } = n.getState();
      m.lastEvent.current = h;
      const v = c === "onPointerMove", _ = c === "onClick" || c === "onContextMenu" || c === "onDoubleClick", M = i(h, v ? t : void 0), g = _ ? e(h) : 0;
      c === "onPointerDown" && (m.initialClick = [h.offsetX, h.offsetY], m.initialHits = M.map((S) => S.eventObject)), _ && !M.length && g <= 2 && (o(h, m.interaction), d && d(h)), v && s(M);
      function x(S) {
        const T = S.eventObject, C = T.__r3f, P = C == null ? void 0 : C.handlers;
        if (C != null && C.eventCount)
          if (v) {
            if (P.onPointerOver || P.onPointerEnter || P.onPointerOut || P.onPointerLeave) {
              const L = rd(S), N = m.hovered.get(L);
              N ? N.stopped && S.stopPropagation() : (m.hovered.set(L, S), P.onPointerOver == null || P.onPointerOver(S), P.onPointerEnter == null || P.onPointerEnter(S));
            }
            P.onPointerMove == null || P.onPointerMove(S);
          } else {
            const L = P[c];
            L ? (!_ || m.initialHits.includes(T)) && (o(h, m.interaction.filter((N) => !m.initialHits.includes(N))), L(S)) : _ && m.initialHits.includes(T) && o(h, m.interaction.filter((N) => !m.initialHits.includes(N)));
          }
      }
      r(M, h, g, x);
    };
  }
  return {
    handlePointer: l
  };
}
const rC = (n) => !!(n != null && n.render), sC = /* @__PURE__ */ xe.createContext(null), Hk = (n, e) => {
  const t = Ak((l, c) => {
    const f = new D(), h = new D(), d = new D();
    function m(g = c().camera, x = h, S = c().size) {
      const {
        width: T,
        height: C,
        top: P,
        left: L
      } = S, N = T / C;
      x.isVector3 ? d.copy(x) : d.set(...x);
      const R = g.getWorldPosition(f).distanceTo(d);
      if (J2(g))
        return {
          width: T / g.zoom,
          height: C / g.zoom,
          top: P,
          left: L,
          factor: 1,
          distance: R,
          aspect: N
        };
      {
        const b = g.fov * Math.PI / 180, G = 2 * Math.tan(b / 2) * R, $ = G * (T / C);
        return {
          width: $,
          height: G,
          top: P,
          left: L,
          factor: T / $,
          distance: R,
          aspect: N
        };
      }
    }
    let v;
    const _ = (g) => l((x) => ({
      performance: {
        ...x.performance,
        current: g
      }
    })), w = new me();
    return {
      set: l,
      get: c,
      // Mock objects that have to be configured
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      xr: null,
      scene: null,
      invalidate: (g = 1) => n(c(), g),
      advance: (g, x) => e(g, x, c()),
      legacy: !1,
      linear: !1,
      flat: !1,
      controls: null,
      clock: new z_(),
      pointer: w,
      mouse: w,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const g = c();
          v && clearTimeout(v), g.performance.current !== g.performance.min && _(g.performance.min), v = setTimeout(() => _(c().performance.max), g.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        updateStyle: !1
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: m
      },
      setEvents: (g) => l((x) => ({
        ...x,
        events: {
          ...x.events,
          ...g
        }
      })),
      setSize: (g, x, S, T, C) => {
        const P = c().camera, L = {
          width: g,
          height: x,
          top: T || 0,
          left: C || 0,
          updateStyle: S
        };
        l((N) => ({
          size: L,
          viewport: {
            ...N.viewport,
            ...m(P, h, L)
          }
        }));
      },
      setDpr: (g) => l((x) => {
        const S = tC(g);
        return {
          viewport: {
            ...x.viewport,
            dpr: S,
            initialDpr: x.viewport.initialDpr || S
          }
        };
      }),
      setFrameloop: (g = "always") => {
        const x = c().clock;
        x.stop(), x.elapsedTime = 0, g !== "never" && (x.start(), x.elapsedTime = 0), l(() => ({
          frameloop: g
        }));
      },
      previousRoot: void 0,
      internal: {
        active: !1,
        priority: 0,
        frames: 0,
        lastEvent: /* @__PURE__ */ xe.createRef(),
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        subscribe: (g, x, S) => {
          const T = c().internal;
          return T.priority = T.priority + (x > 0 ? 1 : 0), T.subscribers.push({
            ref: g,
            priority: x,
            store: S
          }), T.subscribers = T.subscribers.sort((C, P) => C.priority - P.priority), () => {
            const C = c().internal;
            C != null && C.subscribers && (C.priority = C.priority - (x > 0 ? 1 : 0), C.subscribers = C.subscribers.filter((P) => P.ref !== g));
          };
        }
      }
    };
  }), i = t.getState();
  let r = i.size, s = i.viewport.dpr, o = i.camera;
  return t.subscribe(() => {
    const {
      camera: l,
      size: c,
      viewport: f,
      gl: h,
      set: d
    } = t.getState();
    if (c.width !== r.width || c.height !== r.height || f.dpr !== s) {
      var m;
      r = c, s = f.dpr, kk(l, c), h.setPixelRatio(f.dpr);
      const v = (m = c.updateStyle) != null ? m : typeof HTMLCanvasElement < "u" && h.domElement instanceof HTMLCanvasElement;
      h.setSize(c.width, c.height, v);
    }
    l !== o && (o = l, d((v) => ({
      viewport: {
        ...v.viewport,
        ...v.viewport.getCurrentViewport(l)
      }
    })));
  }), t.subscribe((l) => n(l)), t;
};
let sd, Vk = /* @__PURE__ */ new Set(), Gk = /* @__PURE__ */ new Set(), Wk = /* @__PURE__ */ new Set();
function h0(n, e) {
  if (n.size)
    for (const {
      callback: t
    } of n.values())
      t(e);
}
function ku(n, e) {
  switch (n) {
    case "before":
      return h0(Vk, e);
    case "after":
      return h0(Gk, e);
    case "tail":
      return h0(Wk, e);
  }
}
let d0, p0;
function m0(n, e, t) {
  let i = e.clock.getDelta();
  for (e.frameloop === "never" && typeof n == "number" && (i = n - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = n), d0 = e.internal.subscribers, sd = 0; sd < d0.length; sd++)
    p0 = d0[sd], p0.ref.current(p0.store.getState(), i, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function Xk(n) {
  let e = !1, t = !1, i, r, s;
  function o(f) {
    r = requestAnimationFrame(o), e = !0, i = 0, ku("before", f), t = !0;
    for (const d of n.values()) {
      var h;
      s = d.store.getState(), s.internal.active && (s.frameloop === "always" || s.internal.frames > 0) && !((h = s.gl.xr) != null && h.isPresenting) && (i += m0(f, s));
    }
    if (t = !1, ku("after", f), i === 0)
      return ku("tail", f), e = !1, cancelAnimationFrame(r);
  }
  function l(f, h = 1) {
    var d;
    if (!f)
      return n.forEach((m) => l(m.store.getState(), h));
    (d = f.gl.xr) != null && d.isPresenting || !f.internal.active || f.frameloop === "never" || (h > 1 ? f.internal.frames = Math.min(60, f.internal.frames + h) : t ? f.internal.frames = 2 : f.internal.frames = 1, e || (e = !0, requestAnimationFrame(o)));
  }
  function c(f, h = !0, d, m) {
    if (h && ku("before", f), d)
      m0(f, d, m);
    else
      for (const v of n.values())
        m0(f, v.store.getState());
    h && ku("after", f);
  }
  return {
    loop: o,
    invalidate: l,
    advance: c
  };
}
function oC() {
  const n = xe.useContext(sC);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function ls(n = (t) => t, e) {
  return oC()(n, e);
}
function Kp(n, e = 0) {
  const t = oC(), i = t.getState().internal.subscribe, r = Q2(n);
  return ef(() => i(r, e, t), [e, i, t]), null;
}
const Wl = /* @__PURE__ */ new Map(), {
  invalidate: dw,
  advance: pw
} = Xk(Wl), {
  reconciler: ip,
  applyProps: il
} = Lk(Wl, Fk), rl = {
  objects: "shallow",
  strict: !1
}, jk = (n, e) => {
  const t = typeof n == "function" ? n(e) : n;
  return rC(t) ? t : new __({
    powerPreference: "high-performance",
    canvas: e,
    antialias: !0,
    alpha: !0,
    ...n
  });
};
function Yk(n, e) {
  const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
  if (e) {
    const {
      width: i,
      height: r,
      top: s,
      left: o,
      updateStyle: l = t
    } = e;
    return {
      width: i,
      height: r,
      top: s,
      left: o,
      updateStyle: l
    };
  } else if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) {
    const {
      width: i,
      height: r,
      top: s,
      left: o
    } = n.parentElement.getBoundingClientRect();
    return {
      width: i,
      height: r,
      top: s,
      left: o,
      updateStyle: t
    };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0,
      updateStyle: t
    };
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function qk(n) {
  const e = Wl.get(n), t = e == null ? void 0 : e.fiber, i = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const r = typeof reportError == "function" ? (
    // In modern browsers, reportError will dispatch an error event,
    // emulating an uncaught JavaScript error.
    reportError
  ) : (
    // In older browsers and test environments, fallback to console.error.
    console.error
  ), s = i || Hk(dw, pw), o = t || ip.createContainer(s, El.ConcurrentRoot, null, !1, null, "", r, null);
  e || Wl.set(n, {
    fiber: o,
    store: s
  });
  let l, c = !1, f;
  return {
    configure(h = {}) {
      let {
        gl: d,
        size: m,
        scene: v,
        events: _,
        onCreated: w,
        shadows: M = !1,
        linear: g = !1,
        flat: x = !1,
        legacy: S = !1,
        orthographic: T = !1,
        frameloop: C = "always",
        dpr: P = [1, 2],
        performance: L,
        raycaster: N,
        camera: R,
        onPointerMissed: b
      } = h, G = s.getState(), $ = G.gl;
      G.gl || G.set({
        gl: $ = jk(d, n)
      });
      let Y = G.raycaster;
      Y || G.set({
        raycaster: Y = new W2()
      });
      const {
        params: K,
        ...J
      } = N || {};
      if (jt.equ(J, Y, rl) || il(Y, {
        ...J
      }), jt.equ(K, Y.params, rl) || il(Y, {
        params: {
          ...Y.params,
          ...K
        }
      }), !G.camera || G.camera === f && !jt.equ(f, R, rl)) {
        f = R;
        const W = R instanceof Yc, V = W ? R : T ? new Vr(0, 0, 0, 0, 0.1, 1e3) : new Qt(75, 0, 0.1, 1e3);
        W || (V.position.z = 5, R && (il(V, R), ("aspect" in R || "left" in R || "right" in R || "bottom" in R || "top" in R) && (V.manual = !0, V.updateProjectionMatrix())), !G.camera && !(R != null && R.rotation) && V.lookAt(0, 0, 0)), G.set({
          camera: V
        }), Y.camera = V;
      }
      if (!G.scene) {
        let W;
        v != null && v.isScene ? W = v : (W = new x_(), v && il(W, v)), G.set({
          scene: ol(W)
        });
      }
      if (!G.xr) {
        var oe;
        const W = (de, ye) => {
          const Te = s.getState();
          Te.frameloop !== "never" && pw(de, !0, Te, ye);
        }, V = () => {
          const de = s.getState();
          de.gl.xr.enabled = de.gl.xr.isPresenting, de.gl.xr.setAnimationLoop(de.gl.xr.isPresenting ? W : null), de.gl.xr.isPresenting || dw(de);
        }, j = {
          connect() {
            const de = s.getState().gl;
            de.xr.addEventListener("sessionstart", V), de.xr.addEventListener("sessionend", V);
          },
          disconnect() {
            const de = s.getState().gl;
            de.xr.removeEventListener("sessionstart", V), de.xr.removeEventListener("sessionend", V);
          }
        };
        typeof ((oe = $.xr) == null ? void 0 : oe.addEventListener) == "function" && j.connect(), G.set({
          xr: j
        });
      }
      if ($.shadowMap) {
        const W = $.shadowMap.enabled, V = $.shadowMap.type;
        if ($.shadowMap.enabled = !!M, jt.boo(M))
          $.shadowMap.type = $u;
        else if (jt.str(M)) {
          var ne;
          const j = {
            basic: VT,
            percentage: Mp,
            soft: $u,
            variance: hr
          };
          $.shadowMap.type = (ne = j[M]) != null ? ne : $u;
        } else
          jt.obj(M) && Object.assign($.shadowMap, M);
        (W !== $.shadowMap.enabled || V !== $.shadowMap.type) && ($.shadowMap.needsUpdate = !0);
      }
      const O = K2();
      O && ("enabled" in O ? O.enabled = !S : "legacyMode" in O && (O.legacyMode = S)), c || il($, {
        outputEncoding: g ? 3e3 : 3001,
        toneMapping: x ? _r : e_
      }), G.legacy !== S && G.set(() => ({
        legacy: S
      })), G.linear !== g && G.set(() => ({
        linear: g
      })), G.flat !== x && G.set(() => ({
        flat: x
      })), d && !jt.fun(d) && !rC(d) && !jt.equ(d, $, rl) && il($, d), _ && !G.events.handlers && G.set({
        events: _(s)
      });
      const X = Yk(n, m);
      return jt.equ(X, G.size, rl) || G.setSize(X.width, X.height, X.updateStyle, X.top, X.left), P && G.viewport.dpr !== tC(P) && G.setDpr(P), G.frameloop !== C && G.setFrameloop(C), G.onPointerMissed || G.set({
        onPointerMissed: b
      }), L && !jt.equ(L, G.performance, rl) && G.set((W) => ({
        performance: {
          ...W.performance,
          ...L
        }
      })), l = w, c = !0, this;
    },
    render(h) {
      return c || this.configure(), ip.updateContainer(/* @__PURE__ */ se.jsx(Zk, {
        store: s,
        children: h,
        onCreated: l,
        rootElement: n
      }), o, null, () => {
      }), s;
    },
    unmount() {
      aC(n);
    }
  };
}
function Zk({
  store: n,
  children: e,
  onCreated: t,
  rootElement: i
}) {
  return ef(() => {
    const r = n.getState();
    r.set((s) => ({
      internal: {
        ...s.internal,
        active: !0
      }
    })), t && t(r), n.getState().events.connected || r.events.connect == null || r.events.connect(i);
  }, []), /* @__PURE__ */ se.jsx(sC.Provider, {
    value: n,
    children: e
  });
}
function aC(n, e) {
  const t = Wl.get(n), i = t == null ? void 0 : t.fiber;
  if (i) {
    const r = t == null ? void 0 : t.store.getState();
    r && (r.internal.active = !1), ip.updateContainer(null, i, null, () => {
      r && setTimeout(() => {
        try {
          var s, o, l, c;
          r.events.disconnect == null || r.events.disconnect(), (s = r.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(), (l = r.gl) == null || l.forceContextLoss == null || l.forceContextLoss(), (c = r.gl) != null && c.xr && r.xr.disconnect(), Uk(r), Wl.delete(n), e && e(n);
        } catch {
        }
      }, 500);
    });
  }
}
ip.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: xe.version
});
const g0 = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function Kk(n) {
  const {
    handlePointer: e
  } = Bk(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, i, r) {
      i.pointer.set(t.offsetX / i.size.width * 2 - 1, -(t.offsetY / i.size.height) * 2 + 1), i.raycaster.setFromCamera(i.pointer, i.camera);
    },
    connected: void 0,
    handlers: Object.keys(g0).reduce((t, i) => ({
      ...t,
      [i]: e(i)
    }), {}),
    update: () => {
      var t;
      const {
        events: i,
        internal: r
      } = n.getState();
      (t = r.lastEvent) != null && t.current && i.handlers && i.handlers.onPointerMove(r.lastEvent.current);
    },
    connect: (t) => {
      var i;
      const {
        set: r,
        events: s
      } = n.getState();
      s.disconnect == null || s.disconnect(), r((o) => ({
        events: {
          ...o.events,
          connected: t
        }
      })), Object.entries((i = s.handlers) != null ? i : []).forEach(([o, l]) => {
        const [c, f] = g0[o];
        t.addEventListener(c, l, {
          passive: f
        });
      });
    },
    disconnect: () => {
      const {
        set: t,
        events: i
      } = n.getState();
      if (i.connected) {
        var r;
        Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => {
          if (i && i.connected instanceof HTMLElement) {
            const [l] = g0[s];
            i.connected.removeEventListener(l, o);
          }
        }), t((s) => ({
          events: {
            ...s.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
function mw(n, e) {
  let t;
  return (...i) => {
    window.clearTimeout(t), t = window.setTimeout(() => n(...i), e);
  };
}
function Jk({ debounce: n, scroll: e, polyfill: t, offsetSize: i } = { debounce: 0, scroll: !1, offsetSize: !1 }) {
  const r = t || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!r)
    throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [s, o] = xe.useState({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), l = xe.useRef({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: s, orientationHandler: null }), c = n ? typeof n == "number" ? n : n.scroll : null, f = n ? typeof n == "number" ? n : n.resize : null, h = xe.useRef(!1);
  xe.useEffect(() => (h.current = !0, () => void (h.current = !1)));
  const [d, m, v] = xe.useMemo(() => {
    const g = () => {
      if (!l.current.element)
        return;
      const { left: x, top: S, width: T, height: C, bottom: P, right: L, x: N, y: R } = l.current.element.getBoundingClientRect(), b = { left: x, top: S, width: T, height: C, bottom: P, right: L, x: N, y: R };
      l.current.element instanceof HTMLElement && i && (b.height = l.current.element.offsetHeight, b.width = l.current.element.offsetWidth), Object.freeze(b), h.current && !tF(l.current.lastBounds, b) && o(l.current.lastBounds = b);
    };
    return [g, f ? mw(g, f) : g, c ? mw(g, c) : g];
  }, [o, i, c, f]);
  function _() {
    l.current.scrollContainers && (l.current.scrollContainers.forEach((g) => g.removeEventListener("scroll", v, !0)), l.current.scrollContainers = null), l.current.resizeObserver && (l.current.resizeObserver.disconnect(), l.current.resizeObserver = null), l.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", l.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", l.current.orientationHandler));
  }
  function w() {
    l.current.element && (l.current.resizeObserver = new r(v), l.current.resizeObserver.observe(l.current.element), e && l.current.scrollContainers && l.current.scrollContainers.forEach((g) => g.addEventListener("scroll", v, { capture: !0, passive: !0 })), l.current.orientationHandler = () => {
      v();
    }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", l.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", l.current.orientationHandler));
  }
  const M = (g) => {
    !g || g === l.current.element || (_(), l.current.element = g, l.current.scrollContainers = lC(g), w());
  };
  return $k(v, !!e), Qk(m), xe.useEffect(() => {
    _(), w();
  }, [e, v, m]), xe.useEffect(() => _, []), [M, s, d];
}
function Qk(n) {
  xe.useEffect(() => {
    const e = n;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [n]);
}
function $k(n, e) {
  xe.useEffect(() => {
    if (e) {
      const t = n;
      return window.addEventListener("scroll", t, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", t, !0);
    }
  }, [n, e]);
}
function lC(n) {
  const e = [];
  if (!n || n === document.body)
    return e;
  const { overflow: t, overflowX: i, overflowY: r } = window.getComputedStyle(n);
  return [t, i, r].some((s) => s === "auto" || s === "scroll") && e.push(n), [...e, ...lC(n.parentElement)];
}
const eF = ["x", "y", "top", "bottom", "left", "right", "width", "height"], tF = (n, e) => eF.every((t) => n[t] === e[t]);
var nF = Object.defineProperty, iF = Object.defineProperties, rF = Object.getOwnPropertyDescriptors, gw = Object.getOwnPropertySymbols, sF = Object.prototype.hasOwnProperty, oF = Object.prototype.propertyIsEnumerable, vw = (n, e, t) => e in n ? nF(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, yw = (n, e) => {
  for (var t in e || (e = {}))
    sF.call(e, t) && vw(n, t, e[t]);
  if (gw)
    for (var t of gw(e))
      oF.call(e, t) && vw(n, t, e[t]);
  return n;
}, aF = (n, e) => iF(n, rF(e)), _w, xw;
typeof window < "u" && ((_w = window.document) != null && _w.createElement || ((xw = window.navigator) == null ? void 0 : xw.product) === "ReactNative") ? xe.useLayoutEffect : xe.useEffect;
function uC(n, e, t) {
  if (!n)
    return;
  if (t(n) === !0)
    return n;
  let i = e ? n.return : n.child;
  for (; i; ) {
    const r = uC(i, e, t);
    if (r)
      return r;
    i = e ? null : i.sibling;
  }
}
function cC(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return n;
  }
}
const Sw = console.error;
console.error = function() {
  const n = [...arguments].join("");
  if (n != null && n.startsWith("Warning:") && n.includes("useContext")) {
    console.error = Sw;
    return;
  }
  return Sw.apply(this, arguments);
};
const W_ = cC(xe.createContext(null));
class fC extends xe.Component {
  render() {
    return /* @__PURE__ */ xe.createElement(W_.Provider, {
      value: this._reactInternals
    }, this.props.children);
  }
}
function lF() {
  const n = xe.useContext(W_);
  if (n === null)
    throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const e = xe.useId();
  return xe.useMemo(() => {
    for (const i of [n, n == null ? void 0 : n.alternate]) {
      if (!i)
        continue;
      const r = uC(i, !1, (s) => {
        let o = s.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e)
            return !0;
          o = o.next;
        }
      });
      if (r)
        return r;
    }
  }, [n, e]);
}
function uF() {
  const n = lF(), [e] = xe.useState(() => /* @__PURE__ */ new Map());
  e.clear();
  let t = n;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const r = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
      r && r !== W_ && !e.has(r) && e.set(r, xe.useContext(cC(r)));
    }
    t = t.return;
  }
  return e;
}
function cF() {
  const n = uF();
  return xe.useMemo(
    () => Array.from(n.keys()).reduce(
      (e, t) => (i) => /* @__PURE__ */ xe.createElement(e, null, /* @__PURE__ */ xe.createElement(t.Provider, aF(yw({}, i), {
        value: n.get(t)
      }))),
      (e) => /* @__PURE__ */ xe.createElement(fC, yw({}, e))
    ),
    [n]
  );
}
const fF = /* @__PURE__ */ xe.forwardRef(function({
  children: e,
  fallback: t,
  resize: i,
  style: r,
  gl: s,
  events: o = Kk,
  eventSource: l,
  eventPrefix: c,
  shadows: f,
  linear: h,
  flat: d,
  legacy: m,
  orthographic: v,
  frameloop: _,
  dpr: w,
  performance: M,
  raycaster: g,
  camera: x,
  scene: S,
  onPointerMissed: T,
  onCreated: C,
  ...P
}, L) {
  xe.useMemo(() => bk(wk), []);
  const N = cF(), [R, b] = Jk({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...i
  }), G = xe.useRef(null), $ = xe.useRef(null);
  xe.useImperativeHandle(L, () => G.current);
  const Y = Q2(T), [K, J] = xe.useState(!1), [oe, ne] = xe.useState(!1);
  if (K)
    throw K;
  if (oe)
    throw oe;
  const O = xe.useRef(null);
  ef(() => {
    const W = G.current;
    b.width > 0 && b.height > 0 && W && (O.current || (O.current = qk(W)), O.current.configure({
      gl: s,
      events: o,
      shadows: f,
      linear: h,
      flat: d,
      legacy: m,
      orthographic: v,
      frameloop: _,
      dpr: w,
      performance: M,
      raycaster: g,
      camera: x,
      scene: S,
      size: b,
      // Pass mutable reference to onPointerMissed so it's free to update
      onPointerMissed: (...V) => Y.current == null ? void 0 : Y.current(...V),
      onCreated: (V) => {
        V.events.connect == null || V.events.connect(l ? Ik(l) ? l.current : l : $.current), c && V.setEvents({
          compute: (j, de) => {
            const ye = j[c + "X"], Te = j[c + "Y"];
            de.pointer.set(ye / de.size.width * 2 - 1, -(Te / de.size.height) * 2 + 1), de.raycaster.setFromCamera(de.pointer, de.camera);
          }
        }), C == null || C(V);
      }
    }), O.current.render(/* @__PURE__ */ se.jsx(N, {
      children: /* @__PURE__ */ se.jsx($2, {
        set: ne,
        children: /* @__PURE__ */ se.jsx(xe.Suspense, {
          fallback: /* @__PURE__ */ se.jsx(Nk, {
            set: J
          }),
          children: e ?? null
        })
      })
    })));
  }), xe.useEffect(() => {
    const W = G.current;
    if (W)
      return () => aC(W);
  }, []);
  const X = l ? "none" : "auto";
  return /* @__PURE__ */ se.jsx("div", {
    ref: $,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: X,
      ...r
    },
    ...P,
    children: /* @__PURE__ */ se.jsx("div", {
      ref: R,
      style: {
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ se.jsx("canvas", {
        ref: G,
        style: {
          display: "block"
        },
        children: t
      })
    })
  });
}), hF = /* @__PURE__ */ xe.forwardRef(function(e, t) {
  return /* @__PURE__ */ se.jsx(fC, {
    children: /* @__PURE__ */ se.jsx(fF, {
      ...e,
      ref: t
    })
  });
});
function rp() {
  return rp = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t)
        ({}).hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }, rp.apply(null, arguments);
}
const tf = /* @__PURE__ */ new D(), X_ = /* @__PURE__ */ new D(), dF = /* @__PURE__ */ new D(), Mw = /* @__PURE__ */ new me();
function pF(n, e, t) {
  const i = tf.setFromMatrixPosition(n.matrixWorld);
  i.project(e);
  const r = t.width / 2, s = t.height / 2;
  return [i.x * r + r, -(i.y * s) + s];
}
function mF(n, e) {
  const t = tf.setFromMatrixPosition(n.matrixWorld), i = X_.setFromMatrixPosition(e.matrixWorld), r = t.sub(i), s = e.getWorldDirection(dF);
  return r.angleTo(s) > Math.PI / 2;
}
function gF(n, e, t, i) {
  const r = tf.setFromMatrixPosition(n.matrixWorld), s = r.clone();
  s.project(e), Mw.set(s.x, s.y), t.setFromCamera(Mw, e);
  const o = t.intersectObjects(i, !0);
  if (o.length) {
    const l = o[0].distance;
    return r.distanceTo(t.ray.origin) < l;
  }
  return !0;
}
function vF(n, e) {
  if (e instanceof Vr)
    return e.zoom;
  if (e instanceof Qt) {
    const t = tf.setFromMatrixPosition(n.matrixWorld), i = X_.setFromMatrixPosition(e.matrixWorld), r = e.fov * Math.PI / 180, s = t.distanceTo(i);
    return 1 / (2 * Math.tan(r / 2) * s);
  } else
    return 1;
}
function yF(n, e, t) {
  if (e instanceof Qt || e instanceof Vr) {
    const i = tf.setFromMatrixPosition(n.matrixWorld), r = X_.setFromMatrixPosition(e.matrixWorld), s = i.distanceTo(r), o = (t[1] - t[0]) / (e.far - e.near), l = t[1] - o * e.far;
    return Math.round(o * s + l);
  }
}
const ny = (n) => Math.abs(n) < 1e-10 ? 0 : n;
function hC(n, e, t = "") {
  let i = "matrix3d(";
  for (let r = 0; r !== 16; r++)
    i += ny(e[r] * n.elements[r]) + (r !== 15 ? "," : ")");
  return t + i;
}
const _F = ((n) => (e) => hC(e, n))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), xF = ((n) => (e, t) => hC(e, n(t), "translate(-50%,-50%)"))((n) => [1 / n, 1 / n, 1 / n, 1, -1 / n, -1 / n, -1 / n, -1, 1 / n, 1 / n, 1 / n, 1, 1, 1, 1, 1]);
function SF(n) {
  return n && typeof n == "object" && "current" in n;
}
const MF = /* @__PURE__ */ xe.forwardRef(({
  children: n,
  eps: e = 1e-3,
  style: t,
  className: i,
  prepend: r,
  center: s,
  fullscreen: o,
  portal: l,
  distanceFactor: c,
  sprite: f = !1,
  transform: h = !1,
  occlude: d,
  onOcclude: m,
  castShadow: v,
  receiveShadow: _,
  material: w,
  geometry: M,
  zIndexRange: g = [16777271, 0],
  calculatePosition: x = pF,
  as: S = "div",
  wrapperClass: T,
  pointerEvents: C = "auto",
  ...P
}, L) => {
  const {
    gl: N,
    camera: R,
    scene: b,
    size: G,
    raycaster: $,
    events: Y,
    viewport: K
  } = ls(), [J] = xe.useState(() => document.createElement(S)), oe = xe.useRef(), ne = xe.useRef(null), O = xe.useRef(0), X = xe.useRef([0, 0]), W = xe.useRef(null), V = xe.useRef(null), j = (l == null ? void 0 : l.current) || Y.connected || N.domElement.parentNode, de = xe.useRef(null), ye = xe.useRef(!1), Te = xe.useMemo(() => d && d !== "blending" || Array.isArray(d) && d.length && SF(d[0]), [d]);
  xe.useLayoutEffect(() => {
    const lt = N.domElement;
    d && d === "blending" ? (lt.style.zIndex = `${Math.floor(g[0] / 2)}`, lt.style.position = "absolute", lt.style.pointerEvents = "none") : (lt.style.zIndex = null, lt.style.position = null, lt.style.pointerEvents = null);
  }, [d]), xe.useLayoutEffect(() => {
    if (ne.current) {
      const lt = oe.current = FT(J);
      if (b.updateMatrixWorld(), h)
        J.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
      else {
        const Re = x(ne.current, R, G);
        J.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${Re[0]}px,${Re[1]}px,0);transform-origin:0 0;`;
      }
      return j && (r ? j.prepend(J) : j.appendChild(J)), () => {
        j && j.removeChild(J), lt.unmount();
      };
    }
  }, [j, h]), xe.useLayoutEffect(() => {
    T && (J.className = T);
  }, [T]);
  const Ie = xe.useMemo(() => h ? {
    position: "absolute",
    top: 0,
    left: 0,
    width: G.width,
    height: G.height,
    transformStyle: "preserve-3d",
    pointerEvents: "none"
  } : {
    position: "absolute",
    transform: s ? "translate3d(-50%,-50%,0)" : "none",
    ...o && {
      top: -G.height / 2,
      left: -G.width / 2,
      width: G.width,
      height: G.height
    },
    ...t
  }, [t, s, o, G, h]), Be = xe.useMemo(() => ({
    position: "absolute",
    pointerEvents: C
  }), [C]);
  xe.useLayoutEffect(() => {
    if (ye.current = !1, h) {
      var lt;
      (lt = oe.current) == null || lt.render(/* @__PURE__ */ xe.createElement("div", {
        ref: W,
        style: Ie
      }, /* @__PURE__ */ xe.createElement("div", {
        ref: V,
        style: Be
      }, /* @__PURE__ */ xe.createElement("div", {
        ref: L,
        className: i,
        style: t,
        children: n
      }))));
    } else {
      var Re;
      (Re = oe.current) == null || Re.render(/* @__PURE__ */ xe.createElement("div", {
        ref: L,
        style: Ie,
        className: i,
        children: n
      }));
    }
  });
  const je = xe.useRef(!0);
  Kp((lt) => {
    if (ne.current) {
      R.updateMatrixWorld(), ne.current.updateWorldMatrix(!0, !1);
      const Re = h ? X.current : x(ne.current, R, G);
      if (h || Math.abs(O.current - R.zoom) > e || Math.abs(X.current[0] - Re[0]) > e || Math.abs(X.current[1] - Re[1]) > e) {
        const z = mF(ne.current, R);
        let ge = !1;
        Te && (Array.isArray(d) ? ge = d.map((He) => He.current) : d !== "blending" && (ge = [b]));
        const fe = je.current;
        if (ge) {
          const He = gF(ne.current, R, $, ge);
          je.current = He && !z;
        } else
          je.current = !z;
        fe !== je.current && (m ? m(!je.current) : J.style.display = je.current ? "block" : "none");
        const Se = Math.floor(g[0] / 2), ve = d ? Te ? [g[0], Se] : [Se - 1, 0] : g;
        if (J.style.zIndex = `${yF(ne.current, R, ve)}`, h) {
          const [He, Oe] = [G.width / 2, G.height / 2], Fe = R.projectionMatrix.elements[5] * Oe, {
            isOrthographicCamera: Je,
            top: mt,
            left: Ut,
            bottom: F,
            right: I
          } = R, ae = _F(R.matrixWorldInverse), we = Je ? `scale(${Fe})translate(${ny(-(I + Ut) / 2)}px,${ny((mt + F) / 2)}px)` : `translateZ(${Fe}px)`;
          let _e = ne.current.matrixWorld;
          f && (_e = R.matrixWorldInverse.clone().transpose().copyPosition(_e).scale(ne.current.scale), _e.elements[3] = _e.elements[7] = _e.elements[11] = 0, _e.elements[15] = 1), J.style.width = G.width + "px", J.style.height = G.height + "px", J.style.perspective = Je ? "" : `${Fe}px`, W.current && V.current && (W.current.style.transform = `${we}${ae}translate(${He}px,${Oe}px)`, V.current.style.transform = xF(_e, 1 / ((c || 10) / 400)));
        } else {
          const He = c === void 0 ? 1 : vF(ne.current, R) * c;
          J.style.transform = `translate3d(${Re[0]}px,${Re[1]}px,0) scale(${He})`;
        }
        X.current = Re, O.current = R.zoom;
      }
    }
    if (!Te && de.current && !ye.current)
      if (h) {
        if (W.current) {
          const Re = W.current.children[0];
          if (Re != null && Re.clientWidth && Re != null && Re.clientHeight) {
            const {
              isOrthographicCamera: z
            } = R;
            if (z || M)
              P.scale && (Array.isArray(P.scale) ? P.scale instanceof D ? de.current.scale.copy(P.scale.clone().divideScalar(1)) : de.current.scale.set(1 / P.scale[0], 1 / P.scale[1], 1 / P.scale[2]) : de.current.scale.setScalar(1 / P.scale));
            else {
              const ge = (c || 10) / 400, fe = Re.clientWidth * ge, Se = Re.clientHeight * ge;
              de.current.scale.set(fe, Se, 1);
            }
            ye.current = !0;
          }
        }
      } else {
        const Re = J.children[0];
        if (Re != null && Re.clientWidth && Re != null && Re.clientHeight) {
          const z = 1 / K.factor, ge = Re.clientWidth * z, fe = Re.clientHeight * z;
          de.current.scale.set(ge, fe, 1), ye.current = !0;
        }
        de.current.lookAt(lt.camera.position);
      }
  });
  const vt = xe.useMemo(() => ({
    vertexShader: h ? void 0 : (
      /* glsl */
      `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `
    ),
    fragmentShader: (
      /* glsl */
      `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `
    )
  }), [h]);
  return /* @__PURE__ */ xe.createElement("group", rp({}, P, {
    ref: ne
  }), d && !Te && /* @__PURE__ */ xe.createElement("mesh", {
    castShadow: v,
    receiveShadow: _,
    ref: de
  }, M || /* @__PURE__ */ xe.createElement("planeGeometry", null), w || /* @__PURE__ */ xe.createElement("shaderMaterial", {
    side: gr,
    vertexShader: vt.vertexShader,
    fragmentShader: vt.fragmentShader
  })));
});
var wF = Object.defineProperty, EF = (n, e, t) => e in n ? wF(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, TF = (n, e, t) => (EF(n, typeof e != "symbol" ? e + "" : e, t), t);
class AF {
  constructor() {
    TF(this, "_listeners");
  }
  /**
   * Adds a listener to an event type.
   * @param type The type of event to listen to.
   * @param listener The function that gets called when the event is fired.
   */
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  /**
      * Checks if listener is added to an event type.
      * @param type The type of event to listen to.
      * @param listener The function that gets called when the event is fired.
      */
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  /**
      * Removes a listener from an event type.
      * @param type The type of the listener that gets removed.
      * @param listener The listener function that gets removed.
      */
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  /**
      * Fire an event type.
      * @param event The event that gets fired.
      */
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++)
        r[s].call(this, e);
      e.target = null;
    }
  }
}
var CF = Object.defineProperty, RF = (n, e, t) => e in n ? CF(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, it = (n, e, t) => (RF(n, typeof e != "symbol" ? e + "" : e, t), t);
const od = /* @__PURE__ */ new ma(), ww = /* @__PURE__ */ new fs(), PF = Math.cos(70 * (Math.PI / 180)), Ew = (n, e) => (n % e + e) % e;
let bF = class extends AF {
  constructor(e, t) {
    super(), it(this, "object"), it(this, "domElement"), it(this, "enabled", !0), it(this, "target", new D()), it(this, "minDistance", 0), it(this, "maxDistance", 1 / 0), it(this, "minZoom", 0), it(this, "maxZoom", 1 / 0), it(this, "minPolarAngle", 0), it(this, "maxPolarAngle", Math.PI), it(this, "minAzimuthAngle", -1 / 0), it(this, "maxAzimuthAngle", 1 / 0), it(this, "enableDamping", !1), it(this, "dampingFactor", 0.05), it(this, "enableZoom", !0), it(this, "zoomSpeed", 1), it(this, "enableRotate", !0), it(this, "rotateSpeed", 1), it(this, "enablePan", !0), it(this, "panSpeed", 1), it(this, "screenSpacePanning", !0), it(this, "keyPanSpeed", 7), it(this, "zoomToCursor", !1), it(this, "autoRotate", !1), it(this, "autoRotateSpeed", 2), it(this, "reverseOrbit", !1), it(this, "reverseHorizontalOrbit", !1), it(this, "reverseVerticalOrbit", !1), it(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), it(this, "mouseButtons", {
      LEFT: Bo.ROTATE,
      MIDDLE: Bo.DOLLY,
      RIGHT: Bo.PAN
    }), it(this, "touches", { ONE: Ho.ROTATE, TWO: Ho.DOLLY_PAN }), it(this, "target0"), it(this, "position0"), it(this, "zoom0"), it(this, "_domElementKeyEvents", null), it(this, "getPolarAngle"), it(this, "getAzimuthalAngle"), it(this, "setPolarAngle"), it(this, "setAzimuthalAngle"), it(this, "getDistance"), it(this, "getZoomScale"), it(this, "listenToKeyEvents"), it(this, "stopListenToKeyEvents"), it(this, "saveState"), it(this, "reset"), it(this, "update"), it(this, "connect"), it(this, "dispose"), it(this, "dollyIn"), it(this, "dollyOut"), it(this, "getScale"), it(this, "setScale"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => h.phi, this.getAzimuthalAngle = () => h.theta, this.setPolarAngle = (B) => {
      let pe = Ew(B, 2 * Math.PI), Ne = h.phi;
      Ne < 0 && (Ne += 2 * Math.PI), pe < 0 && (pe += 2 * Math.PI);
      let H = Math.abs(pe - Ne);
      2 * Math.PI - H < H && (pe < Ne ? pe += 2 * Math.PI : Ne += 2 * Math.PI), d.phi = pe - Ne, i.update();
    }, this.setAzimuthalAngle = (B) => {
      let pe = Ew(B, 2 * Math.PI), Ne = h.theta;
      Ne < 0 && (Ne += 2 * Math.PI), pe < 0 && (pe += 2 * Math.PI);
      let H = Math.abs(pe - Ne);
      2 * Math.PI - H < H && (pe < Ne ? pe += 2 * Math.PI : Ne += 2 * Math.PI), d.theta = pe - Ne, i.update();
    }, this.getDistance = () => i.object.position.distanceTo(i.target), this.listenToKeyEvents = (B) => {
      B.addEventListener("keydown", Pe), this._domElementKeyEvents = B;
    }, this.stopListenToKeyEvents = () => {
      this._domElementKeyEvents.removeEventListener("keydown", Pe), this._domElementKeyEvents = null;
    }, this.saveState = () => {
      i.target0.copy(i.target), i.position0.copy(i.object.position), i.zoom0 = i.object.zoom;
    }, this.reset = () => {
      i.target.copy(i.target0), i.object.position.copy(i.position0), i.object.zoom = i.zoom0, i.object.updateProjectionMatrix(), i.dispatchEvent(r), i.update(), c = l.NONE;
    }, this.update = (() => {
      const B = new D(), pe = new D(0, 1, 0), Ne = new Qn().setFromUnitVectors(e.up, pe), H = Ne.clone().invert(), Me = new D(), ie = new Qn(), Ae = 2 * Math.PI;
      return function() {
        const Et = i.object.position;
        Ne.setFromUnitVectors(e.up, pe), H.copy(Ne).invert(), B.copy(Et).sub(i.target), B.applyQuaternion(Ne), h.setFromVector3(B), i.autoRotate && c === l.NONE && K($()), i.enableDamping ? (h.theta += d.theta * i.dampingFactor, h.phi += d.phi * i.dampingFactor) : (h.theta += d.theta, h.phi += d.phi);
        let At = i.minAzimuthAngle, Dt = i.maxAzimuthAngle;
        isFinite(At) && isFinite(Dt) && (At < -Math.PI ? At += Ae : At > Math.PI && (At -= Ae), Dt < -Math.PI ? Dt += Ae : Dt > Math.PI && (Dt -= Ae), At <= Dt ? h.theta = Math.max(At, Math.min(Dt, h.theta)) : h.theta = h.theta > (At + Dt) / 2 ? Math.max(At, h.theta) : Math.min(Dt, h.theta)), h.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, h.phi)), h.makeSafe(), i.enableDamping === !0 ? i.target.addScaledVector(v, i.dampingFactor) : i.target.add(v), i.zoomToCursor && R || i.object.isOrthographicCamera ? h.radius = de(h.radius) : h.radius = de(h.radius * m), B.setFromSpherical(h), B.applyQuaternion(H), Et.copy(i.target).add(B), i.object.matrixAutoUpdate || i.object.updateMatrix(), i.object.lookAt(i.target), i.enableDamping === !0 ? (d.theta *= 1 - i.dampingFactor, d.phi *= 1 - i.dampingFactor, v.multiplyScalar(1 - i.dampingFactor)) : (d.set(0, 0, 0), v.set(0, 0, 0));
        let Sn = !1;
        if (i.zoomToCursor && R) {
          let Nt = null;
          if (i.object instanceof Qt && i.object.isPerspectiveCamera) {
            const Mn = B.length();
            Nt = de(Mn * m);
            const nn = Mn - Nt;
            i.object.position.addScaledVector(L, nn), i.object.updateMatrixWorld();
          } else if (i.object.isOrthographicCamera) {
            const Mn = new D(N.x, N.y, 0);
            Mn.unproject(i.object), i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / m)), i.object.updateProjectionMatrix(), Sn = !0;
            const nn = new D(N.x, N.y, 0);
            nn.unproject(i.object), i.object.position.sub(nn).add(Mn), i.object.updateMatrixWorld(), Nt = B.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), i.zoomToCursor = !1;
          Nt !== null && (i.screenSpacePanning ? i.target.set(0, 0, -1).transformDirection(i.object.matrix).multiplyScalar(Nt).add(i.object.position) : (od.origin.copy(i.object.position), od.direction.set(0, 0, -1).transformDirection(i.object.matrix), Math.abs(i.object.up.dot(od.direction)) < PF ? e.lookAt(i.target) : (ww.setFromNormalAndCoplanarPoint(i.object.up, i.target), od.intersectPlane(ww, i.target))));
        } else
          i.object instanceof Vr && i.object.isOrthographicCamera && (Sn = m !== 1, Sn && (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / m)), i.object.updateProjectionMatrix()));
        return m = 1, R = !1, Sn || Me.distanceToSquared(i.object.position) > f || 8 * (1 - ie.dot(i.object.quaternion)) > f ? (i.dispatchEvent(r), Me.copy(i.object.position), ie.copy(i.object.quaternion), Sn = !1, !0) : !1;
      };
    })(), this.connect = (B) => {
      i.domElement = B, i.domElement.style.touchAction = "none", i.domElement.addEventListener("contextmenu", ue), i.domElement.addEventListener("pointerdown", Ut), i.domElement.addEventListener("pointercancel", I), i.domElement.addEventListener("wheel", _e);
    }, this.dispose = () => {
      var B, pe, Ne, H, Me, ie;
      i.domElement && (i.domElement.style.touchAction = "auto"), (B = i.domElement) == null || B.removeEventListener("contextmenu", ue), (pe = i.domElement) == null || pe.removeEventListener("pointerdown", Ut), (Ne = i.domElement) == null || Ne.removeEventListener("pointercancel", I), (H = i.domElement) == null || H.removeEventListener("wheel", _e), (Me = i.domElement) == null || Me.ownerDocument.removeEventListener("pointermove", F), (ie = i.domElement) == null || ie.ownerDocument.removeEventListener("pointerup", I), i._domElementKeyEvents !== null && i._domElementKeyEvents.removeEventListener("keydown", Pe);
    };
    const i = this, r = { type: "change" }, s = { type: "start" }, o = { type: "end" }, l = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let c = l.NONE;
    const f = 1e-6, h = new Qv(), d = new Qv();
    let m = 1;
    const v = new D(), _ = new me(), w = new me(), M = new me(), g = new me(), x = new me(), S = new me(), T = new me(), C = new me(), P = new me(), L = new D(), N = new me();
    let R = !1;
    const b = [], G = {};
    function $() {
      return 2 * Math.PI / 60 / 60 * i.autoRotateSpeed;
    }
    function Y() {
      return Math.pow(0.95, i.zoomSpeed);
    }
    function K(B) {
      i.reverseOrbit || i.reverseHorizontalOrbit ? d.theta += B : d.theta -= B;
    }
    function J(B) {
      i.reverseOrbit || i.reverseVerticalOrbit ? d.phi += B : d.phi -= B;
    }
    const oe = (() => {
      const B = new D();
      return function(Ne, H) {
        B.setFromMatrixColumn(H, 0), B.multiplyScalar(-Ne), v.add(B);
      };
    })(), ne = (() => {
      const B = new D();
      return function(Ne, H) {
        i.screenSpacePanning === !0 ? B.setFromMatrixColumn(H, 1) : (B.setFromMatrixColumn(H, 0), B.crossVectors(i.object.up, B)), B.multiplyScalar(Ne), v.add(B);
      };
    })(), O = (() => {
      const B = new D();
      return function(Ne, H) {
        const Me = i.domElement;
        if (Me && i.object instanceof Qt && i.object.isPerspectiveCamera) {
          const ie = i.object.position;
          B.copy(ie).sub(i.target);
          let Ae = B.length();
          Ae *= Math.tan(i.object.fov / 2 * Math.PI / 180), oe(2 * Ne * Ae / Me.clientHeight, i.object.matrix), ne(2 * H * Ae / Me.clientHeight, i.object.matrix);
        } else
          Me && i.object instanceof Vr && i.object.isOrthographicCamera ? (oe(
            Ne * (i.object.right - i.object.left) / i.object.zoom / Me.clientWidth,
            i.object.matrix
          ), ne(
            H * (i.object.top - i.object.bottom) / i.object.zoom / Me.clientHeight,
            i.object.matrix
          )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), i.enablePan = !1);
      };
    })();
    function X(B) {
      i.object instanceof Qt && i.object.isPerspectiveCamera || i.object instanceof Vr && i.object.isOrthographicCamera ? m = B : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1);
    }
    function W(B) {
      X(m / B);
    }
    function V(B) {
      X(m * B);
    }
    function j(B) {
      if (!i.zoomToCursor || !i.domElement)
        return;
      R = !0;
      const pe = i.domElement.getBoundingClientRect(), Ne = B.clientX - pe.left, H = B.clientY - pe.top, Me = pe.width, ie = pe.height;
      N.x = Ne / Me * 2 - 1, N.y = -(H / ie) * 2 + 1, L.set(N.x, N.y, 1).unproject(i.object).sub(i.object.position).normalize();
    }
    function de(B) {
      return Math.max(i.minDistance, Math.min(i.maxDistance, B));
    }
    function ye(B) {
      _.set(B.clientX, B.clientY);
    }
    function Te(B) {
      j(B), T.set(B.clientX, B.clientY);
    }
    function Ie(B) {
      g.set(B.clientX, B.clientY);
    }
    function Be(B) {
      w.set(B.clientX, B.clientY), M.subVectors(w, _).multiplyScalar(i.rotateSpeed);
      const pe = i.domElement;
      pe && (K(2 * Math.PI * M.x / pe.clientHeight), J(2 * Math.PI * M.y / pe.clientHeight)), _.copy(w), i.update();
    }
    function je(B) {
      C.set(B.clientX, B.clientY), P.subVectors(C, T), P.y > 0 ? W(Y()) : P.y < 0 && V(Y()), T.copy(C), i.update();
    }
    function vt(B) {
      x.set(B.clientX, B.clientY), S.subVectors(x, g).multiplyScalar(i.panSpeed), O(S.x, S.y), g.copy(x), i.update();
    }
    function lt(B) {
      j(B), B.deltaY < 0 ? V(Y()) : B.deltaY > 0 && W(Y()), i.update();
    }
    function Re(B) {
      let pe = !1;
      switch (B.code) {
        case i.keys.UP:
          O(0, i.keyPanSpeed), pe = !0;
          break;
        case i.keys.BOTTOM:
          O(0, -i.keyPanSpeed), pe = !0;
          break;
        case i.keys.LEFT:
          O(i.keyPanSpeed, 0), pe = !0;
          break;
        case i.keys.RIGHT:
          O(-i.keyPanSpeed, 0), pe = !0;
          break;
      }
      pe && (B.preventDefault(), i.update());
    }
    function z() {
      if (b.length == 1)
        _.set(b[0].pageX, b[0].pageY);
      else {
        const B = 0.5 * (b[0].pageX + b[1].pageX), pe = 0.5 * (b[0].pageY + b[1].pageY);
        _.set(B, pe);
      }
    }
    function ge() {
      if (b.length == 1)
        g.set(b[0].pageX, b[0].pageY);
      else {
        const B = 0.5 * (b[0].pageX + b[1].pageX), pe = 0.5 * (b[0].pageY + b[1].pageY);
        g.set(B, pe);
      }
    }
    function fe() {
      const B = b[0].pageX - b[1].pageX, pe = b[0].pageY - b[1].pageY, Ne = Math.sqrt(B * B + pe * pe);
      T.set(0, Ne);
    }
    function Se() {
      i.enableZoom && fe(), i.enablePan && ge();
    }
    function ve() {
      i.enableZoom && fe(), i.enableRotate && z();
    }
    function He(B) {
      if (b.length == 1)
        w.set(B.pageX, B.pageY);
      else {
        const Ne = Ve(B), H = 0.5 * (B.pageX + Ne.x), Me = 0.5 * (B.pageY + Ne.y);
        w.set(H, Me);
      }
      M.subVectors(w, _).multiplyScalar(i.rotateSpeed);
      const pe = i.domElement;
      pe && (K(2 * Math.PI * M.x / pe.clientHeight), J(2 * Math.PI * M.y / pe.clientHeight)), _.copy(w);
    }
    function Oe(B) {
      if (b.length == 1)
        x.set(B.pageX, B.pageY);
      else {
        const pe = Ve(B), Ne = 0.5 * (B.pageX + pe.x), H = 0.5 * (B.pageY + pe.y);
        x.set(Ne, H);
      }
      S.subVectors(x, g).multiplyScalar(i.panSpeed), O(S.x, S.y), g.copy(x);
    }
    function Fe(B) {
      const pe = Ve(B), Ne = B.pageX - pe.x, H = B.pageY - pe.y, Me = Math.sqrt(Ne * Ne + H * H);
      C.set(0, Me), P.set(0, Math.pow(C.y / T.y, i.zoomSpeed)), W(P.y), T.copy(C);
    }
    function Je(B) {
      i.enableZoom && Fe(B), i.enablePan && Oe(B);
    }
    function mt(B) {
      i.enableZoom && Fe(B), i.enableRotate && He(B);
    }
    function Ut(B) {
      var pe, Ne;
      i.enabled !== !1 && (b.length === 0 && ((pe = i.domElement) == null || pe.ownerDocument.addEventListener("pointermove", F), (Ne = i.domElement) == null || Ne.ownerDocument.addEventListener("pointerup", I)), Qe(B), B.pointerType === "touch" ? qe(B) : ae(B));
    }
    function F(B) {
      i.enabled !== !1 && (B.pointerType === "touch" ? be(B) : we(B));
    }
    function I(B) {
      var pe, Ne, H;
      $e(B), b.length === 0 && ((pe = i.domElement) == null || pe.releasePointerCapture(B.pointerId), (Ne = i.domElement) == null || Ne.ownerDocument.removeEventListener("pointermove", F), (H = i.domElement) == null || H.ownerDocument.removeEventListener("pointerup", I)), i.dispatchEvent(o), c = l.NONE;
    }
    function ae(B) {
      let pe;
      switch (B.button) {
        case 0:
          pe = i.mouseButtons.LEFT;
          break;
        case 1:
          pe = i.mouseButtons.MIDDLE;
          break;
        case 2:
          pe = i.mouseButtons.RIGHT;
          break;
        default:
          pe = -1;
      }
      switch (pe) {
        case Bo.DOLLY:
          if (i.enableZoom === !1)
            return;
          Te(B), c = l.DOLLY;
          break;
        case Bo.ROTATE:
          if (B.ctrlKey || B.metaKey || B.shiftKey) {
            if (i.enablePan === !1)
              return;
            Ie(B), c = l.PAN;
          } else {
            if (i.enableRotate === !1)
              return;
            ye(B), c = l.ROTATE;
          }
          break;
        case Bo.PAN:
          if (B.ctrlKey || B.metaKey || B.shiftKey) {
            if (i.enableRotate === !1)
              return;
            ye(B), c = l.ROTATE;
          } else {
            if (i.enablePan === !1)
              return;
            Ie(B), c = l.PAN;
          }
          break;
        default:
          c = l.NONE;
      }
      c !== l.NONE && i.dispatchEvent(s);
    }
    function we(B) {
      if (i.enabled !== !1)
        switch (c) {
          case l.ROTATE:
            if (i.enableRotate === !1)
              return;
            Be(B);
            break;
          case l.DOLLY:
            if (i.enableZoom === !1)
              return;
            je(B);
            break;
          case l.PAN:
            if (i.enablePan === !1)
              return;
            vt(B);
            break;
        }
    }
    function _e(B) {
      i.enabled === !1 || i.enableZoom === !1 || c !== l.NONE && c !== l.ROTATE || (B.preventDefault(), i.dispatchEvent(s), lt(B), i.dispatchEvent(o));
    }
    function Pe(B) {
      i.enabled === !1 || i.enablePan === !1 || Re(B);
    }
    function qe(B) {
      switch (et(B), b.length) {
        case 1:
          switch (i.touches.ONE) {
            case Ho.ROTATE:
              if (i.enableRotate === !1)
                return;
              z(), c = l.TOUCH_ROTATE;
              break;
            case Ho.PAN:
              if (i.enablePan === !1)
                return;
              ge(), c = l.TOUCH_PAN;
              break;
            default:
              c = l.NONE;
          }
          break;
        case 2:
          switch (i.touches.TWO) {
            case Ho.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1)
                return;
              Se(), c = l.TOUCH_DOLLY_PAN;
              break;
            case Ho.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1)
                return;
              ve(), c = l.TOUCH_DOLLY_ROTATE;
              break;
            default:
              c = l.NONE;
          }
          break;
        default:
          c = l.NONE;
      }
      c !== l.NONE && i.dispatchEvent(s);
    }
    function be(B) {
      switch (et(B), c) {
        case l.TOUCH_ROTATE:
          if (i.enableRotate === !1)
            return;
          He(B), i.update();
          break;
        case l.TOUCH_PAN:
          if (i.enablePan === !1)
            return;
          Oe(B), i.update();
          break;
        case l.TOUCH_DOLLY_PAN:
          if (i.enableZoom === !1 && i.enablePan === !1)
            return;
          Je(B), i.update();
          break;
        case l.TOUCH_DOLLY_ROTATE:
          if (i.enableZoom === !1 && i.enableRotate === !1)
            return;
          mt(B), i.update();
          break;
        default:
          c = l.NONE;
      }
    }
    function ue(B) {
      i.enabled !== !1 && B.preventDefault();
    }
    function Qe(B) {
      b.push(B);
    }
    function $e(B) {
      delete G[B.pointerId];
      for (let pe = 0; pe < b.length; pe++)
        if (b[pe].pointerId == B.pointerId) {
          b.splice(pe, 1);
          return;
        }
    }
    function et(B) {
      let pe = G[B.pointerId];
      pe === void 0 && (pe = new me(), G[B.pointerId] = pe), pe.set(B.pageX, B.pageY);
    }
    function Ve(B) {
      const pe = B.pointerId === b[0].pointerId ? b[1] : b[0];
      return G[pe.pointerId];
    }
    this.dollyIn = (B = Y()) => {
      V(B), i.update();
    }, this.dollyOut = (B = Y()) => {
      W(B), i.update();
    }, this.getScale = () => m, this.setScale = (B) => {
      X(B), i.update();
    }, this.getZoomScale = () => Y(), t !== void 0 && this.connect(t), this.update();
  }
};
const LF = /* @__PURE__ */ xe.forwardRef(({
  makeDefault: n,
  camera: e,
  regress: t,
  domElement: i,
  enableDamping: r = !0,
  keyEvents: s = !1,
  onChange: o,
  onStart: l,
  onEnd: c,
  ...f
}, h) => {
  const d = ls((P) => P.invalidate), m = ls((P) => P.camera), v = ls((P) => P.gl), _ = ls((P) => P.events), w = ls((P) => P.setEvents), M = ls((P) => P.set), g = ls((P) => P.get), x = ls((P) => P.performance), S = e || m, T = i || _.connected || v.domElement, C = xe.useMemo(() => new bF(S), [S]);
  return Kp(() => {
    C.enabled && C.update();
  }, -1), xe.useEffect(() => (s && C.connect(s === !0 ? T : s), C.connect(T), () => void C.dispose()), [s, T, t, C, d]), xe.useEffect(() => {
    const P = (R) => {
      d(), t && x.regress(), o && o(R);
    }, L = (R) => {
      l && l(R);
    }, N = (R) => {
      c && c(R);
    };
    return C.addEventListener("change", P), C.addEventListener("start", L), C.addEventListener("end", N), () => {
      C.removeEventListener("start", L), C.removeEventListener("end", N), C.removeEventListener("change", P);
    };
  }, [o, l, c, C, d, w]), xe.useEffect(() => {
    if (n) {
      const P = g().controls;
      return M({
        controls: C
      }), () => M({
        controls: P
      });
    }
  }, [n, C]), /* @__PURE__ */ xe.createElement("primitive", rp({
    ref: h,
    object: C,
    enableDamping: r
  }, f));
}), IF = /* @__PURE__ */ xe.forwardRef(({
  children: n,
  enabled: e = !0,
  speed: t = 1,
  rotationIntensity: i = 1,
  floatIntensity: r = 1,
  floatingRange: s = [-0.1, 0.1],
  autoInvalidate: o = !1,
  ...l
}, c) => {
  const f = xe.useRef(null);
  xe.useImperativeHandle(c, () => f.current, []);
  const h = xe.useRef(Math.random() * 1e4);
  return Kp((d) => {
    var m, v;
    if (!e || t === 0)
      return;
    o && d.invalidate();
    const _ = h.current + d.clock.elapsedTime;
    f.current.rotation.x = Math.cos(_ / 4 * t) / 8 * i, f.current.rotation.y = Math.sin(_ / 4 * t) / 8 * i, f.current.rotation.z = Math.sin(_ / 4 * t) / 20 * i;
    let w = Math.sin(_ / 4 * t) / 10;
    w = zA.mapLinear(w, -0.1, 0.1, (m = s == null ? void 0 : s[0]) !== null && m !== void 0 ? m : -0.1, (v = s == null ? void 0 : s[1]) !== null && v !== void 0 ? v : 0.1), f.current.position.y = w * r, f.current.updateMatrix();
  }), /* @__PURE__ */ xe.createElement("group", l, /* @__PURE__ */ xe.createElement("group", {
    ref: f,
    matrixAutoUpdate: !1
  }, n));
}), ad = ({
  position: n,
  value: e,
  unit: t,
  label: i,
  icon: r,
  color: s = "text-white"
}) => /* @__PURE__ */ se.jsx(MF, { position: n, center: !0, distanceFactor: 10, zIndexRange: [100, 0], children: /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col items-center justify-center p-2 rounded-xl backdrop-blur-md bg-black/60 border border-white/10 shadow-lg min-w-[100px] transition-all hover:scale-110 cursor-default group", children: [
  /* @__PURE__ */ se.jsxs("div", { className: "flex items-center gap-1 mb-1 opacity-70 group-hover:opacity-100 transition-opacity", children: [
    r && /* @__PURE__ */ se.jsx(r, { size: 14, className: s }),
    /* @__PURE__ */ se.jsx("span", { className: "text-[10px] uppercase tracking-wider font-semibold text-gray-300", children: i })
  ] }),
  /* @__PURE__ */ se.jsxs("div", { className: "flex items-baseline gap-1", children: [
    /* @__PURE__ */ se.jsx("span", { className: `text-xl font-bold ${s}`, children: e }),
    /* @__PURE__ */ se.jsx("span", { className: "text-xs text-gray-400", children: t })
  ] }),
  /* @__PURE__ */ se.jsx("div", { className: "w-1 h-4 bg-white/20 absolute -bottom-4 left-1/2 -translate-x-1/2" })
] }) }), as = ({ position: n, args: e, color: t = "#4b5563" }) => /* @__PURE__ */ se.jsxs("mesh", { position: n, castShadow: !0, receiveShadow: !0, children: [
  /* @__PURE__ */ se.jsx("capsuleGeometry", { args: e }),
  /* @__PURE__ */ se.jsx("meshStandardMaterial", { color: t, roughness: 0.3, metalness: 0.8 })
] }), sl = ({ position: n }) => /* @__PURE__ */ se.jsxs("mesh", { position: n, castShadow: !0, children: [
  /* @__PURE__ */ se.jsx("sphereGeometry", { args: [0.16, 16, 16] }),
  /* @__PURE__ */ se.jsx("meshStandardMaterial", { color: "#374151", roughness: 0.5, metalness: 0.5 })
] }), NF = ({ data: n }) => {
  var o, l, c, f;
  const e = xe.useRef(null);
  Kp((h) => {
    e.current && (e.current.position.y = -1 + Math.sin(h.clock.elapsedTime) * 0.05, e.current.rotation.y = Math.sin(h.clock.elapsedTime * 0.2) * 0.1);
  });
  const t = n["sensor.withings_gewicht"], i = n["sensor.withings_muskelmasse"], r = n["sensor.withings_herzschlag"], s = n["sensor.withings_schritte_heute"];
  return /* @__PURE__ */ se.jsxs("group", { ref: e, position: [0, -1, 0], children: [
    /* @__PURE__ */ se.jsxs("mesh", { position: [0, 2.7, 0], castShadow: !0, children: [
      /* @__PURE__ */ se.jsx("sphereGeometry", { args: [0.25, 32, 32] }),
      /* @__PURE__ */ se.jsx("meshStandardMaterial", { color: "#6b7280", roughness: 0.2, metalness: 0.7 })
    ] }),
    /* @__PURE__ */ se.jsxs("mesh", { position: [0, 2.35, 0], children: [
      /* @__PURE__ */ se.jsx("cylinderGeometry", { args: [0.08, 0.1, 0.3, 16] }),
      /* @__PURE__ */ se.jsx("meshStandardMaterial", { color: "#4b5563" })
    ] }),
    /* @__PURE__ */ se.jsxs("mesh", { position: [0, 2, 0], castShadow: !0, children: [
      /* @__PURE__ */ se.jsx("boxGeometry", { args: [0.7, 0.6, 0.35] }),
      /* @__PURE__ */ se.jsx("meshStandardMaterial", { color: "#374151", roughness: 0.3, metalness: 0.6 })
    ] }),
    /* @__PURE__ */ se.jsxs("mesh", { position: [0, 1.5, 0], castShadow: !0, children: [
      /* @__PURE__ */ se.jsx("cylinderGeometry", { args: [0.28, 0.25, 0.6, 16] }),
      /* @__PURE__ */ se.jsx("meshStandardMaterial", { color: "#4b5563", roughness: 0.3, metalness: 0.6 })
    ] }),
    /* @__PURE__ */ se.jsx(as, { position: [-0.5, 1.8, 0], args: [0.1, 0.5, 4, 16] }),
    " ",
    /* @__PURE__ */ se.jsx(sl, { position: [-0.5, 1.4, 0] }),
    /* @__PURE__ */ se.jsx(as, { position: [-0.55, 1, 0.1], args: [0.09, 0.5, 4, 16] }),
    " ",
    /* @__PURE__ */ se.jsx(as, { position: [0.5, 1.8, 0], args: [0.1, 0.5, 4, 16] }),
    " ",
    /* @__PURE__ */ se.jsx(sl, { position: [0.5, 1.4, 0] }),
    /* @__PURE__ */ se.jsx(as, { position: [0.55, 1, 0.1], args: [0.09, 0.5, 4, 16] }),
    " ",
    /* @__PURE__ */ se.jsxs("mesh", { position: [0, 1.1, 0], children: [
      /* @__PURE__ */ se.jsx("cylinderGeometry", { args: [0.26, 0.28, 0.3] }),
      /* @__PURE__ */ se.jsx("meshStandardMaterial", { color: "#374151" })
    ] }),
    /* @__PURE__ */ se.jsx(sl, { position: [-0.25, 1, 0] }),
    /* @__PURE__ */ se.jsx(as, { position: [-0.25, 0.5, 0], args: [0.12, 0.8, 4, 16] }),
    " ",
    /* @__PURE__ */ se.jsx(sl, { position: [-0.25, 0, 0] }),
    /* @__PURE__ */ se.jsx(as, { position: [-0.25, -0.6, 0], args: [0.1, 0.8, 4, 16] }),
    " ",
    /* @__PURE__ */ se.jsx(sl, { position: [0.25, 1, 0] }),
    /* @__PURE__ */ se.jsx(as, { position: [-0.25, 0.5, 0], args: [0.12, 0.8, 4, 16] }),
    /* @__PURE__ */ se.jsx(as, { position: [0.25, 0.5, 0], args: [0.12, 0.8, 4, 16] }),
    " ",
    /* @__PURE__ */ se.jsx(sl, { position: [0.25, 0, 0] }),
    /* @__PURE__ */ se.jsx(as, { position: [0.25, -0.6, 0], args: [0.1, 0.8, 4, 16] }),
    " ",
    /* @__PURE__ */ se.jsx(
      ad,
      {
        position: [0.8, 2.2, 0],
        value: r == null ? void 0 : r.state,
        unit: (o = r == null ? void 0 : r.attributes) == null ? void 0 : o.unit_of_measurement,
        label: "Heart Rate",
        icon: fv,
        color: "text-red-400"
      }
    ),
    /* @__PURE__ */ se.jsx(
      ad,
      {
        position: [-0.9, 1.5, 0],
        value: t == null ? void 0 : t.state,
        unit: (l = t == null ? void 0 : t.attributes) == null ? void 0 : l.unit_of_measurement,
        label: "Current Weight",
        icon: zT,
        color: "text-blue-400"
      }
    ),
    /* @__PURE__ */ se.jsx(
      ad,
      {
        position: [0.8, 1.2, 0],
        value: i == null ? void 0 : i.state,
        unit: (c = i == null ? void 0 : i.attributes) == null ? void 0 : c.unit_of_measurement,
        label: "Muscle Mass",
        icon: hv,
        color: "text-yellow-400"
      }
    ),
    /* @__PURE__ */ se.jsx(
      ad,
      {
        position: [-0.6, -0.5, 0.5],
        value: s == null ? void 0 : s.state,
        unit: (f = s == null ? void 0 : s.attributes) == null ? void 0 : f.unit_of_measurement,
        label: "Steps Today",
        icon: cv,
        color: "text-green-400"
      }
    )
  ] });
}, DF = ({ data: n }) => /* @__PURE__ */ se.jsxs("div", { className: "w-full h-full min-h-[500px] relative bg-gradient-to-b from-gray-900 via-gray-800 to-gray-900 rounded-2xl overflow-hidden shadow-2xl border border-white/5", children: [
  /* @__PURE__ */ se.jsxs("div", { className: "absolute top-4 left-4 z-10", children: [
    /* @__PURE__ */ se.jsx("h2", { className: "text-white/80 font-bold text-lg uppercase tracking-widest", children: "Body Composition" }),
    /* @__PURE__ */ se.jsx("p", { className: "text-white/40 text-xs", children: "Interactive 3D View" })
  ] }),
  /* @__PURE__ */ se.jsxs(hF, { shadows: !0, camera: { position: [0, 1, 5.5], fov: 45 }, children: [
    /* @__PURE__ */ se.jsx("fog", { attach: "fog", args: ["#111827", 5, 15] }),
    /* @__PURE__ */ se.jsx("ambientLight", { intensity: 0.5 }),
    /* @__PURE__ */ se.jsx(
      "directionalLight",
      {
        position: [5, 5, 5],
        intensity: 1,
        castShadow: !0,
        "shadow-mapSize": 1024
      }
    ),
    /* @__PURE__ */ se.jsx("spotLight", { position: [-5, 5, 5], intensity: 0.5, color: "#3b82f6" }),
    /* @__PURE__ */ se.jsx("spotLight", { position: [5, -5, 5], intensity: 0.5, color: "#10b981" }),
    /* @__PURE__ */ se.jsx(IF, { speed: 2, rotationIntensity: 0.2, floatIntensity: 0.2, children: /* @__PURE__ */ se.jsx(NF, { data: n }) }),
    /* @__PURE__ */ se.jsxs("mesh", { rotation: [-Math.PI / 2, 0, 0], position: [0, -2, 0], receiveShadow: !0, children: [
      /* @__PURE__ */ se.jsx("planeGeometry", { args: [10, 10] }),
      /* @__PURE__ */ se.jsx("meshStandardMaterial", { color: "#111827", roughness: 0.8, metalness: 0.2 })
    ] }),
    /* @__PURE__ */ se.jsx(
      LF,
      {
        enableZoom: !1,
        minPolarAngle: Math.PI / 3,
        maxPolarAngle: Math.PI / 1.5,
        enablePan: !1
      }
    )
  ] })
] }), Li = ({
  entity: n,
  icon: e,
  labelOverride: t,
  colorClass: i = "text-blue-500",
  trend: r
}) => {
  var l;
  if (!n)
    return null;
  const s = n.attributes.unit_of_measurement || "", o = t || ((l = n.attributes.friendly_name) == null ? void 0 : l.replace("Withings ", "")) || "Unknown";
  return /* @__PURE__ */ se.jsxs("div", { className: "bg-gray-800/50 backdrop-blur-sm border border-white/5 rounded-xl p-4 flex flex-col justify-between hover:bg-gray-800/80 transition-all duration-300", children: [
    /* @__PURE__ */ se.jsxs("div", { className: "flex justify-between items-start mb-2", children: [
      /* @__PURE__ */ se.jsx("div", { className: `p-2 rounded-lg bg-gray-900/50 ${i}`, children: /* @__PURE__ */ se.jsx(e, { size: 20 }) }),
      r && /* @__PURE__ */ se.jsx("span", { className: `text-xs px-2 py-0.5 rounded-full ${r === "up" ? "bg-green-500/20 text-green-400" : "bg-red-500/20 text-red-400"}`, children: r === "up" ? "" : "" })
    ] }),
    /* @__PURE__ */ se.jsxs("div", { children: [
      /* @__PURE__ */ se.jsx("p", { className: "text-gray-400 text-xs uppercase tracking-wider font-medium truncate", children: o }),
      /* @__PURE__ */ se.jsxs("div", { className: "flex items-baseline gap-1 mt-1", children: [
        /* @__PURE__ */ se.jsx("span", { className: "text-2xl font-bold text-white", children: n.state }),
        /* @__PURE__ */ se.jsx("span", { className: "text-sm text-gray-500 font-medium", children: s })
      ] })
    ] })
  ] });
}, UF = {
  "sensor.withings_aktive_zeit_heute": {
    entity_id: "sensor.withings_aktive_zeit_heute",
    state: 0,
    attributes: { unit_of_measurement: "h", friendly_name: "Aktive Zeit heute" }
  },
  "sensor.withings_diastolischer_blutdruck": {
    entity_id: "sensor.withings_diastolischer_blutdruck",
    state: 70,
    attributes: { unit_of_measurement: "mmHg", friendly_name: "Diastolischer Blutdruck" }
  },
  "sensor.withings_systolischer_blutdruck": {
    entity_id: "sensor.withings_systolischer_blutdruck",
    state: 112,
    attributes: { unit_of_measurement: "mmHg", friendly_name: "Systolischer Blutdruck" }
  },
  "sensor.withings_fettanteil": {
    entity_id: "sensor.withings_fettanteil",
    state: 11.6,
    attributes: { unit_of_measurement: "%", friendly_name: "Fettanteil" }
  },
  "sensor.withings_fettfreie_masse": {
    entity_id: "sensor.withings_fettfreie_masse",
    state: 56.84,
    attributes: { unit_of_measurement: "kg", friendly_name: "Fettfreie Masse" }
  },
  "sensor.withings_fettmasse": {
    entity_id: "sensor.withings_fettmasse",
    state: 7.46,
    attributes: { unit_of_measurement: "kg", friendly_name: "Fettmasse" }
  },
  "sensor.withings_gesamtkalorienverbrauch_heute": {
    entity_id: "sensor.withings_gesamtkalorienverbrauch_heute",
    state: 1575.991,
    attributes: { unit_of_measurement: "kcal", friendly_name: "Gesamtkalorien" }
  },
  "sensor.withings_gewicht": {
    entity_id: "sensor.withings_gewicht",
    state: 65.975,
    attributes: { unit_of_measurement: "kg", friendly_name: "Gewicht" }
  },
  "sensor.withings_zielgewicht": {
    entity_id: "sensor.withings_zielgewicht",
    state: 64.5,
    attributes: { unit_of_measurement: "kg", friendly_name: "Zielgewicht" }
  },
  "sensor.withings_herzschlag": {
    entity_id: "sensor.withings_herzschlag",
    state: 79,
    attributes: { unit_of_measurement: "bpm", friendly_name: "Herzschlag" }
  },
  "sensor.withings_heute_aktiv_verbrannte_kalorien": {
    entity_id: "sensor.withings_heute_aktiv_verbrannte_kalorien",
    state: 3.43,
    attributes: { unit_of_measurement: "kcal", friendly_name: "Aktiv Kalorien" }
  },
  "sensor.withings_heute_zuruckgelegte_strecke": {
    entity_id: "sensor.withings_heute_zuruckgelegte_strecke",
    state: 93.58,
    attributes: { unit_of_measurement: "m", friendly_name: "Strecke" }
  },
  "sensor.withings_knochenmasse": {
    entity_id: "sensor.withings_knochenmasse",
    state: 2.35,
    attributes: { unit_of_measurement: "kg", friendly_name: "Knochenmasse" }
  },
  "sensor.withings_muskelmasse": {
    entity_id: "sensor.withings_muskelmasse",
    state: 54.48,
    attributes: { unit_of_measurement: "kg", friendly_name: "Muskelmasse" }
  },
  "sensor.withings_pulswellengeschwindigkeit": {
    entity_id: "sensor.withings_pulswellengeschwindigkeit",
    state: 6.398,
    attributes: { unit_of_measurement: "m/s", friendly_name: "Pulswelle" }
  },
  "sensor.withings_schritte_heute": {
    entity_id: "sensor.withings_schritte_heute",
    state: 123,
    attributes: { unit_of_measurement: "steps", friendly_name: "Schritte" }
  },
  "sensor.withings_schrittziel": {
    entity_id: "sensor.withings_schrittziel",
    state: 1e4,
    attributes: { unit_of_measurement: "steps", friendly_name: "Schrittziel" }
  },
  "sensor.withings_spo2": {
    entity_id: "sensor.withings_spo2",
    state: 100,
    attributes: { unit_of_measurement: "%", friendly_name: "SpO" }
  }
}, OF = ({ hass: n, config: e }) => {
  var s, o, l, c;
  const t = !n, i = xe.useMemo(() => {
    if (t || !n)
      return UF;
    const f = [
      "sensor.withings_aktive_zeit_heute",
      "sensor.withings_diastolischer_blutdruck",
      "sensor.withings_systolischer_blutdruck",
      "sensor.withings_fettanteil",
      "sensor.withings_fettfreie_masse",
      "sensor.withings_fettmasse",
      "sensor.withings_gesamtkalorienverbrauch_heute",
      "sensor.withings_gewicht",
      "sensor.withings_zielgewicht",
      "sensor.withings_herzschlag",
      "sensor.withings_heute_aktiv_verbrannte_kalorien",
      "sensor.withings_heute_zuruckgelegte_strecke",
      "sensor.withings_knochenmasse",
      "sensor.withings_muskelmasse",
      "sensor.withings_pulswellengeschwindigkeit",
      "sensor.withings_schritte_heute",
      "sensor.withings_schrittziel",
      "sensor.withings_spo2"
    ], h = {};
    return f.forEach((d) => {
      n.states[d] && (h[d] = n.states[d]);
    }), h;
  }, [n, t]), r = (f) => i[`sensor.withings_${f}`];
  return (
    // Wir nutzen hier w-full statt min-h-screen, damit es in die HA Karte passt
    /* @__PURE__ */ se.jsxs("div", { className: "w-full h-full bg-[#0b0f19] text-white p-4 font-sans selection:bg-blue-500/30 rounded-xl", children: [
      (e == null ? void 0 : e.header) !== "false" && /* @__PURE__ */ se.jsxs("header", { className: "mb-6 flex justify-between items-center", children: [
        /* @__PURE__ */ se.jsxs("div", { children: [
          /* @__PURE__ */ se.jsx("h1", { className: "text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-emerald-400", children: (e == null ? void 0 : e.header) || "Health Dashboard" }),
          /* @__PURE__ */ se.jsx("p", { className: "text-gray-400 text-xs mt-1", children: "Withings Ecosystem" })
        ] }),
        t && /* @__PURE__ */ se.jsx("div", { className: "text-xs bg-yellow-500/20 text-yellow-500 px-2 py-1 rounded", children: "DEV MODE" })
      ] }),
      /* @__PURE__ */ se.jsxs("div", { className: "grid grid-cols-1 xl:grid-cols-2 gap-6", children: [
        /* @__PURE__ */ se.jsx("div", { className: "h-[500px] flex flex-col", children: /* @__PURE__ */ se.jsx(DF, { data: i }) }),
        /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col gap-4", children: [
          /* @__PURE__ */ se.jsxs("section", { children: [
            /* @__PURE__ */ se.jsxs("h3", { className: "text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2 flex items-center gap-2", children: [
              /* @__PURE__ */ se.jsx(fv, { size: 14, className: "text-red-500" }),
              " Cardiovascular"
            ] }),
            /* @__PURE__ */ se.jsxs("div", { className: "grid grid-cols-2 md:grid-cols-4 gap-3", children: [
              /* @__PURE__ */ se.jsx(Li, { entity: r("herzschlag"), icon: fv, colorClass: "text-red-500" }),
              /* @__PURE__ */ se.jsx(Li, { entity: r("systolischer_blutdruck"), labelOverride: "Systolic", icon: DS, colorClass: "text-orange-400" }),
              /* @__PURE__ */ se.jsx(Li, { entity: r("diastolischer_blutdruck"), labelOverride: "Diastolic", icon: DS, colorClass: "text-orange-300" }),
              /* @__PURE__ */ se.jsx(Li, { entity: r("pulswellengeschwindigkeit"), labelOverride: "Pulse Wave", icon: cv, colorClass: "text-purple-400" })
            ] })
          ] }),
          /* @__PURE__ */ se.jsxs("section", { children: [
            /* @__PURE__ */ se.jsxs("h3", { className: "text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2 flex items-center gap-2", children: [
              /* @__PURE__ */ se.jsx(NS, { size: 14, className: "text-orange-500" }),
              " Activity"
            ] }),
            /* @__PURE__ */ se.jsxs("div", { className: "grid grid-cols-2 md:grid-cols-4 gap-3", children: [
              /* @__PURE__ */ se.jsx(Li, { entity: r("schritte_heute"), icon: Ub, colorClass: "text-green-400" }),
              /* @__PURE__ */ se.jsx(Li, { entity: r("heute_zuruckgelegte_strecke"), labelOverride: "Distance", icon: cv, colorClass: "text-blue-400" }),
              /* @__PURE__ */ se.jsx(Li, { entity: r("heute_aktiv_verbrannte_kalorien"), labelOverride: "Active Cal", icon: NS, colorClass: "text-orange-500" }),
              /* @__PURE__ */ se.jsx(Li, { entity: r("gesamtkalorienverbrauch_heute"), labelOverride: "Total Burn", icon: hv, colorClass: "text-yellow-400" })
            ] })
          ] }),
          /* @__PURE__ */ se.jsxs("section", { children: [
            /* @__PURE__ */ se.jsxs("h3", { className: "text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2 flex items-center gap-2", children: [
              /* @__PURE__ */ se.jsx(zT, { size: 14, className: "text-blue-500" }),
              " Composition"
            ] }),
            /* @__PURE__ */ se.jsxs("div", { className: "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-3", children: [
              /* @__PURE__ */ se.jsx(Li, { entity: r("fettanteil"), labelOverride: "Fat %", icon: Ob, colorClass: "text-yellow-200" }),
              /* @__PURE__ */ se.jsx(Li, { entity: r("fettmasse"), labelOverride: "Fat kg", icon: IS, colorClass: "text-yellow-600" }),
              /* @__PURE__ */ se.jsx(Li, { entity: r("muskelmasse"), labelOverride: "Muscle", icon: hv, colorClass: "text-red-400" }),
              /* @__PURE__ */ se.jsx(Li, { entity: r("knochenmasse"), labelOverride: "Bone", icon: Db, colorClass: "text-gray-200" }),
              /* @__PURE__ */ se.jsx(Li, { entity: r("spo2"), labelOverride: "SpO", icon: IS, colorClass: "text-cyan-400" })
            ] })
          ] }),
          r("schritte_heute") && r("schrittziel") && /* @__PURE__ */ se.jsxs("section", { className: "bg-gray-800/40 rounded-xl p-4 border border-white/5 mt-2", children: [
            /* @__PURE__ */ se.jsxs("div", { className: "flex justify-between items-end mb-2", children: [
              /* @__PURE__ */ se.jsx("div", { children: /* @__PURE__ */ se.jsx("h4", { className: "text-gray-300 text-sm font-medium", children: "Daily Goal" }) }),
              /* @__PURE__ */ se.jsx("div", { className: "text-right", children: /* @__PURE__ */ se.jsxs("span", { className: "text-xl font-bold text-white", children: [
                Math.round(Number((s = r("schritte_heute")) == null ? void 0 : s.state) / Number((o = r("schrittziel")) == null ? void 0 : o.state) * 100),
                "%"
              ] }) })
            ] }),
            /* @__PURE__ */ se.jsx("div", { className: "w-full bg-gray-700 rounded-full h-2 overflow-hidden", children: /* @__PURE__ */ se.jsx(
              "div",
              {
                className: "bg-gradient-to-r from-blue-500 to-green-400 h-2 rounded-full transition-all duration-1000 ease-out",
                style: { width: `${Math.min(Number((l = r("schritte_heute")) == null ? void 0 : l.state) / Number((c = r("schrittziel")) == null ? void 0 : c.state) * 100, 100)}%` }
              }
            ) })
          ] })
        ] })
      ] })
    ] })
  );
};
class kF extends HTMLElement {
  constructor() {
    super(...arguments), this._root = null;
  }
  set hass(e) {
    this._hass = e, this.render();
  }
  setConfig(e) {
    this._config = e, this.render();
  }
  getCardSize() {
    return 6;
  }
  connectedCallback() {
    this._root || (this._root = v0.createRoot(this)), this.render();
  }
  disconnectedCallback() {
    this._root && (this._root.unmount(), this._root = null);
  }
  render() {
    !this._root || !this._hass || !this._config || this._root.render(
      /* @__PURE__ */ se.jsx(_R.StrictMode, { children: /* @__PURE__ */ se.jsx("div", { className: "withings-card-wrapper text-base", children: /* @__PURE__ */ se.jsx(OF, { hass: this._hass, config: this._config }) }) })
    );
  }
}
const iy = "withings-3d-card";
customElements.get(iy) || (customElements.define(iy, kF), console.info(
  "%c WITHINGS-3D-CARD %c Custom Element registered ",
  "color: white; background: #3b82f6; font-weight: bold;",
  "color: #3b82f6; background: white; font-weight: bold;"
));
window.customCards = window.customCards || [];
window.customCards.push({
  type: iy,
  name: "Withings 3D Health",
  description: "A 3D visualization of your health data"
});
